{"version":3,"names":["Config","centerWave","wave","sum","i","length","average","performIntegral","push","Float32Array","centerAndNormalizeWave","magn","Math","abs","magnAvg","cumulative","newWave","getDrumWave","index","inverseRealFourierTransform","scaleElementsByFactor","chipNoises","samples","chipNoiseLength","drumBuffer","newBuffer","random","drawNoiseSpectrum","sqrt","Error","waveLength","lowOctave","highOctave","lowPower","highPower","overallSlope","lowIndex","pow","highIndex","min","retroWave","combinedAmplitude","lerped","log2","amplitude","radians","PI","cos","sin","generateSquareWave","phaseWidth","sineWaveLength","centerPoint","generateSawWave","inverse","getArpeggioPitchIndex","pitchCount","useFastTwoNoteArp","arpeggio","arpeggioPattern","arpeggioPatterns","toNameMap","array","dictionary","value","name","result","effectsIncludeTransition","effects","effectsIncludeChord","effectsIncludePitchShift","effectsIncludeDetune","effectsIncludeVibrato","effectsIncludeNoteFilter","effectsIncludeDistortion","effectsIncludeBitcrusher","effectsIncludePanning","effectsIncludeChorus","effectsIncludeEcho","effectsIncludeReverb","effectsIncludeNoteRange","effectsIncludeInvertWave","thresholdVal","kneeVal","ratioVal","attackVal","releaseVal","scales","realName","flags","keys","isWhiteKey","basePitch","blackKeyNameParents","tempoMin","tempoMax","echoDelayRange","echoDelayStepTicks","echoSustainRange","echoShelfHz","echoShelfGain","reverbShelfHz","reverbShelfGain","reverbRange","reverbDelayBufferSize","reverbDelayBufferMask","beatsPerBarMin","beatsPerBarMax","barCountMin","barCountMax","instrumentCountMin","layeredInstrumentCountMax","patternInstrumentCountMax","partsPerBeat","ticksPerPart","ticksPerArpeggio","rhythms","stepsPerBeat","roundUpThresholds","instrumentTypeNames","instrumentTypeHasSpecialInterval","chipBaseExpression","fmBaseExpression","noiseBaseExpression","spectrumBaseExpression","drumsetBaseExpression","harmonicsBaseExpression","pwmBaseExpression","pickedStringBaseExpression","distortionBaseVolume","bitcrusherBaseVolume","rawChipWaves","expression","chipWaves","raw","newArray","Array","Object","assign","key","rawChipToIntegrated","pitchFilterMult","isSoft","filterFreqStep","filterFreqRange","filterFreqReferenceSetting","filterFreqReferenceHz","filterFreqMaxHz","filterFreqMinHz","filterGainRange","filterGainCenter","filterGainStep","filterMaxPoints","filterTypeNames","filterMorphCount","filterSimpleCutRange","filterSimplePeakRange","fadeInRange","fadeOutTicks","fadeOutNeutral","drumsetFadeOutTicks","transitions","isSeamless","continues","slides","slideTicks","includeAdjacentPatterns","vibratos","type","delayTicks","vibratoTypes","periodsSeconds","period","arpSpeedScale","unisons","voices","spread","offset","sign","effectNames","effectOrder","noteSizeMax","volumeRange","volumeLogScale","panCenter","panMax","panDelaySecondsMax","chorusRange","chorusPeriodSeconds","chorusDelayRange","chorusDelayOffsets","chorusPhaseOffsets","chorusMaxDelay","concat","reduce","x","y","max","chords","customInterval","arpeggiates","strumParts","singleTone","maxChordSize","operatorCount","maxPitchOrOperatorCount","algorithms","carrierCount","associatedCarrier","modulatedBy","operatorCarrierInterval","operatorAmplitudeMax","operatorFrequencies","mult","hzOffset","amplitudeSign","envelopes","speed","feedbacks","indices","spectrumNoiseLength","spectrumBasePitch","spectrumControlPoints","spectrumControlPointsPerOctave","spectrumControlPointBits","spectrumMax","harmonicsControlPoints","harmonicsRendered","harmonicsRenderedForPickedString","harmonicsControlPointBits","harmonicsMax","harmonicsWavelength","pulseWidthRange","pulseWidthStepPower","pitchChannelCountMin","pitchChannelCountMax","noiseChannelCountMin","noiseChannelCountMax","modChannelCountMin","modChannelCountMax","noiseInterval","pitchesPerOctave","drumCount","pitchOctaves","modCount","maxPitch","maximumTonesPerChannel","justIntonationSemitones","map","pitchShiftRange","pitchShiftCenter","detuneCenter","detuneMax","detuneMin","songDetuneMin","songDetuneMax","sineWaveMask","sineWave","generateSineWave","pickedStringDispersionCenterFreq","pickedStringDispersionFreqScale","pickedStringDispersionFreqMult","pickedStringShelfHz","distortionRange","stringSustainRange","stringDecayRate","bitcrusherFreqRange","bitcrusherOctaveStep","bitcrusherQuantizationRange","maxEnvelopeCount","defaultAutomationRange","instrumentAutomationTargets","computeIndex","displayName","interleave","isFilter","maxCount","effect","compatibleInstruments","operatorWaves","asin","generateTriWave","drive","generateTrapezoidWave","pwmOperatorWaves","barEditorHeight","modulators","pianoName","maxRawVol","newNoteVol","forSong","convertRealFactor","associatedEffect","promptName","promptDesc","ceil","round","test","navigator","userAgent","EditorConfig","valueToPreset","presetValue","categoryIndex","presetIndex","presetCategories","presets","midiProgramToPresetValue","program","category","preset","generalMidi","midiProgram","nameToPresetValue","presetName","factor","countBits","n","isPowerOf2","log","fullArrayLength","totalPasses","pass","subStride","midSubStride","stride","radiansIncrement","cosIncrement","sinIncrement","oscillatorMultiplier","startIndex","startIndexA","midIndexA","startIndexB","midIndexB","stopIndex","realStartA","imagStartB","c","s","cPrev","sPrev","indexA0","indexA1","indexB0","indexB1","real0","real1","imag0","imag1","tempA","tempB","cTemp","sTemp","index1","index2","index3","imag2","imag3","bitCount","finalShift","j","temp","reverseIndexBits","version","versionDisplayName","releaseNotesURL","isOnMac","platform","ctrlSymbol","ctrlName","customType","settings","eqFilter","transition","fadeInSeconds","chord","unison","cutoffHz","linearGain","vibrato","isNoise","filterCutoffHz","filterResonance","filterEnvelope","algorithm","feedbackType","feedbackAmplitude","operators","frequency","target","envelope","customChipWave","noteFilter","reverb","harmonics","stringSustain","feedbackEnvelope","midiSubharmonicOctaves","interval","bitcrusherOctave","bitcrusherQuantization","distortion","pulseWidth","chorus","spectrum","pulseEnvelope","drums","pitchShiftSemitones","Deque","constructor","this","_capacity","_buffer","undefined","_mask","_offset","_count","pushFront","element","_expandCapacity","pushBack","popFront","popBack","peakFront","peakBack","count","set","get","remove","oldBuffer","size","FilterCoefficients","a","b","order","linearGain0thOrder","lowPass1stOrderButterworth","cornerRadiansPerSample","g","tan","a0","lowPass1stOrderSimplified","highPass1stOrderButterworth","highShelf1stOrder","shelfLinearGain","sqrtGain","allPass1stOrderInvertPhaseAbove","allPass1stOrderFractionalDelay","delay","lowPass2ndOrderButterworth","peakLinearGain","alpha","lowPass2ndOrderSimplified","feedback","highPass2ndOrderButterworth","peak2ndOrder","bandWidthScale","bandWidth","FrequencyResponse","real","imag","denom","analyze","filter","radiansPerSample","analyzeComplex","realZ1","imagZ1","realNum","imagNum","realDenom","imagDenom","realZ","imagZ","imagTemp","magnitude","angle","atan2","DynamicBiquadFilter","a1","a2","b0","b1","b2","a1Delta","a2Delta","b0Delta","b1Delta","b2Delta","output1","output2","useMultiplicativeInputCoefficients","resetOutput","loadCoefficientsWithGradient","start","end","deltaRate","epsilon","clamp","val","validateRange","base64IntToCharCode","base64CharCodeToInt","BitFieldReader","source","_bits","_readIndex","charCodeAt","read","readLongTail","minValue","minBits","numBits","readPartDuration","readLegacyPartDuration","readPinCount","readPitchInterval","BitFieldWriter","_index","clear","write","writeLongTail","writePartDuration","writePinCount","writePitchInterval","other","encodeBase64","buffer","lengthBase64","makeNotePin","time","Note","pitch","fadeout","pitches","pins","continuesLastPattern","pickMainInterval","longestFlatIntervalDuration","mainInterval","pinIndex","pinA","pinB","duration","loudestSize","pin","clone","newNote","getEndPinIndex","part","endPinIndex","Pattern","notes","instruments","cloneNotes","note","reset","toJsonObject","song","channel","isModChannel","noteArray","instrument","mod","volumeCap","getVolumeCapForSetting","modFilterTypes","pointArray","useVol","tick","rhythm","pitchBend","volume","forMod","noteObject","points","patternObject","patternInstruments","fromJsonObject","importedPartsPerBeat","isNoiseChannel","isArray","instrumentCount","getMaxInstrumentsPerPatternForChannel","maxNoteCount","beatsPerBar","k","indexOf","startInterval","pointObject","lowestPitch","highestPitch","splice","Operator","waveform","copy","SpectrumWave","hash","isHarmonic","markCustomWaveDirty","hashMult","Synth","fittingPowerOfTwo","point","SpectrumWaveState","_hash","getCustomWave","lowestOctave","pitchTweak","controlPointToOctave","floor","value1","value2","octave1","octave2","HarmonicsWave","HarmonicsWaveState","instrumentType","_generatedForType","combinedControlPointAmplitude","harmonicIndex","harmonicFreq","controlValue","normalizedValue","performIntegralOld","FilterControlPoint","freq","gain","freqSetting","gainSetting","getHz","getHzFromSettingValue","getSettingValueFromHz","hz","getRoundedSettingValueFromHz","getLinearGain","peakMult","power","neutral","interpolatedPower","getRoundedSettingValueFromLinearGain","toCoefficients","sampleRate","freqMult","getVolumeCompensationMult","octave","gainPow","freqRelativeTo8khz","warpedFreq","warpedOctave","distanceFromCenter","freqLoudness","FilterSettings","controlPoints","controlPointCount","addPoint","controlPoint","filterArray","filterObject","filtersCanMorph","filterA","filterB","lerpFilters","pos","lerpedFilter","convertLegacySettings","legacyCutoffSetting","legacyResonanceSetting","legacyEnv","legacyFilterMaxRadians","legacyFilterMax","resonant","firstOrder","cutoffAtMax","legacyFilterCutoffRange","envDecays","standardSampleRate","legacyHz","legacyRadians","extraOctaves","targetRadians","curvedHz","finalHz","finalRadians","legacyFilter","response","legacyFilterGainAtNewRadians","logGain","convertedGain","intendedGain","invertedGain","curvedRadians","legacyFilterGain","convertLegacySettingsForSynth","allowFirstOrder","EnvelopeSettings","envelopeObject","Instrument","chipWave","chipNoise","eqFilterType","eqFilterSimpleCut","eqFilterSimplePeak","noteFilterType","noteFilterSimpleCut","noteFilterSimplePeak","eqSubFilters","noteSubFilters","fadeIn","fadeOut","envelopeCount","pitchShift","detune","vibratoDepth","vibratoSpeed","vibratoDelay","vibratoType","pan","panDelay","arpeggioSpeed","fastTwoNoteArp","legacyTieOver","clicklessTransition","aliases","bitcrusherFreq","echoSustain","echoDelay","LFOtime","nextLFOtime","arpTime","customChipWaveIntegral","harmonicsWave","drumsetEnvelopes","drumsetSpectrumWaves","modChannels","modInstruments","invalidModulators","invertWave","upperNoteLimit","lowerNoteLimit","spectrumWave","wavePrev","setTypeAndReset","legacySettings","forceSimpleFilter","filterCutoff","legacyFilterEnv","legacyPulseEnv","legacyOperatorEnvelopes","operatorEnvelopes","legacyFeedbackEnv","noCarriersControlledByNoteSize","allCarriersControlledByNoteSize","noteSizeControlsSomethingElse","addEnvelope","instrumentObject","eqSimpleCut","eqSimplePeak","getChord","detuneToCents","fadeInSettingToSeconds","fadeOutSettingToTicks","getDrumsetEnvelope","operatorArray","operator","Float64Array","useSlowerRhythm","legacyGlobalReverb","legacyEffectsNames","transitionProperty","binary","seamless","sudden","hard","smooth","soft","slide","secondsToFadeInSetting","ticksToFadeOutSetting","chordProperty","legacyChordNames","harmony","unisonProperty","legacyChorusNames","union","fifths","octaves","centsToDetune","vibratoProperty","legacyVibratoNames","isNaN","findIndex","legacyEnvelopeNames","custom","steady","getEnvelope","drum","legacyWaveNames","triangle","square","sawtooth","spiky","plateau","operatorObject","filterCutoffMaxHz","filterCutoffRange","filterResonanceRange","LN2","legacyToCutoff","legacyToEnvelope","filterNames","oldFilterNames","envelopeArray","tempEnvelope","frequencyFromPitch","makeEmpty","supportsEnvelopeTarget","envelopeSettings","automationTarget","useControlPointCount","clearInvalidEnvelopeTargets","envelopeIndex","getTransition","getFadeInSeconds","getFadeOutTicks","Channel","patterns","bars","muted","Song","string","channels","limitDecay","limitRise","compressionThreshold","limitThreshold","compressionRatio","limitRatio","masterGain","inVolumeCap","outVolumeCap","getNewNoteVolume","isMod","modChannel","modInstrument","vol","tempoIndex","tempo","getVolumeCap","modulator","cap","modSetting","filterType","fromBase64String","initToDefault","getChannelCount","pitchChannelCount","noiseChannelCount","modChannelCount","getMaxInstrumentsPerChannel","layeredInstruments","getMaxInstrumentsPerPattern","channelIndex","getChannelIsNoise","getChannelIsMod","andResetChannels","scale","loopStart","loopLength","barCount","patternsPerChannel","title","document","pattern","bar","toBase64String","bits","_variant","_latestJummBoxVersion","encodedSongTitle","encodeURIComponent","encodedChannelName","console","usingSubFilterBitfield","harmonicsBits","o","spectrumBits","neededBits","shapeBits","bitsPerNoteSize","getNeededBits","maxInstrumentsPerPattern","neededInstrumentCountBits","neededInstrumentIndexBits","neededModInstrumentIndexBits","instrumentIndex","modFilter","status","octaveOffset","lastPitch","recentPitches","recentShapes","curPart","shapePart","startPitch","currentPitch","pitchBends","nextPitch","shapeString","String","fromCharCode","apply","shapeIndex","unshift","pop","allPitches","pitchIndex","pitchIter","stringLength","digits","prototype","maxApplyArgs","slice","_envelopeFromLegacyIndex","legacyIndex","compressed","charIndex","JSON","parse","substring","fromBeepBox","fromJummBox","_latestBeepboxVersion","_oldestBeepboxVersion","_oldestJummBoxVersion","beforeTwo","beforeThree","beforeFour","beforeFive","beforeSix","beforeSeven","beforeEight","beforeNine","legacySettingsCache","command","instrumentChannelIterator","instrumentIndexIterator","useSlowerArpSpeed","songNameLength","decodeURIComponent","channelCount","instrumentsPerChannel","instrumentsFlagBits","legacyWaves","typeCheck","originalControlPointCount","originalSubfilterControlPointCount","legacyEffects","legacyEnvelopes","originalValue","nextValue","restoreLimiterDefaults","channelNameLength","byteCount","subStringLength","bitStringLength","largerChords","recentPitchBitLength","recentPitchLength","bitStringLengthLength","songReverbChannel","songReverbInstrument","songReverbIndex","forNoteFilter","detuneScaleNotes","newPattern","newNotes","noteCount","useOldShape","shape","pinCount","initialSize","bendCount","pinObj","intervalIter","shift","isBackwards","restLength","patternIndex","lowestPart","chn","enableIntro","loopCount","enableOutro","channelArray","instrumentArray","patternArray","sequenceArray","l","channelObject","sequence","format","_format","introBars","loopBars","ticksPerBeat","beatsPerMinute","jsonObject","oldScaleNames","enigma","scaleName","letter","charAt","toUpperCase","symbol","toLowerCase","C","D","E","F","G","A","B","maxInstruments","maxPatterns","maxBars","newPitchChannels","newNoiseChannels","newModChannels","instrumentObjects","getPattern","getBeatsPerMinute","maxValue","clz32","PickedString","delayLine","allPassG","allPassGDelta","shelfA1","shelfA1Delta","shelfB0","shelfB0Delta","shelfB1","shelfB1Delta","delayIndex","allPassSample","allPassPrevInput","shelfSample","shelfPrevInput","fractionalDelaySample","prevDelayLength","delayResetOffset","update","synth","instrumentState","tone","stringIndex","roundedSamplesPerTick","stringDecayStart","stringDecayEnd","allPassCenter","samplesPerSecond","shelfRadians","decayCurveStart","decayCurveEnd","phaseDeltaStart","phaseDeltas","phaseDeltaScale","phaseDeltaScales","phaseDeltaEnd","radiansPerSampleStart","radiansPerSampleEnd","centerHarmonicStart","centerHarmonicEnd","allPassRadiansStart","allPassRadiansEnd","decayRateStart","decayRateEnd","shelfGainStart","shelfGainEnd","expressionDecayStart","expressionDecayEnd","tempFilterStartCoefficients","tempFrequencyResponse","allPassGStart","allPassPhaseDelayStart","tempFilterEndCoefficients","allPassGEnd","allPassPhaseDelayEnd","shelfA1Start","shelfB0Start","shelfB1Start","shelfPhaseDelayStart","shelfA1End","shelfB0End","shelfB1End","shelfPhaseDelayEnd","periodLengthStart","periodLengthEnd","minBufferLength","delayLength","delayLengthEnd","delayLengthDelta","pitchChanged","reinitializeImpulse","likelyMaximumLength","newDelayLine","oldDelayBufferMask","startCopyingFromIndex","delayBufferMask","startImpulseFrom","startZerosFrom","stopZerosAt","impulseWave","impulseWaveLength","impulsePhaseDelta","fadeDuration","startImpulseFromSample","stopImpulseAt","stopImpulseAtSample","impulsePhase","prevWaveIntegral","impulsePhaseInt","nextWaveIntegral","phaseRatio","sample","combinedFade","curvedFade","EnvelopeComputer","noteSecondsStart","noteSecondsEnd","noteTicksStart","noteTicksEnd","noteSizeStart","noteSizeEnd","prevNoteSize","nextNoteSize","_noteSizeFinal","prevNoteSecondsStart","prevNoteSecondsEnd","prevNoteTicksStart","prevNoteTicksEnd","_prevNoteSizeFinal","prevSlideStart","prevSlideEnd","nextSlideStart","nextSlideEnd","prevSlideRatioStart","prevSlideRatioEnd","nextSlideRatioStart","nextSlideRatioEnd","envelopeStarts","envelopeEnds","_modifiedEnvelopeIndices","_modifiedEnvelopeCount","lowpassCutoffDecayVolumeCompensation","computeEnvelopes","currentPart","tickTimeStart","secondsPerTick","atNoteStart","forceContinueAtStart","tickTimeEnd","beatsPerTick","beatTimeStart","beatTimeEnd","passedEndOfNote","startPin","endPin","startPinTick","endPinTick","ratioStart","ratioEnd","noteStartTick","noteStartPart","noteEndTick","noteEndPart","maximumSlideTicks","prevNote","nextNote","forceContinueAtEnd","usedNoteSize","targetIndex","envelopeStart","computeEnvelope","envelopeEnd","filterSettings","tmpNoteFilterStart","getLowpassCutoffDecayVolumeCompensation","clearEnvelopes","beats","noteSize","noteSizeToVolumeMult","attack","Tone","fill","chordSize","drumsetPitch","prevNotePitchIndex","nextNotePitchIndex","freshlyAllocated","isOnLastTick","ticksSinceReleased","liveInputSamplesHeld","lastInterval","noiseSample","stringSustainStart","stringSustainEnd","phases","expressionDelta","operatorExpressions","operatorExpressionDeltas","prevPitchExpressions","prevVibrato","prevStringDecay","pulseWidthDelta","pickedStrings","noteFilters","noteFilterCount","initialNoteFilterInput1","initialNoteFilterInput2","specialIntervalExpressionMult","feedbackOutputs","feedbackMult","feedbackDelta","stereoVolumeLStart","stereoVolumeRStart","stereoVolumeLDelta","stereoVolumeRDelta","stereoDelayStart","stereoDelayEnd","stereoDelayDelta","customVolumeStart","customVolumeEnd","filterResonanceStart","filterResonanceDelta","isFirstOrder","envelopeComputer","pickedString","InstrumentState","awake","computed","tonesAddedInThisTick","flushingDelayLines","deactivateAfterThisTick","attentuationProgress","flushedSamples","activeTones","activeModTones","releasedTones","liveInputTones","synthesizer","noisePitchFilterMult","volumeScale","eqFilterVolume","eqFilterVolumeDelta","mixVolume","mixVolumeDelta","delayInputMult","delayInputMultDelta","distortionDelta","distortionDrive","distortionDriveDelta","distortionFractionalInput1","distortionFractionalInput2","distortionFractionalInput3","distortionPrevInput","distortionNextOutput","bitcrusherPrevInput","bitcrusherCurrentOutput","bitcrusherPhase","bitcrusherPhaseDelta","bitcrusherPhaseDeltaScale","bitcrusherScale","bitcrusherScaleScale","bitcrusherFoldLevel","bitcrusherFoldLevelScale","eqFilters","eqFilterCount","initialEqFilterInput1","initialEqFilterInput2","panningDelayLine","panningDelayPos","panningVolumeL","panningVolumeR","panningVolumeDeltaL","panningVolumeDeltaR","panningOffsetL","panningOffsetR","panningOffsetDeltaL","panningOffsetDeltaR","chorusDelayLineL","chorusDelayLineR","chorusDelayLineDirty","chorusDelayPos","chorusPhase","chorusVoiceMult","chorusVoiceMultDelta","chorusCombinedMult","chorusCombinedMultDelta","echoDelayLineL","echoDelayLineR","echoDelayLineDirty","echoDelayPos","echoDelayOffsetStart","echoDelayOffsetEnd","echoDelayOffsetRatio","echoDelayOffsetRatioDelta","echoMult","echoMultDelta","echoShelfA1","echoShelfB0","echoShelfB1","echoShelfSampleL","echoShelfSampleR","echoShelfPrevInputL","echoShelfPrevInputR","reverbDelayLine","reverbDelayLineDirty","reverbDelayPos","reverbMult","reverbMultDelta","reverbShelfA1","reverbShelfB0","reverbShelfB1","reverbShelfSample0","reverbShelfSample1","reverbShelfSample2","reverbShelfSample3","reverbShelfPrevInput0","reverbShelfPrevInput1","reverbShelfPrevInput2","reverbShelfPrevInput3","allocateNecessaryBuffers","samplesPerTick","panningDelayBufferSize","chorusDelayBufferSize","safeEchoDelaySteps","safeEchoDelayBufferSize","newDelayLineL","newDelayLineR","oldMask","deactivate","resetAllEffects","compute","getInstrumentSynthFunction","updateWaves","usesDistortion","usesBitcrusher","usesPanning","usesChorus","usesEcho","usesReverb","useDistortionStart","useDistortionEnd","isModActive","getModValue","distortionSliderStart","distortionSliderEnd","distortionStart","distortionEnd","distortionDriveStart","distortionDriveEnd","freqSettingStart","freqSettingEnd","quantizationSettingStart","quantizationSettingEnd","freqStart","freqEnd","scaleStart","scaleEnd","foldLevelStart","foldLevelEnd","eqFilterSettingsStart","eqFilterSettingsEnd","startPoint","startSimpleFreq","startSimpleGain","endSimpleFreq","endSimpleGain","filterChanges","endPoint","eqFilterSettings","tmpEqFilterStart","tmpEqFilterEnd","mainInstrumentVolume","instrumentVolumeToVolumeMult","mixVolumeEnd","startVal","endVal","eqFilterVolumeStart","eqFilterVolumeEnd","delayInputMultStart","delayInputMultEnd","usePanStart","usePanEnd","panStart","panEnd","volumeStartL","volumeStartR","volumeEndL","volumeEndR","maxDelaySamples","usePanDelayStart","usePanDelayEnd","delayStart","delayEnd","delayStartL","delayStartR","delayEndL","delayEndR","useChorusStart","useChorusEnd","chorusStart","chorusEnd","chorusCombinedMultStart","chorusCombinedMultEnd","maxEchoMult","averageEchoDelaySeconds","useEchoSustainStart","useEchoSustainEnd","echoMultStart","echoMultEnd","useEchoDelayStart","useEchoDelayEnd","ignoreTicks","tmpEchoDelayOffsetStart","tmpEchoDelayOffsetEnd","maxReverbMult","useReverbStart","useReverbEnd","reverbStart","reverbEnd","totalDelaySamples","attenuationThreshold","halfLifeMult","delayDuration","attenuationPerSecond","averageMult","averageReverbDelaySeconds","progressInTick","progressAtEndOfTick","_drumsetIndexToSpectrumOctave","getDrumsetWave","drumsetIndexReferenceDelta","ChannelState","singleSeamlessInstrument","preferLowerLatency","anticipatePoorPerformance","liveInputDuration","liveInputStarted","liveInputPitches","liveInputChannel","liveInputInstruments","loopRepeatCount","enableMetronome","countInMetronome","renderingSong","wantToSkip","playheadInternal","prevBar","nextBar","beat","isAtStartOfTick","isAtEndOfTick","tickSampleCountdown","modValues","modInsValues","nextModValues","nextModInsValues","isPlayingSong","isRecording","liveInputEndTime","browserAutomaticallyClearsAudioBuffer","tempDrumSetControlPoint","tonePool","tempMatchedPitchTones","startedMetronome","metronomeSamplesRemaining","metronomeAmplitude","metronomePrevAmplitude","metronomeFilter","limit","tempMonoInstrumentSampleBuffer","audioCtx","scriptNode","audioProcessCallback","audioProcessingEvent","outputBuffer","outputDataL","getChannelData","outputDataR","performance","now","deactivateAudio","synthesize","computeDelayBufferSizes","setSong","syncSongState","channelState","warmUpSynthesizer","getSamplesPerTick","tmpNoteFilterEnd","dummyArray","computeLatestModValues","latestModTimes","latestModInsTimes","currentBar","instrumentIdx","latestPinParts","latestPinValues","partsInBar","findPartsInBar","pinIdx","transitionLength","toNextBarLength","deltaVolume","setModValue","usedInstruments","tgtPattern","eqFilterParam","noteFilterParam","modulatorAdjust","tgtInstrument","determineInvalidModulators","tgtInstrumentList","str","operatorAmplitudeCurve","playing","recording","playhead","remainder","getSamplesPerBar","getTicksIntoBar","getCurrentPart","getTotalSamples","loop","startBar","endBar","hasTempoMods","hasNextBarMods","prevTempo","latestTempoPin","latestTempoValue","ended","totalSamples","foundMod","find","sort","getSamplesPerTickSpecificBPM","tickLength","prevPinTempo","currPinTempo","bpmScalar","getTotalBars","useLoopCount","panningDelayBufferMask","chorusDelayBufferMask","activateAudio","bufferSize","latencyHint","window","AudioContext","webkitAudioContext","createScriptProcessor","createJavaScriptNode","onaudioprocess","channelCountMode","channelInterpretation","connect","destination","resume","disconnect","close","maintainLiveInput","play","pause","startRecording","resetEffects","freeAllTones","volumeStart","volumeEnd","setting","nextVal","isAnyModActive","unsetMod","isFilterModActive","channelIdx","snapToStart","snapToBar","goToBar","jumpIntoLoop","oldBar","goToNextBar","goToPrevBar","getNextBar","skipBar","outputBufferLength","playSong","skippedBars","firstSkippedBufferIndex","bufferIndex","samplesLeftInBuffer","samplesLeftInTick","runLength","runEnd","determineCurrentActiveTones","playModTone","barVisited","includes","determineLiveInputTones","tonesPlayedInThisInstrument","freeReleasedTone","shouldFadeOutFast","computeTone","playTone","effectsSynth","startRatio","endRatio","ticksIntoBar","partTimeTickStart","partTimeTickEnd","partTimeStart","partTimeEnd","useVibratoSpeed","midBeat","periods","samplesPerPeriod","tempAmplitude","sampleL","sampleR","absL","absR","limitRange","limitTarget","limitedVolume","useArpeggioSpeed","Number","isInteger","isFinite","freeTone","newTone","releaseTone","toneIndex","toneList","toneCount","filteredPitches","moveTonesIntoOrderedTempMatchedList","clearTempMatchedPitchTones","adjacentPatternHasCompatibleInstrumentTransition","otherPattern","otherNote","forceContinue","otherInstrument","otherTransition","adjacentNotesHaveMatchingPitches","firstNote","secondNote","firstNoteInterval","notePitches","currentTick","prevNotes","nextNotes","fillCount","modToneCount","newInstrumentIndex","sourceInstrumentState","destInstrumentState","prevNoteForThisInstrument","nextNoteForThisInstrument","oldTone","partsPerBar","tonesInPrevNote","tonesInNextNote","prevPattern","lastNote","patternForcesContinueAtStart","chordOfCompatibleInstrument","nextPattern","nextPatternForcesContinueAtStart","strumOffsetParts","prevNoteForThisTone","noteForThisTone","nextNoteForThisTone","released","modSynth","computeChordExpression","chordExpression","intervalScale","secondsPerPart","sampleTime","beatsPerPart","specialIntervalMult","toneIsOnLastTick","intervalStart","intervalEnd","fadeExpressionStart","fadeExpressionEnd","chordExpressionStart","chordExpressionEnd","expressionReferencePitch","baseExpression","pitchDamping","getOperatorWave","startTicksSinceReleased","endTicksSinceReleased","pinStart","pinEnd","noteTicksPassedTickStart","noteTicksPassedTickEnd","pinRatioStart","pinRatioEnd","noteLengthTicks","tmpNoteFilter","noteFilterSettingsStart","noteFilterSettingsEnd","intervalDiff","chordSizeDiff","pitchShiftScalarStart","pitchShiftScalarEnd","modDetuneStart","modDetuneEnd","vibratoAmplitudeStart","vibratoAmplitudeEnd","vibratoStart","POSITIVE_INFINITY","getLFOAmplitude","ticksUntilVibratoStart","lfoEnd","vibratoDepthEnvelopeEnd","vibratoEnd","ticksUntilVibratoEnd","noteFilterExpression","noteAllFreqsEnvelopeStart","noteAllFreqsEnvelopeEnd","noteFreqEnvelopeStart","noteFreqEnvelopeEnd","notePeakEnvelopeStart","notePeakEnvelopeEnd","noteFilterSettings","drumsetFilterEnvelope","drumsetFilterEnvelopeStart","drumsetFilterEnvelopeEnd","sineExpressionBoost","totalCarrierExpression","arpeggioInterval","associatedCarrierIndex","pitchStart","pitchEnd","baseFreqStart","baseFreqEnd","targetFreqStart","targetFreqEnd","freqEnvelopeStart","freqEnvelopeEnd","amplitudeStart","amplitudeEnd","amplitudeCurveStart","amplitudeCurveEnd","expressionStart","expressionEnd","pitchExpressionStart","pitchExpressionEnd","useFeedbackAmplitudeStart","useFeedbackAmplitudeEnd","feedbackAmplitudeStart","feedbackAmplitudeEnd","feedbackStart","feedbackEnd","basePhaseDeltaScale","intervalOffset","endPitch","settingsExpressionMult","basePulseWidth","pulseWidthModStart","pulseWidthModEnd","pulseWidthStart","pulseWidthEnd","useSustainStart","useSustainEnd","startFreq","voiceCountExpression","unisonEnvelopeStart","unisonEnvelopeEnd","unisonAStart","unisonAEnd","unisonBStart","unisonBEnd","sustainEnvelopeStart","sustainEnvelopeEnd","secondsIntoBar","vibratoPeriodSeconds","fingerprint","fmSynthFunctionCache","synthSource","line","fmSourceTemplate","outputs","replace","join","operatorLine","operatorSourceTemplate","modulatorNumber","feedbackIndices","Function","chipSynth","harmonicsSynth","pulseWidthSynth","pickedStringSynth","noiseSynth","spectrumSynth","drumsetSynth","data","unisonSign","phaseDeltaA","phaseDeltaB","phaseDeltaScaleA","phaseDeltaScaleB","phaseA","phaseB","filters","filterCount","initialFilterInput1","initialFilterInput2","applyFilters","prevWaveIntegralA","prevWaveIntegralB","phaseAInt","phaseBInt","indexA","indexB","phaseRatioA","phaseRatioB","sampleIndex","waveA","waveB","inputSample","nextWaveIntegralA","nextWaveIntegralB","output","sanitizeFilters","voiceCount","pickedStringFunction","pickedStringFunctionCache","pickedStringSource","sampleList","voice","lines","usesEqFilter","signature","effectsFunction","effectsFunctionCache","effectsSource","usesDelays","phaseDelta","phase","sawPhaseA","sawPhaseB","pulseWave","t","randOff","phaseMask","pitchRelativefilter","findRandomZeroCrossing","phaseInt","waveSample","referenceDelta","stereoBufferIndex","dotTarget","lerpEndRatio","indexPrev","attemptsRemaining","indexNext","waveNext","innerIndexNext","innerWaveNext","slope","instrumentVolume","volumeMultToInstrumentVolume","volumeMult","volumeMultToNoteSize","seconds","ticks","lower","upper","cents","beatsPerSecond","partsPerSecond","tickPerSecond","sanitizeDelayLine","lastIndex","mask","input1","input2","split"],"sources":["../synth/SynthConfig.ts","../editor/EditorConfig.ts","../synth/FFT.ts","../synth/Deque.ts","../synth/filtering.ts","../synth/synth.ts"],"sourcesContent":["/*!\r\nCopyright (c) 2012-2022 John Nesky and contributing authors\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of \r\nthis software and associated documentation files (the \"Software\"), to deal in \r\nthe Software without restriction, including without limitation the rights to \r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \r\nof the Software, and to permit persons to whom the Software is furnished to do \r\nso, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all \r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \r\nSOFTWARE.\r\n*/\r\n\r\nexport interface Dictionary<T> {\r\n    [K: string]: T;\r\n}\r\n\r\nexport interface DictionaryArray<T> extends ReadonlyArray<T> {\r\n    dictionary: Dictionary<T>;\r\n}\r\n\r\nexport const enum FilterType {\r\n    lowPass,\r\n    highPass,\r\n    peak,\r\n    length,\r\n}\r\n\r\nexport const enum EnvelopeType {\r\n    noteSize,\r\n    none,\r\n    punch,\r\n    flare,\r\n    twang,\r\n    swell,\r\n    tremolo,\r\n    tremolo2,\r\n    decay,\r\n}\r\n\r\nexport const enum InstrumentType {\r\n    chip,\r\n    fm,\r\n    noise,\r\n    spectrum,\r\n    drumset,\r\n    harmonics,\r\n    pwm,\r\n    pickedString,\r\n    customChipWave,\r\n    mod,\r\n    length,\r\n}\r\n\r\nexport const enum DropdownID {\r\n    Vibrato = 0,\r\n    Pan = 1,\r\n    Chord = 2,\r\n    Transition = 3,\r\n    FM = 4,\r\n\r\n}\r\n\r\nexport const enum EffectType {\r\n    reverb,\r\n    chorus,\r\n    panning,\r\n    distortion,\r\n    bitcrusher,\r\n    noteFilter,\r\n    echo,\r\n    pitchShift,\r\n    detune,\r\n    vibrato,\r\n    transition,\r\n    chord,\r\n    noteRange,\r\n    invertWave,\r\n    length,\r\n}\r\n\r\nexport const enum EnvelopeComputeIndex {\r\n    noteVolume,\r\n    noteFilterAllFreqs,\r\n    pulseWidth,\r\n    stringSustain,\r\n    unison,\r\n    operatorFrequency0, operatorFrequency1, operatorFrequency2, operatorFrequency3,\r\n    operatorAmplitude0, operatorAmplitude1, operatorAmplitude2, operatorAmplitude3,\r\n    feedbackAmplitude,\r\n    pitchShift,\r\n    detune,\r\n    vibratoDepth,\r\n    noteFilterFreq0, noteFilterFreq1, noteFilterFreq2, noteFilterFreq3, noteFilterFreq4, noteFilterFreq5, noteFilterFreq6, noteFilterFreq7,\r\n    noteFilterGain0, noteFilterGain1, noteFilterGain2, noteFilterGain3, noteFilterGain4, noteFilterGain5, noteFilterGain6, noteFilterGain7,\r\n    length,\r\n}\r\n\r\n/*\r\nexport const enum InstrumentAutomationIndex {\r\n    mixVolume,\r\n    eqFilterAllFreqs,\r\n    eqFilterFreq0, eqFilterFreq1, eqFilterFreq2, eqFilterFreq3, eqFilterFreq4, eqFilterFreq5, eqFilterFreq6, eqFilterFreq7,\r\n    eqFilterGain0, eqFilterGain1, eqFilterGain2, eqFilterGain3, eqFilterGain4, eqFilterGain5, eqFilterGain6, eqFilterGain7,\r\n    distortion,\r\n    bitcrusherQuantization,\r\n    bitcrusherFrequency,\r\n    panning,\r\n    chorus,\r\n    echoSustain,\r\n    //echoDelay, // Wait until tick settings can be computed once for multiple run lengths.\r\n    reverb,\r\n    length,\r\n}\r\n*/\r\n\r\nexport interface BeepBoxOption {\r\n    readonly index: number;\r\n    readonly name: string;\r\n}\r\n\r\nexport interface Scale extends BeepBoxOption {\r\n    readonly flags: ReadonlyArray<boolean>;\r\n    readonly realName: string;\r\n}\r\n\r\nexport interface Key extends BeepBoxOption {\r\n    readonly isWhiteKey: boolean;\r\n    readonly basePitch: number;\r\n}\r\n\r\nexport interface Rhythm extends BeepBoxOption {\r\n    readonly stepsPerBeat: number;\r\n    readonly roundUpThresholds: number[] | null;\r\n}\r\n\r\nexport interface ChipWave extends BeepBoxOption {\r\n    readonly expression: number;\r\n    samples: Float32Array;\r\n}\r\n\r\nexport interface OperatorWave extends BeepBoxOption {\r\n    samples: Float32Array;\r\n}\r\n\r\nexport interface ChipNoise extends BeepBoxOption {\r\n    readonly expression: number;\r\n    readonly basePitch: number;\r\n    readonly pitchFilterMult: number;\r\n    readonly isSoft: boolean;\r\n    samples: Float32Array | null;\r\n}\r\n\r\nexport interface Transition extends BeepBoxOption {\r\n    readonly isSeamless: boolean;\r\n    readonly continues: boolean;\r\n    readonly slides: boolean;\r\n    readonly slideTicks: number;\r\n    readonly includeAdjacentPatterns: boolean;\r\n}\r\n\r\nexport interface Vibrato extends BeepBoxOption {\r\n    readonly amplitude: number;\r\n    readonly type: number;\r\n    readonly delayTicks: number;\r\n}\r\n\r\nexport interface VibratoType extends BeepBoxOption {\r\n    readonly periodsSeconds: number[];\r\n    readonly period: number;\r\n}\r\n\r\nexport interface Unison extends BeepBoxOption {\r\n    readonly voices: number;\r\n    readonly spread: number;\r\n    readonly offset: number;\r\n    readonly expression: number;\r\n    readonly sign: number;\r\n}\r\n\r\nexport interface Modulator extends BeepBoxOption {\r\n    readonly name: string; // name that shows up in song editor UI\r\n    readonly pianoName: string; // short name that shows up in mod piano UI\r\n    readonly maxRawVol: number; // raw\r\n    readonly newNoteVol: number; // raw\r\n    readonly forSong: boolean; // true - setting is song scope\r\n    convertRealFactor: number; // offset that needs to be applied to get a \"real\" number display of value, for UI purposes\r\n    readonly associatedEffect: EffectType; // effect that should be enabled for this modulator to work properly. If unused, set to EffectType.length.\r\n    readonly promptName: string; // long-as-needed name that shows up in tip prompt\r\n    readonly promptDesc: string[]; // paragraph(s) describing how to use this mod\r\n\r\n}\r\n\r\nexport interface Chord extends BeepBoxOption {\r\n    readonly customInterval: boolean;\r\n    readonly arpeggiates: boolean;\r\n    readonly strumParts: number;\r\n    readonly singleTone: boolean;\r\n}\r\n\r\nexport interface Algorithm extends BeepBoxOption {\r\n    readonly carrierCount: number;\r\n    readonly associatedCarrier: ReadonlyArray<number>;\r\n    readonly modulatedBy: ReadonlyArray<ReadonlyArray<number>>;\r\n}\r\n\r\nexport interface OperatorFrequency extends BeepBoxOption {\r\n    readonly mult: number;\r\n    readonly hzOffset: number;\r\n    readonly amplitudeSign: number;\r\n}\r\n\r\nexport interface Feedback extends BeepBoxOption {\r\n    readonly indices: ReadonlyArray<ReadonlyArray<number>>;\r\n}\r\n\r\nexport interface Envelope extends BeepBoxOption {\r\n    readonly type: EnvelopeType;\r\n    readonly speed: number;\r\n}\r\n\r\nexport interface AutomationTarget extends BeepBoxOption {\r\n    readonly computeIndex: EnvelopeComputeIndex /*| InstrumentAutomationIndex*/ | null;\r\n    readonly displayName: string;\r\n    //readonly perNote: boolean; // Whether to compute envelopes on a per-note basis.\r\n    readonly interleave: boolean; // Whether to interleave this target with the next one in the menu.\r\n    readonly isFilter: boolean; // Filters have a variable maxCount in practice.\r\n    //readonly range: number | null; // set if automation is allowed.\r\n    readonly maxCount: number;\r\n    readonly effect: EffectType | null;\r\n    readonly compatibleInstruments: InstrumentType[] | null;\r\n}\r\n\r\nexport class Config {\r\n    // Params for post-processing compressor\r\n    public static thresholdVal: number = -10;\r\n    public static kneeVal: number = 40;\r\n    public static ratioVal: number = 12;\r\n    public static attackVal: number = 0;\r\n    public static releaseVal: number = 0.25;\r\n\r\n    public static readonly scales: DictionaryArray<Scale> = toNameMap([\r\n\r\n        //   C     Db      D     Eb      E      F     F#      G     Ab      A     Bb      B      C\r\n        { name: \"Free\", realName: \"chromatic\", flags: [true, true, true, true, true, true, true, true, true, true, true, true] }, // Free\r\n        { name: \"Major\", realName: \"ionian\", flags: [true, false, true, false, true, true, false, true, false, true, false, true] }, // Major\r\n        { name: \"Minor\", realName: \"aeolian\", flags: [true, false, true, true, false, true, false, true, true, false, true, false] }, // Minor\r\n        { name: \"Mixolydian\", realName: \"mixolydian\", flags: [true, false, true, false, true, true, false, true, false, true, true, false] }, // Mixolydian\r\n        { name: \"Lydian\", realName: \"lydian\", flags: [true, false, true, false, true, false, true, true, false, true, false, true] }, // Lydian\r\n        { name: \"Dorian\", realName: \"dorian\", flags: [true, false, true, true, false, true, false, true, false, true, true, false] }, // Dorian\r\n        { name: \"Phrygian\", realName: \"phrygian\", flags: [true, true, false, true, false, true, false, true, true, false, true, false] }, // Phrygian\r\n        { name: \"Locrian\", realName: \"locrian\", flags: [true, true, false, true, false, true, true, false, true, false, true, false] }, // Locrian\r\n        { name: \"Lydian Dominant\", realName: \"lydian dominant\", flags: [true, false, true, false, true, false, true, true, false, true, true, false] }, // Lydian Dominant\r\n        { name: \"Phrygian Dominant\", realName: \"phrygian dominant\", flags: [true, true, false, false, true, true, false, true, true, false, true, false] }, // Phrygian Dominant\r\n        { name: \"Harmonic Major\", realName: \"harmonic major\", flags: [true, false, true, false, true, true, false, true, true, false, false, true] }, // Harmonic Major\r\n        { name: \"Harmonic Minor\", realName: \"harmonic minor\", flags: [true, false, true, true, false, true, false, true, true, false, false, true] }, // Harmonic Minor\r\n        { name: \"Melodic Minor\", realName: \"melodic minor\", flags: [true, false, true, true, false, true, false, true, false, true, false, true] }, // Melodic Minor\r\n        { name: \"Blues\", realName: \"blues\", flags: [true, false, false, true, false, true, true, true, false, false, true, false] }, // Blues\r\n        { name: \"Altered\", realName: \"altered\", flags: [true, true, false, true, true, false, true, false, true, false, true, false] }, // Altered\r\n        { name: \"Major Pentatonic\", realName: \"major pentatonic\", flags: [true, false, true, false, true, false, false, true, false, true, false, false] }, // Major Pentatonic\r\n        { name: \"Minor Pentatonic\", realName: \"minor pentatonic\", flags: [true, false, false, true, false, true, false, true, false, false, true, false] }, // Minor Pentatonic\r\n        { name: \"Whole Tone\", realName: \"whole tone\", flags: [true, false, true, false, true, false, true, false, true, false, true, false] }, // Whole Tone\r\n        { name: \"Octatonic\", realName: \"octatonic\", flags: [true, false, true, true, false, true, true, false, true, true, false, true] }, // Octatonic\r\n        { name: \"Hexatonic\", realName: \"hexatonic\", flags: [true, false, false, true, true, false, false, true, true, false, false, true] }, // Hexatonic\r\n\r\n\r\n    ]);\r\n    public static readonly keys: DictionaryArray<Key> = toNameMap([\r\n        { name: \"C\", isWhiteKey: true, basePitch: 12 }, // C0 has index 12 on the MIDI scale. C7 is 96, and C9 is 120. C10 is barely in the audible range.\r\n        { name: \"C♯\", isWhiteKey: false, basePitch: 13 },\r\n        { name: \"D\", isWhiteKey: true, basePitch: 14 },\r\n        { name: \"D♯\", isWhiteKey: false, basePitch: 15 },\r\n        { name: \"E\", isWhiteKey: true, basePitch: 16 },\r\n        { name: \"F\", isWhiteKey: true, basePitch: 17 },\r\n        { name: \"F♯\", isWhiteKey: false, basePitch: 18 },\r\n        { name: \"G\", isWhiteKey: true, basePitch: 19 },\r\n        { name: \"G♯\", isWhiteKey: false, basePitch: 20 },\r\n        { name: \"A\", isWhiteKey: true, basePitch: 21 },\r\n        { name: \"A♯\", isWhiteKey: false, basePitch: 22 },\r\n        { name: \"B\", isWhiteKey: true, basePitch: 23 },\r\n    ]);\r\n    public static readonly blackKeyNameParents: ReadonlyArray<number> = [-1, 1, -1, 1, -1, 1, -1, -1, 1, -1, 1, -1];\r\n    public static readonly tempoMin: number = 30;\r\n    public static readonly tempoMax: number = 320;\r\n    public static readonly echoDelayRange: number = 24;\r\n    public static readonly echoDelayStepTicks: number = 4;\r\n    public static readonly echoSustainRange: number = 8;\r\n    public static readonly echoShelfHz: number = 4000.0; // The cutoff freq of the shelf filter that is used to decay echoes.\r\n    public static readonly echoShelfGain: number = Math.pow(2.0, -0.5);\r\n    public static readonly reverbShelfHz: number = 8000.0; // The cutoff freq of the shelf filter that is used to decay reverb.\r\n    public static readonly reverbShelfGain: number = Math.pow(2.0, -1.5);\r\n    public static readonly reverbRange: number = 32;\r\n    public static readonly reverbDelayBufferSize: number = 16384; // TODO: Compute a buffer size based on sample rate.\r\n    public static readonly reverbDelayBufferMask: number = Config.reverbDelayBufferSize - 1; // TODO: Compute a buffer size based on sample rate.\r\n    public static readonly beatsPerBarMin: number = 3;\r\n    public static readonly beatsPerBarMax: number = 16;\r\n    public static readonly barCountMin: number = 1;\r\n    public static readonly barCountMax: number = 256;\r\n    public static readonly instrumentCountMin: number = 1;\r\n    public static readonly layeredInstrumentCountMax: number = 10;\r\n    public static readonly patternInstrumentCountMax: number = 48;\r\n    public static readonly partsPerBeat: number = 24;\r\n    public static readonly ticksPerPart: number = 2;\r\n    public static readonly ticksPerArpeggio: number = 3;\r\n    public static readonly arpeggioPatterns: ReadonlyArray<ReadonlyArray<number>> = [[0], [0, 1], [0, 1, 2, 1], [0, 1, 2, 3], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4, 5], [0, 1, 2, 3, 4, 5, 6], [0, 1, 2, 3, 4, 5, 6, 7]];\r\n    public static readonly rhythms: DictionaryArray<Rhythm> = toNameMap([\r\n        { name: \"÷3 (triplets)\", stepsPerBeat: 3, /*ticksPerArpeggio: 4, arpeggioPatterns: [[0], [0, 0, 1, 1], [0, 1, 2, 1], [0, 1, 2, 3]]*/ roundUpThresholds: [/*0*/ 5, /*8*/ 12, /*16*/ 18 /*24*/] },\r\n        { name: \"÷4 (standard)\", stepsPerBeat: 4, /*ticksPerArpeggio: 3, arpeggioPatterns: [[0], [0, 0, 1, 1], [0, 1, 2, 1], [0, 1, 2, 3]]*/ roundUpThresholds: [/*0*/ 3, /*6*/ 9, /*12*/ 17, /*18*/ 21 /*24*/] },\r\n        { name: \"÷6\", stepsPerBeat: 6, /*ticksPerArpeggio: 4, arpeggioPatterns: [[0], [0, 1], [0, 1, 2, 1], [0, 1, 2, 3]]*/ roundUpThresholds: null },\r\n        { name: \"÷8\", stepsPerBeat: 8, /*ticksPerArpeggio: 3, arpeggioPatterns: [[0], [0, 1], [0, 1, 2, 1], [0, 1, 2, 3]]*/ roundUpThresholds: null },\r\n        { name: \"freehand\", stepsPerBeat: 24, /*ticksPerArpeggio: 3, arpeggioPatterns: [[0], [0, 1], [0, 1, 2, 1], [0, 1, 2, 3]]*/ roundUpThresholds: null },\r\n    ]);\r\n\r\n    public static readonly instrumentTypeNames: ReadonlyArray<string> = [\"chip\", \"FM\", \"noise\", \"spectrum\", \"drumset\", \"harmonics\", \"PWM\", \"Picked String\", \"custom chip\", \"mod\"];\r\n    public static readonly instrumentTypeHasSpecialInterval: ReadonlyArray<boolean> = [true, true, false, false, false, true, false, false, false];\r\n    public static readonly chipBaseExpression: number = 0.03375; // Doubled by unison feature, but affected by expression adjustments per unison setting and wave shape.\r\n    public static readonly fmBaseExpression: number = 0.03;\r\n    public static readonly noiseBaseExpression: number = 0.19;\r\n    public static readonly spectrumBaseExpression: number = 0.3; // Spectrum can be in pitch or noise channels, the expression is doubled for noise.\r\n    public static readonly drumsetBaseExpression: number = 0.45; // Drums tend to be loud but brief!\r\n    public static readonly harmonicsBaseExpression: number = 0.025;\r\n    public static readonly pwmBaseExpression: number = 0.04725; // It's actually closer to half of this, the synthesized pulse amplitude range is only .5 to -.5, but also note that the fundamental sine partial amplitude of a square wave is 4/π times the measured square wave amplitude.\r\n    public static readonly pickedStringBaseExpression: number = 0.025; // Same as harmonics.\r\n    public static readonly distortionBaseVolume: number = 0.011; // Distortion is not affected by pitchDamping, which otherwise approximately halves expression for notes around the middle of the range.\r\n    public static readonly bitcrusherBaseVolume: number = 0.010; // Also not affected by pitchDamping, used when bit crushing is maxed out (aka \"1-bit\" output).\r\n\r\n    public static readonly rawChipWaves: DictionaryArray<ChipWave> = toNameMap([\r\n        { name: \"rounded\", expression: 0.94, samples: centerWave([0.0, 0.2, 0.4, 0.5, 0.6, 0.7, 0.8, 0.85, 0.9, 0.95, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.95, 0.9, 0.85, 0.8, 0.7, 0.6, 0.5, 0.4, 0.2, 0.0, -0.2, -0.4, -0.5, -0.6, -0.7, -0.8, -0.85, -0.9, -0.95, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -0.95, -0.9, -0.85, -0.8, -0.7, -0.6, -0.5, -0.4, -0.2]) },\r\n        { name: \"triangle\", expression: 1.0, samples: centerWave([1.0 / 15.0, 3.0 / 15.0, 5.0 / 15.0, 7.0 / 15.0, 9.0 / 15.0, 11.0 / 15.0, 13.0 / 15.0, 15.0 / 15.0, 15.0 / 15.0, 13.0 / 15.0, 11.0 / 15.0, 9.0 / 15.0, 7.0 / 15.0, 5.0 / 15.0, 3.0 / 15.0, 1.0 / 15.0, -1.0 / 15.0, -3.0 / 15.0, -5.0 / 15.0, -7.0 / 15.0, -9.0 / 15.0, -11.0 / 15.0, -13.0 / 15.0, -15.0 / 15.0, -15.0 / 15.0, -13.0 / 15.0, -11.0 / 15.0, -9.0 / 15.0, -7.0 / 15.0, -5.0 / 15.0, -3.0 / 15.0, -1.0 / 15.0]) },\r\n        { name: \"square\", expression: 0.5, samples: centerWave([1.0, -1.0]) },\r\n        { name: \"1/4 pulse\", expression: 0.5, samples: centerWave([1.0, -1.0, -1.0, -1.0]) },\r\n        { name: \"1/8 pulse\", expression: 0.5, samples: centerWave([1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0]) },\r\n        { name: \"sawtooth\", expression: 0.65, samples: centerWave([1.0 / 31.0, 3.0 / 31.0, 5.0 / 31.0, 7.0 / 31.0, 9.0 / 31.0, 11.0 / 31.0, 13.0 / 31.0, 15.0 / 31.0, 17.0 / 31.0, 19.0 / 31.0, 21.0 / 31.0, 23.0 / 31.0, 25.0 / 31.0, 27.0 / 31.0, 29.0 / 31.0, 31.0 / 31.0, -31.0 / 31.0, -29.0 / 31.0, -27.0 / 31.0, -25.0 / 31.0, -23.0 / 31.0, -21.0 / 31.0, -19.0 / 31.0, -17.0 / 31.0, -15.0 / 31.0, -13.0 / 31.0, -11.0 / 31.0, -9.0 / 31.0, -7.0 / 31.0, -5.0 / 31.0, -3.0 / 31.0, -1.0 / 31.0]) },\r\n        { name: \"double saw\", expression: 0.5, samples: centerWave([0.0, -0.2, -0.4, -0.6, -0.8, -1.0, 1.0, -0.8, -0.6, -0.4, -0.2, 1.0, 0.8, 0.6, 0.4, 0.2]) },\r\n        { name: \"double pulse\", expression: 0.4, samples: centerWave([1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0]) },\r\n        { name: \"spiky\", expression: 0.4, samples: centerWave([1.0, -1.0, 1.0, -1.0, 1.0, 0.0]) },\r\n        { name: \"sine\", expression: 0.88, samples: centerAndNormalizeWave([8.0, 9.0, 11.0, 12.0, 13.0, 14.0, 15.0, 15.0, 15.0, 15.0, 14.0, 14.0, 13.0, 11.0, 10.0, 9.0, 7.0, 6.0, 4.0, 3.0, 2.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 2.0, 4.0, 5.0, 6.0]) },\r\n        { name: \"flute\", expression: 0.8, samples: centerAndNormalizeWave([3.0, 4.0, 6.0, 8.0, 10.0, 11.0, 13.0, 14.0, 15.0, 15.0, 14.0, 13.0, 11.0, 8.0, 5.0, 3.0]) },\r\n        { name: \"harp\", expression: 0.8, samples: centerAndNormalizeWave([0.0, 3.0, 3.0, 3.0, 4.0, 5.0, 5.0, 6.0, 7.0, 8.0, 9.0, 11.0, 11.0, 13.0, 13.0, 15.0, 15.0, 14.0, 12.0, 11.0, 10.0, 9.0, 8.0, 7.0, 7.0, 5.0, 4.0, 3.0, 2.0, 1.0, 0.0, 0.0]) },\r\n        { name: \"sharp clarinet\", expression: 0.38, samples: centerAndNormalizeWave([0.0, 0.0, 0.0, 1.0, 1.0, 8.0, 8.0, 9.0, 9.0, 9.0, 8.0, 8.0, 8.0, 8.0, 8.0, 9.0, 9.0, 7.0, 9.0, 9.0, 10.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]) },\r\n        { name: \"soft clarinet\", expression: 0.45, samples: centerAndNormalizeWave([0.0, 1.0, 5.0, 8.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 9.0, 11.0, 11.0, 12.0, 13.0, 12.0, 10.0, 9.0, 7.0, 6.0, 4.0, 3.0, 3.0, 3.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]) },\r\n        { name: \"alto sax\", expression: 0.3, samples: centerAndNormalizeWave([5.0, 5.0, 6.0, 4.0, 3.0, 6.0, 8.0, 7.0, 2.0, 1.0, 5.0, 6.0, 5.0, 4.0, 5.0, 7.0, 9.0, 11.0, 13.0, 14.0, 14.0, 14.0, 14.0, 13.0, 10.0, 8.0, 7.0, 7.0, 4.0, 3.0, 4.0, 2.0]) },\r\n        { name: \"bassoon\", expression: 0.35, samples: centerAndNormalizeWave([9.0, 9.0, 7.0, 6.0, 5.0, 4.0, 4.0, 4.0, 4.0, 5.0, 7.0, 8.0, 9.0, 10.0, 11.0, 13.0, 13.0, 11.0, 10.0, 9.0, 7.0, 6.0, 4.0, 2.0, 1.0, 1.0, 1.0, 2.0, 2.0, 5.0, 11.0, 14.0]) },\r\n        { name: \"trumpet\", expression: 0.22, samples: centerAndNormalizeWave([10.0, 11.0, 8.0, 6.0, 5.0, 5.0, 5.0, 6.0, 7.0, 7.0, 7.0, 7.0, 6.0, 6.0, 7.0, 7.0, 7.0, 7.0, 7.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 7.0, 8.0, 9.0, 11.0, 14.0]) },\r\n        { name: \"electric guitar\", expression: 0.2, samples: centerAndNormalizeWave([11.0, 12.0, 12.0, 10.0, 6.0, 6.0, 8.0, 0.0, 2.0, 4.0, 8.0, 10.0, 9.0, 10.0, 1.0, 7.0, 11.0, 3.0, 6.0, 6.0, 8.0, 13.0, 14.0, 2.0, 0.0, 12.0, 8.0, 4.0, 13.0, 11.0, 10.0, 13.0]) },\r\n        { name: \"organ\", expression: 0.2, samples: centerAndNormalizeWave([11.0, 10.0, 12.0, 11.0, 14.0, 7.0, 5.0, 5.0, 12.0, 10.0, 10.0, 9.0, 12.0, 6.0, 4.0, 5.0, 13.0, 12.0, 12.0, 10.0, 12.0, 5.0, 2.0, 2.0, 8.0, 6.0, 6.0, 5.0, 8.0, 3.0, 2.0, 1.0]) },\r\n        { name: \"pan flute\", expression: 0.35, samples: centerAndNormalizeWave([1.0, 4.0, 7.0, 6.0, 7.0, 9.0, 7.0, 7.0, 11.0, 12.0, 13.0, 15.0, 13.0, 11.0, 11.0, 12.0, 13.0, 10.0, 7.0, 5.0, 3.0, 6.0, 10.0, 7.0, 3.0, 3.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0]) },\r\n        { name: \"glitch\", expression: 0.5, samples: centerWave([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0]) },\r\n    ]);\r\n    public static readonly chipWaves: DictionaryArray<ChipWave> = rawChipToIntegrated(Config.rawChipWaves);\r\n    // Noise waves have too many samples to write by hand, they're generated on-demand by getDrumWave instead.\r\n    public static readonly chipNoises: DictionaryArray<ChipNoise> = toNameMap([\r\n        { name: \"retro\", expression: 0.25, basePitch: 69, pitchFilterMult: 1024.0, isSoft: false, samples: null },\r\n        { name: \"white\", expression: 1.0, basePitch: 69, pitchFilterMult: 8.0, isSoft: true, samples: null },\r\n        // The \"clang\" and \"buzz\" noises are based on similar noises in the modded beepbox! :D\r\n        { name: \"clang\", expression: 0.4, basePitch: 69, pitchFilterMult: 1024.0, isSoft: false, samples: null },\r\n        { name: \"buzz\", expression: 0.3, basePitch: 69, pitchFilterMult: 1024.0, isSoft: false, samples: null },\r\n        { name: \"hollow\", expression: 1.5, basePitch: 96, pitchFilterMult: 1.0, isSoft: true, samples: null },\r\n        { name: \"shine\", expression: 1.0, basePitch: 69, pitchFilterMult: 1024.0, isSoft: false, samples: null },\r\n        { name: \"deep\", expression: 1.5, basePitch: 120, pitchFilterMult: 1024.0, isSoft: true, samples: null },\r\n        { name: \"cutter\", expression: 0.005, basePitch: 96, pitchFilterMult: 1024.0, isSoft: false, samples: null },\r\n        { name: \"metallic\", expression: 1.0, basePitch: 96, pitchFilterMult: 1024.0, isSoft: false, samples: null },\r\n    ]);\r\n\r\n    public static readonly filterFreqStep: number = 1.0 / 4.0;\r\n    public static readonly filterFreqRange: number = 34;\r\n    public static readonly filterFreqReferenceSetting: number = 28;\r\n    public static readonly filterFreqReferenceHz: number = 8000.0;\r\n    public static readonly filterFreqMaxHz: number = Config.filterFreqReferenceHz * Math.pow(2.0, Config.filterFreqStep * (Config.filterFreqRange - 1 - Config.filterFreqReferenceSetting)); // ~19khz\r\n    public static readonly filterFreqMinHz: number = 8.0;\r\n    public static readonly filterGainRange: number = 15;\r\n    public static readonly filterGainCenter: number = 7;\r\n    public static readonly filterGainStep: number = 1.0 / 2.0;\r\n    public static readonly filterMaxPoints: number = 12;\r\n    public static readonly filterTypeNames: ReadonlyArray<string> = [\"low-pass\", \"high-pass\", \"peak\"]; // See FilterType enum above.\r\n    public static readonly filterMorphCount: number = 10; // Number of filter shapes allowed for modulating between. Counts the 0/default position.\r\n\r\n    public static readonly filterSimpleCutRange: number = 11;\r\n    public static readonly filterSimplePeakRange: number = 8;\r\n\r\n    public static readonly fadeInRange: number = 10;\r\n    public static readonly fadeOutTicks: ReadonlyArray<number> = [-24, -12, -6, -3, -1, 6, 12, 24, 48, 72, 96];\r\n    public static readonly fadeOutNeutral: number = 4;\r\n    public static readonly drumsetFadeOutTicks: number = 48;\r\n    public static readonly transitions: DictionaryArray<Transition> = toNameMap([\r\n        { name: \"normal\", isSeamless: false, continues: false, slides: false, slideTicks: 3, includeAdjacentPatterns: false },\r\n        { name: \"interrupt\", isSeamless: true, continues: false, slides: false, slideTicks: 3, includeAdjacentPatterns: true },\r\n        { name: \"continue\", isSeamless: true, continues: true, slides: false, slideTicks: 3, includeAdjacentPatterns: true },\r\n        { name: \"slide\", isSeamless: true, continues: false, slides: true, slideTicks: 3, includeAdjacentPatterns: true },\r\n        { name: \"slide in pattern\", isSeamless: true, continues: false, slides: true, slideTicks: 3, includeAdjacentPatterns: false },\r\n    ]);\r\n    public static readonly vibratos: DictionaryArray<Vibrato> = toNameMap([\r\n        { name: \"none\", amplitude: 0.0, type: 0, delayTicks: 0 },\r\n        { name: \"light\", amplitude: 0.15, type: 0, delayTicks: 0 },\r\n        { name: \"delayed\", amplitude: 0.3, type: 0, delayTicks: 37 }, // It will fade in over the previous two ticks.\r\n        { name: \"heavy\", amplitude: 0.45, type: 0, delayTicks: 0 },\r\n        { name: \"shaky\", amplitude: 0.1, type: 1, delayTicks: 0 },\r\n    ]);\r\n    public static readonly vibratoTypes: DictionaryArray<VibratoType> = toNameMap([\r\n        { name: \"normal\", periodsSeconds: [0.14], period: 0.14 },\r\n        { name: \"shaky\", periodsSeconds: [0.11, 1.618 * 0.11, 3 * 0.11], period: 266.97 }, // LCM of all periods\r\n    ]);\r\n    // This array is more or less a linear step by 0.1 but there's a bit of range added at the start to hit specific ratios, and the end starts to grow faster.\r\n    //                                                             0       1      2    3     4      5    6    7      8     9   10   11 12   13   14   15   16   17   18   19   20   21 22   23   24   25   26   27   28   29   30   31 32   33   34   35   36   37   38    39  40   41 42    43   44   45   46 47   48 49 50\r\n    public static readonly arpSpeedScale: ReadonlyArray<number> = [0, 0.0625, 0.125, 0.2, 0.25, 1 / 3, 0.4, 0.5, 2 / 3, 0.75, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9, 3, 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4, 4.15, 4.3, 4.5, 4.8, 5, 5.5, 6, 8];\r\n\r\n    public static readonly unisons: DictionaryArray<Unison> = toNameMap([\r\n        { name: \"none\", voices: 1, spread: 0.0, offset: 0.0, expression: 1.4, sign: 1.0 },\r\n        { name: \"shimmer\", voices: 2, spread: 0.018, offset: 0.0, expression: 0.8, sign: 1.0 },\r\n        { name: \"hum\", voices: 2, spread: 0.045, offset: 0.0, expression: 1.0, sign: 1.0 },\r\n        { name: \"honky tonk\", voices: 2, spread: 0.09, offset: 0.0, expression: 1.0, sign: 1.0 },\r\n        { name: \"dissonant\", voices: 2, spread: 0.25, offset: 0.0, expression: 0.9, sign: 1.0 },\r\n        { name: \"fifth\", voices: 2, spread: 3.5, offset: 3.5, expression: 0.9, sign: 1.0 },\r\n        { name: \"octave\", voices: 2, spread: 6.0, offset: 6.0, expression: 0.8, sign: 1.0 },\r\n        { name: \"bowed\", voices: 2, spread: 0.02, offset: 0.0, expression: 1.0, sign: -1.0 },\r\n        { name: \"piano\", voices: 2, spread: 0.01, offset: 0.0, expression: 1.0, sign: 0.7 },\r\n        { name: \"warbled\", voices: 2, spread: 0.25, offset: 0.05, expression: 0.9, sign: -0.8 },\r\n    ]);\r\n    public static readonly effectNames: ReadonlyArray<string> = [\"reverb\", \"chorus\", \"panning\", \"distortion\", \"bitcrusher\", \"note filter\", \"echo\", \"pitch shift\", \"detune\", \"vibrato\", \"transition type\", \"chord type\", \"note range\", \"invert wave\"];\r\n    public static readonly effectOrder: ReadonlyArray<EffectType> = [EffectType.panning, EffectType.transition, EffectType.chord, EffectType.pitchShift, EffectType.detune, EffectType.vibrato, EffectType.noteFilter, EffectType.distortion, EffectType.bitcrusher, EffectType.chorus, EffectType.echo, EffectType.reverb, EffectType.noteRange, EffectType.invertWave];\r\n    public static readonly noteSizeMax: number = 6;\r\n    public static readonly volumeRange: number = 50;\r\n    // Beepbox's old volume scale used factor -0.5 and was [0~7] had roughly value 6 = 0.125 power. This new value is chosen to have -21 be the same,\r\n    // given that the new scale is [-25~25]. This is such that conversion between the scales is roughly equivalent by satisfying (0.5*6 = 0.1428*21)\t\r\n    public static readonly volumeLogScale: number = 0.1428;\r\n    public static readonly panCenter: number = 50;\r\n    public static readonly panMax: number = Config.panCenter * 2;\r\n    public static readonly panDelaySecondsMax: number = 0.001;\r\n    public static readonly chorusRange: number = 8;\r\n    public static readonly chorusPeriodSeconds: number = 2.0;\r\n    public static readonly chorusDelayRange: number = 0.0034;\r\n    public static readonly chorusDelayOffsets: ReadonlyArray<ReadonlyArray<number>> = [[1.51, 2.10, 3.35], [1.47, 2.15, 3.25]];\r\n    public static readonly chorusPhaseOffsets: ReadonlyArray<ReadonlyArray<number>> = [[0.0, 2.1, 4.2], [3.2, 5.3, 1.0]];\r\n    public static readonly chorusMaxDelay: number = Config.chorusDelayRange * (1.0 + Config.chorusDelayOffsets[0].concat(Config.chorusDelayOffsets[1]).reduce((x, y) => Math.max(x, y)));\r\n    public static readonly chords: DictionaryArray<Chord> = toNameMap([\r\n        { name: \"simultaneous\", customInterval: false, arpeggiates: false, strumParts: 0, singleTone: false },\r\n        { name: \"strum\", customInterval: false, arpeggiates: false, strumParts: 1, singleTone: false },\r\n        { name: \"arpeggio\", customInterval: false, arpeggiates: true, strumParts: 0, singleTone: true },\r\n        { name: \"custom interval\", customInterval: true, arpeggiates: false, strumParts: 0, singleTone: true },\r\n    ]);\r\n    public static readonly maxChordSize: number = 9;\r\n    public static readonly operatorCount: number = 4;\r\n\tpublic static readonly maxPitchOrOperatorCount: number = Math.max(Config.maxChordSize, Config.operatorCount);\r\n    public static readonly algorithms: DictionaryArray<Algorithm> = toNameMap([\r\n        { name: \"1←(2 3 4)\", carrierCount: 1, associatedCarrier: [1, 1, 1, 1], modulatedBy: [[2, 3, 4], [], [], []] },\r\n        { name: \"1←(2 3←4)\", carrierCount: 1, associatedCarrier: [1, 1, 1, 1], modulatedBy: [[2, 3], [], [4], []] },\r\n        { name: \"1←2←(3 4)\", carrierCount: 1, associatedCarrier: [1, 1, 1, 1], modulatedBy: [[2], [3, 4], [], []] },\r\n        { name: \"1←(2 3)←4\", carrierCount: 1, associatedCarrier: [1, 1, 1, 1], modulatedBy: [[2, 3], [4], [4], []] },\r\n        { name: \"1←2←3←4\", carrierCount: 1, associatedCarrier: [1, 1, 1, 1], modulatedBy: [[2], [3], [4], []] },\r\n        { name: \"1←3 2←4\", carrierCount: 2, associatedCarrier: [1, 2, 1, 2], modulatedBy: [[3], [4], [], []] },\r\n        { name: \"1 2←(3 4)\", carrierCount: 2, associatedCarrier: [1, 2, 2, 2], modulatedBy: [[], [3, 4], [], []] },\r\n        { name: \"1 2←3←4\", carrierCount: 2, associatedCarrier: [1, 2, 2, 2], modulatedBy: [[], [3], [4], []] },\r\n        { name: \"(1 2)←3←4\", carrierCount: 2, associatedCarrier: [1, 2, 2, 2], modulatedBy: [[3], [3], [4], []] },\r\n        { name: \"(1 2)←(3 4)\", carrierCount: 2, associatedCarrier: [1, 2, 2, 2], modulatedBy: [[3, 4], [3, 4], [], []] },\r\n        { name: \"1 2 3←4\", carrierCount: 3, associatedCarrier: [1, 2, 3, 3], modulatedBy: [[], [], [4], []] },\r\n        { name: \"(1 2 3)←4\", carrierCount: 3, associatedCarrier: [1, 2, 3, 3], modulatedBy: [[4], [4], [4], []] },\r\n        { name: \"1 2 3 4\", carrierCount: 4, associatedCarrier: [1, 2, 3, 4], modulatedBy: [[], [], [], []] },\r\n    ]);\r\n    public static readonly operatorCarrierInterval: ReadonlyArray<number> = [0.0, 0.04, -0.073, 0.091];\r\n    public static readonly operatorAmplitudeMax: number = 15;\r\n    public static readonly operatorFrequencies: DictionaryArray<OperatorFrequency> = toNameMap([\r\n        { name: \"1×\", mult: 1.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"~1×\", mult: 1.0, hzOffset: 1.5, amplitudeSign: -1.0 },\r\n        { name: \"2×\", mult: 2.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"~2×\", mult: 2.0, hzOffset: -1.3, amplitudeSign: -1.0 },\r\n        { name: \"3×\", mult: 3.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"4×\", mult: 4.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"5×\", mult: 5.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"6×\", mult: 6.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"7×\", mult: 7.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"8×\", mult: 8.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"9×\", mult: 9.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"11×\", mult: 11.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"13×\", mult: 13.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"16×\", mult: 16.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"20×\", mult: 20.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        \r\n        { name: \"-1×\", mult: -1.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"-~1×\", mult: -1.0, hzOffset: 1.5, amplitudeSign: -1.0 },\r\n        { name: \"-2×\", mult: -2.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"-~2×\", mult: -2.0, hzOffset: -1.3, amplitudeSign: -1.0 },\r\n        { name: \"-3×\", mult: -3.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"-4×\", mult: -4.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"-5×\", mult: -5.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"-6×\", mult: -6.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"-7×\", mult: -7.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"-8×\", mult: -8.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"-9×\", mult: -9.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"-11×\", mult: -11.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"-13×\", mult: -13.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"-16×\", mult: -16.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n        { name: \"-20×\", mult: -20.0, hzOffset: 0.0, amplitudeSign: 1.0 },\r\n    ]);\r\n    public static readonly envelopes: DictionaryArray<Envelope> = toNameMap([\r\n        { name: \"none\", type: EnvelopeType.none, speed: 0.0 },\r\n        { name: \"note size\", type: EnvelopeType.noteSize, speed: 0.0 },\r\n        { name: \"punch\", type: EnvelopeType.punch, speed: 0.0 },\r\n        { name: \"flare 1\", type: EnvelopeType.flare, speed: 32.0 },\r\n        { name: \"flare 2\", type: EnvelopeType.flare, speed: 8.0 },\r\n        { name: \"flare 3\", type: EnvelopeType.flare, speed: 2.0 },\r\n        { name: \"twang 1\", type: EnvelopeType.twang, speed: 32.0 },\r\n        { name: \"twang 2\", type: EnvelopeType.twang, speed: 8.0 },\r\n        { name: \"twang 3\", type: EnvelopeType.twang, speed: 2.0 },\r\n        { name: \"swell 1\", type: EnvelopeType.swell, speed: 32.0 },\r\n        { name: \"swell 2\", type: EnvelopeType.swell, speed: 8.0 },\r\n        { name: \"swell 3\", type: EnvelopeType.swell, speed: 2.0 },\r\n        { name: \"tremolo1\", type: EnvelopeType.tremolo, speed: 4.0 },\r\n        { name: \"tremolo2\", type: EnvelopeType.tremolo, speed: 2.0 },\r\n        { name: \"tremolo3\", type: EnvelopeType.tremolo, speed: 1.0 },\r\n        { name: \"tremolo4\", type: EnvelopeType.tremolo2, speed: 4.0 },\r\n        { name: \"tremolo5\", type: EnvelopeType.tremolo2, speed: 2.0 },\r\n        { name: \"tremolo6\", type: EnvelopeType.tremolo2, speed: 1.0 },\r\n        { name: \"decay 1\", type: EnvelopeType.decay, speed: 10.0 },\r\n        { name: \"decay 2\", type: EnvelopeType.decay, speed: 7.0 },\r\n        { name: \"decay 3\", type: EnvelopeType.decay, speed: 4.0 },\r\n    ]);\r\n    public static readonly feedbacks: DictionaryArray<Feedback> = toNameMap([\r\n        { name: \"1⟲\", indices: [[1], [], [], []] },\r\n        { name: \"2⟲\", indices: [[], [2], [], []] },\r\n        { name: \"3⟲\", indices: [[], [], [3], []] },\r\n        { name: \"4⟲\", indices: [[], [], [], [4]] },\r\n        { name: \"1⟲ 2⟲\", indices: [[1], [2], [], []] },\r\n        { name: \"3⟲ 4⟲\", indices: [[], [], [3], [4]] },\r\n        { name: \"1⟲ 2⟲ 3⟲\", indices: [[1], [2], [3], []] },\r\n        { name: \"2⟲ 3⟲ 4⟲\", indices: [[], [2], [3], [4]] },\r\n        { name: \"1⟲ 2⟲ 3⟲ 4⟲\", indices: [[1], [2], [3], [4]] },\r\n        { name: \"1→2\", indices: [[], [1], [], []] },\r\n        { name: \"1→3\", indices: [[], [], [1], []] },\r\n        { name: \"1→4\", indices: [[], [], [], [1]] },\r\n        { name: \"2→3\", indices: [[], [], [2], []] },\r\n        { name: \"2→4\", indices: [[], [], [], [2]] },\r\n        { name: \"3→4\", indices: [[], [], [], [3]] },\r\n        { name: \"1→3 2→4\", indices: [[], [], [1], [2]] },\r\n        { name: \"1→4 2→3\", indices: [[], [], [2], [1]] },\r\n        { name: \"1→2→3→4\", indices: [[], [1], [2], [3]] },\r\n    ]);\r\n    public static readonly chipNoiseLength: number = 1 << 15; // 32768\r\n    public static readonly spectrumNoiseLength: number = 1 << 15; // 32768\r\n    public static readonly spectrumBasePitch: number = 24;\r\n    public static readonly spectrumControlPoints: number = 30;\r\n    public static readonly spectrumControlPointsPerOctave: number = 7;\r\n    public static readonly spectrumControlPointBits: number = 3;\r\n    public static readonly spectrumMax: number = (1 << Config.spectrumControlPointBits) - 1;\r\n    public static readonly harmonicsControlPoints: number = 28;\r\n    public static readonly harmonicsRendered: number = 64;\r\n    public static readonly harmonicsRenderedForPickedString: number = 1 << 8; // 256\r\n    public static readonly harmonicsControlPointBits: number = 3;\r\n    public static readonly harmonicsMax: number = (1 << Config.harmonicsControlPointBits) - 1;\r\n    public static readonly harmonicsWavelength: number = 1 << 11; // 2048\r\n    public static readonly pulseWidthRange: number = 50;\r\n    public static readonly pulseWidthStepPower: number = 0.5;\r\n    public static readonly pitchChannelCountMin: number = 0;\r\n    public static readonly pitchChannelCountMax: number = 80;\r\n    public static readonly noiseChannelCountMin: number = 0;\r\n    public static readonly noiseChannelCountMax: number = 32;\r\n    public static readonly modChannelCountMin: number = 0;\r\n    public static readonly modChannelCountMax: number = 24;\r\n    public static readonly noiseInterval: number = 6;\r\n    public static readonly pitchesPerOctave: number = 12; // TODO: Use this for converting pitch to frequency.\r\n    public static readonly drumCount: number = 12;\r\n    public static readonly pitchOctaves: number = 10;\r\n    public static readonly modCount: number = 8;\r\n    public static readonly maxPitch: number = Config.pitchOctaves * Config.pitchesPerOctave;\r\n    public static readonly maximumTonesPerChannel: number = Config.maxChordSize * 2;\r\n    public static readonly justIntonationSemitones: number[] = [1.0 / 2.0, 8.0 / 15.0, 9.0 / 16.0, 3.0 / 5.0, 5.0 / 8.0, 2.0 / 3.0, 32.0 / 45.0, 3.0 / 4.0, 4.0 / 5.0, 5.0 / 6.0, 8.0 / 9.0, 15.0 / 16.0, 1.0, 16.0 / 15.0, 9.0 / 8.0, 6.0 / 5.0, 5.0 / 4.0, 4.0 / 3.0, 45.0 / 32.0, 3.0 / 2.0, 8.0 / 5.0, 5.0 / 3.0, 16.0 / 9.0, 15.0 / 8.0, 2.0].map(x => Math.log2(x) * Config.pitchesPerOctave);\r\n    public static readonly pitchShiftRange: number = Config.justIntonationSemitones.length;\r\n    public static readonly pitchShiftCenter: number = Config.pitchShiftRange >> 1;\r\n    public static readonly detuneCenter: number = 200;\r\n    public static readonly detuneMax: number = 400;\r\n    public static readonly detuneMin: number = 0;\r\n    public static readonly songDetuneMin: number = 0;\r\n    public static readonly songDetuneMax: number = 500;\r\n    public static readonly sineWaveLength: number = 1 << 8; // 256\r\n    public static readonly sineWaveMask: number = Config.sineWaveLength - 1;\r\n    public static readonly sineWave: Float32Array = generateSineWave();\r\n\r\n    // Picked strings have an all-pass filter with a corner frequency based on the tone fundamental frequency, in order to add a slight inharmonicity. (Which is important for distortion.)\r\n    public static readonly pickedStringDispersionCenterFreq: number = 6000.0; // The tone fundamental freq is pulled toward this freq for computing the all-pass corner freq.\r\n    public static readonly pickedStringDispersionFreqScale: number = 0.3; // The tone fundamental freq freq moves this much toward the center freq for computing the all-pass corner freq.\r\n    public static readonly pickedStringDispersionFreqMult: number = 4.0; // The all-pass corner freq is based on this times the adjusted tone fundamental freq.\r\n    public static readonly pickedStringShelfHz: number = 4000.0; // The cutoff freq of the shelf filter that is used to decay the high frequency energy in the picked string.\r\n\r\n    public static readonly distortionRange: number = 8;\r\n    public static readonly stringSustainRange: number = 15;\r\n    public static readonly stringDecayRate: number = 0.12;\r\n    public static readonly bitcrusherFreqRange: number = 14;\r\n    public static readonly bitcrusherOctaveStep: number = 0.5;\r\n    public static readonly bitcrusherQuantizationRange: number = 8;\r\n\r\n    public static readonly maxEnvelopeCount: number = 12;\r\n    public static readonly defaultAutomationRange: number = 13;\r\n    public static readonly instrumentAutomationTargets: DictionaryArray<AutomationTarget> = toNameMap([\r\n        { name: \"none\", computeIndex: null, displayName: \"none\",             /*perNote: false,*/ interleave: false, isFilter: false, /*range: 0,                              */    maxCount: 1, effect: null, compatibleInstruments: null },\r\n        { name: \"noteVolume\", computeIndex: EnvelopeComputeIndex.noteVolume, displayName: \"note volume\",      /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.volumeRange,             */    maxCount: 1, effect: null, compatibleInstruments: null },\r\n        { name: \"pulseWidth\", computeIndex: EnvelopeComputeIndex.pulseWidth, displayName: \"pulse width\",      /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.pulseWidthRange,         */    maxCount: 1, effect: null, compatibleInstruments: [InstrumentType.pwm] },\r\n        { name: \"stringSustain\", computeIndex: EnvelopeComputeIndex.stringSustain, displayName: \"sustain\",          /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.stringSustainRange,      */    maxCount: 1, effect: null, compatibleInstruments: [InstrumentType.pickedString] },\r\n        { name: \"unison\", computeIndex: EnvelopeComputeIndex.unison, displayName: \"unison\",           /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.defaultAutomationRange,  */    maxCount: 1, effect: null, compatibleInstruments: [InstrumentType.chip, InstrumentType.harmonics, InstrumentType.pickedString] },\r\n        { name: \"operatorFrequency\", computeIndex: EnvelopeComputeIndex.operatorFrequency0, displayName: \"fm# freq\",         /*perNote:  true,*/ interleave: true, isFilter: false, /*range: Config.defaultAutomationRange,  */    maxCount: Config.operatorCount, effect: null, compatibleInstruments: [InstrumentType.fm] },\r\n        { name: \"operatorAmplitude\", computeIndex: EnvelopeComputeIndex.operatorAmplitude0, displayName: \"fm# volume\",       /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.operatorAmplitudeMax + 1,*/    maxCount: Config.operatorCount, effect: null, compatibleInstruments: [InstrumentType.fm] },\r\n        { name: \"feedbackAmplitude\", computeIndex: EnvelopeComputeIndex.feedbackAmplitude, displayName: \"fm feedback\",      /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.operatorAmplitudeMax + 1,*/    maxCount: 1, effect: null, compatibleInstruments: [InstrumentType.fm] },\r\n        { name: \"pitchShift\", computeIndex: EnvelopeComputeIndex.pitchShift, displayName: \"pitch shift\",      /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.pitchShiftRange,         */    maxCount: 1, effect: EffectType.pitchShift, compatibleInstruments: null },\r\n        { name: \"detune\", computeIndex: EnvelopeComputeIndex.detune, displayName: \"detune\",           /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.detuneMax + 1,           */    maxCount: 1, effect: EffectType.detune, compatibleInstruments: null },\r\n        { name: \"vibratoDepth\", computeIndex: EnvelopeComputeIndex.vibratoDepth, displayName: \"vibrato range\",    /*perNote:  true,*/ interleave: false, isFilter: false, /*range: Config.defaultAutomationRange,  */    maxCount: 1, effect: EffectType.vibrato, compatibleInstruments: null },\r\n        { name: \"noteFilterAllFreqs\", computeIndex: EnvelopeComputeIndex.noteFilterAllFreqs, displayName: \"n. filter freqs\",  /*perNote:  true,*/ interleave: false, isFilter: true, /*range: null,                           */    maxCount: 1, effect: EffectType.noteFilter, compatibleInstruments: null },\r\n        { name: \"noteFilterFreq\", computeIndex: EnvelopeComputeIndex.noteFilterFreq0, displayName: \"n. filter # freq\", /*perNote:  true,*/ interleave: false/*true*/, isFilter: true, /*range: Config.filterFreqRange,     */        maxCount: Config.filterMaxPoints, effect: EffectType.noteFilter, compatibleInstruments: null },\r\n        // Controlling filter gain is less obvious and intuitive than controlling filter freq, so to avoid confusion I've disabled it for now...\r\n        //{name: \"noteFilterGain\",         computeIndex:       EnvelopeComputeIndex.noteFilterGain0,        displayName: \"n. filter # vol\",  /*perNote:  true,*/ interleave: false, isFilter:  true, range: Config.filterGainRange,             maxCount: Config.filterMaxPoints, effect: EffectType.noteFilter, compatibleInstruments: null},\r\n        /*\r\n        {name: \"distortion\",             computeIndex: InstrumentAutomationIndex.distortion,             displayName: \"distortion\",       perNote: false, interleave: false, isFilter: false, range: Config.distortionRange,             maxCount: 1,    effect: EffectType.distortion,   compatibleInstruments: null},\r\n        {name: \"bitcrusherQuantization\", computeIndex: InstrumentAutomationIndex.bitcrusherQuantization, displayName: \"bit crush\",        perNote: false, interleave: false, isFilter: false, range: Config.bitcrusherQuantizationRange, maxCount: 1,    effect: EffectType.bitcrusher,   compatibleInstruments: null},\r\n        {name: \"bitcrusherFrequency\",    computeIndex: InstrumentAutomationIndex.bitcrusherFrequency,    displayName: \"freq crush\",       perNote: false, interleave: false, isFilter: false, range: Config.bitcrusherFreqRange,         maxCount: 1,    effect: EffectType.bitcrusher,   compatibleInstruments: null},\r\n        {name: \"eqFilterAllFreqs\",       computeIndex: InstrumentAutomationIndex.eqFilterAllFreqs,       displayName: \"eq filter freqs\",  perNote: false, interleave: false, isFilter:  true, range: null,                               maxCount: 1,    effect: null,                    compatibleInstruments: null},\r\n        {name: \"eqFilterFreq\",           computeIndex: InstrumentAutomationIndex.eqFilterFreq0,          displayName: \"eq filter # freq\", perNote: false, interleave:  true, isFilter:  true, range: Config.filterFreqRange,             maxCount: Config.filterMaxPoints, effect: null,  compatibleInstruments: null},\r\n        {name: \"eqFilterGain\",           computeIndex: InstrumentAutomationIndex.eqFilterGain0,          displayName: \"eq filter # vol\",  perNote: false, interleave: false, isFilter:  true, range: Config.filterGainRange,             maxCount: Config.filterMaxPoints, effect: null,  compatibleInstruments: null},\r\n        {name: \"panning\",                computeIndex: InstrumentAutomationIndex.panning,                displayName: \"panning\",          perNote: false, interleave: false, isFilter: false, range: Config.panMax + 1,                  maxCount: 1,    effect: EffectType.panning,      compatibleInstruments: null},\r\n        {name: \"chorus\",                 computeIndex: InstrumentAutomationIndex.chorus,                 displayName: \"chorus\",           perNote: false, interleave: false, isFilter: false, range: Config.chorusRange,                 maxCount: 1,    effect: EffectType.chorus,       compatibleInstruments: null},\r\n        {name: \"echoSustain\",            computeIndex: InstrumentAutomationIndex.echoSustain,            displayName: \"echo\",             perNote: false, interleave: false, isFilter: false, range: Config.echoSustainRange,            maxCount: 1,    effect: EffectType.echo,         compatibleInstruments: null},\r\n        {name: \"echoDelay\",              computeIndex: InstrumentAutomationIndex.echoDelay,              displayName: \"echo delay\",       perNote: false, interleave: false, isFilter: false, range: Config.echoDelayRange,              maxCount: 1,    effect: EffectType.echo,         compatibleInstruments: null}, // wait until after we're computing a tick's settings for multiple run lengths.\r\n        {name: \"reverb\",                 computeIndex: InstrumentAutomationIndex.reverb,                 displayName: \"reverb\",           perNote: false, interleave: false, isFilter: false, range: Config.reverbRange,                 maxCount: 1,    effect: EffectType.reverb,       compatibleInstruments: null},\r\n        {name: \"mixVolume\",              computeIndex: InstrumentAutomationIndex.mixVolume,              displayName: \"mix volume\",       perNote: false, interleave: false, isFilter: false, range: Config.volumeRange,                 maxCount: 1,    effect: null,                    compatibleInstruments: null},\r\n        {name: \"envelope#\",              computeIndex: null,                                             displayName: \"envelope\",         perNote: false, interleave: false, isFilter: false, range: Config.defaultAutomationRange,      maxCount: Config.maxEnvelopeCount, effect: null, compatibleInstruments: null}, // maxCount special case for envelopes to be allowed to target earlier ones.\r\n        */\r\n    ]);\r\n    public static readonly operatorWaves: DictionaryArray<OperatorWave> = toNameMap([\r\n        { name: \"sine\", samples: Config.sineWave },\r\n        { name: \"triangle\", samples: generateTriWave() },\r\n        { name: \"sawtooth\", samples: generateSawWave() },\r\n        { name: \"pulse width\", samples: generateSquareWave() },\r\n        { name: \"ramp\", samples: generateSawWave(true) },\r\n        { name: \"trapezoid\", samples: generateTrapezoidWave(2) },\r\n        { name: \"white noise\", samples: getDrumWave(1, null, null) },\r\n    ]);\r\n    public static readonly pwmOperatorWaves: DictionaryArray<OperatorWave> = toNameMap([\r\n        { name: \"1%\", samples: generateSquareWave(0.01) },\r\n        { name: \"5%\", samples: generateSquareWave(0.05) },\r\n        { name: \"12.5%\", samples: generateSquareWave(0.125) },\r\n        { name: \"25%\", samples: generateSquareWave(0.25) },\r\n        { name: \"33%\", samples: generateSquareWave(1 / 3) },\r\n        { name: \"50%\", samples: generateSquareWave(0.5) },\r\n        { name: \"66%\", samples: generateSquareWave(2 / 3) },\r\n        { name: \"75%\", samples: generateSquareWave(0.75) },\r\n        { name: \"87.5%\", samples: generateSquareWave(0.875) },\r\n        { name: \"95%\", samples: generateSquareWave(0.95) },\r\n        { name: \"99%\", samples: generateSquareWave(0.99) },\r\n    ]);\r\n\r\n\r\n    // Height of the small editor column for inserting/deleting rows, in pixels.\r\n    public static readonly barEditorHeight: number = 10;\r\n\r\n    // Careful about changing index ordering for this. Index is stored in URL/JSON etc.\r\n    public static readonly modulators: DictionaryArray<Modulator> = toNameMap([\r\n        { name: \"none\", pianoName: \"None\", maxRawVol: 6, newNoteVol: 6, forSong: true, convertRealFactor: 0, associatedEffect: EffectType.length,\r\n            promptName: \"No Mod Setting\", promptDesc: [ \"No setting has been chosen yet, so this modulator will have no effect. Try choosing a setting with the dropdown, then click this '?' again for more info.\", \"[$LO - $HI]\" ] },\r\n        { name: \"song volume\", pianoName: \"Volume\", maxRawVol: 100, newNoteVol: 100, forSong: true, convertRealFactor: 0, associatedEffect: EffectType.length,\r\n            promptName: \"Song Volume\", promptDesc: [ \"This setting affects the overall volume of the song, just like the main volume slider.\", \"At $HI, the volume will be unchanged from default, and it will get gradually quieter down to $LO.\", \"[MULTIPLICATIVE] [$LO - $HI] [%]\" ] },\r\n        { name: \"tempo\", pianoName: \"Tempo\", maxRawVol: Config.tempoMax - Config.tempoMin, newNoteVol: Math.ceil((Config.tempoMax - Config.tempoMin) / 2), forSong: true, convertRealFactor: Config.tempoMin, associatedEffect: EffectType.length,\r\n            promptName: \"Song Tempo\", promptDesc: [ \"This setting controls the speed your song plays at, just like the tempo slider.\", \"When you first make a note for this setting, it will default to your current tempo. Raising it speeds up the song, up to $HI BPM, and lowering it slows it down, to a minimum of $LO BPM.\", \"Note that you can make a 'swing' effect by rapidly changing between two tempo values.\", \"[OVERWRITING] [$LO - $HI] [BPM]\" ] },\r\n        { name: \"song reverb\", pianoName: \"Reverb\", maxRawVol: Config.reverbRange * 2, newNoteVol: Config.reverbRange, forSong: true, convertRealFactor: -Config.reverbRange, associatedEffect: EffectType.length,\r\n            promptName: \"Song Reverb\", promptDesc: [ \"This setting affects the overall reverb of your song. It works by multiplying existing reverb for instruments, so those with no reverb set will be unaffected.\", \"At $MID, all instruments' reverb will be unchanged from default. This increases up to double the reverb value at $HI, or down to no reverb at $LO.\", \"[MULTIPLICATIVE] [$LO - $HI]\" ] },\r\n        { name: \"next bar\", pianoName: \"Next Bar\", maxRawVol: 1, newNoteVol: 1, forSong: true, convertRealFactor: 0, associatedEffect: EffectType.length,\r\n            promptName: \"Go To Next Bar\", promptDesc: [ \"This setting functions a little different from most. Wherever a note is placed, the song will jump immediately to the next bar when it is encountered.\", \"This jump happens at the very start of the note, so the length of a next-bar note is irrelevant. Also, the note can be value 0 or 1, but the value is also irrelevant - wherever you place a note, the song will jump.\", \"You can make mixed-meter songs or intro sections by cutting off unneeded beats with a next-bar modulator.\", \"[$LO - $HI]\" ] },\r\n        { name: \"note volume\", pianoName: \"Note Vol.\", maxRawVol: Config.volumeRange, newNoteVol: Math.ceil(Config.volumeRange / 2), forSong: false, convertRealFactor: Math.ceil(-Config.volumeRange / 2.0), associatedEffect: EffectType.length,\r\n            promptName: \"Note Volume\", promptDesc: [ \"This setting affects the volume of your instrument as if its note size had been scaled.\", \"At $MID, an instrument's volume will be unchanged from default. This means you can still use the volume sliders to mix the base volume of instruments. The volume gradually increases up to $HI, or decreases down to mute at $LO.\", \"This setting was the default for volume modulation in JummBox for a long time. Due to some new effects like distortion and bitcrush, note volume doesn't always allow fine volume control. Also, this modulator affects the value of FM modulator waves instead of just carriers. This can distort the sound which may be useful, but also may be undesirable. In those cases, use the 'mix volume' modulator instead, which will always just scale the volume with no added effects.\", \"For display purposes, this mod will show up on the instrument volume slider, as long as there is not also an active 'mix volume' modulator anyhow. However, as mentioned, it works more like changing note volume.\", \"[MULTIPLICATIVE] [$LO - $HI]\" ] },\r\n        { name: \"pan\", pianoName: \"Pan\", maxRawVol: Config.panMax, newNoteVol: Math.ceil(Config.panMax / 2), forSong: false, convertRealFactor: 0, associatedEffect: EffectType.panning,\r\n            promptName: \"Instrument Panning\", promptDesc: [ \"This setting controls the panning of your instrument, just like the panning slider.\", \"At $LO, your instrument will sound like it is coming fully from the left-ear side. At $MID it will be right in the middle, and at $HI, it will sound like it's on the right.\", \"[OVERWRITING] [$LO - $HI] [L-R]\" ] },\r\n        { name: \"reverb\", pianoName: \"Reverb\", maxRawVol: Config.reverbRange, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.reverb,\r\n            promptName: \"Instrument Reverb\", promptDesc: [ \"This setting controls the reverb of your insturment, just like the reverb slider.\", \"At $LO, your instrument will have no reverb. At $HI, it will be at maximum.\", \"[OVERWRITING] [$LO - $HI]\"] },\r\n        { name: \"distortion\", pianoName: \"Distortion\", maxRawVol: Config.distortionRange-1, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.distortion,\r\n            promptName: \"Instrument Distortion\", promptDesc: [ \"This setting controls the amount of distortion for your instrument, just like the distortion slider.\", \"At $LO, your instrument will have no distortion. At $HI, it will be at maximum.\", \"[OVERWRITING] [$LO - $HI]\" ] },\r\n        { name: \"fm slider 1\", pianoName: \"FM 1\", maxRawVol: 15, newNoteVol: 15, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.length,\r\n            promptName: \"FM Slider 1\", promptDesc: [ \"This setting affects the strength of the first FM slider, just like the corresponding slider on your instrument.\", \"It works in a multiplicative way, so at $HI your slider will sound the same is its default value, and at $LO it will sound like it has been moved all the way to the left.\", \"For the full range of control with this mod, move your underlying slider all the way to the right.\", \"[MULTIPLICATIVE] [$LO - $HI] [%]\"] },\r\n        { name: \"fm slider 2\", pianoName: \"FM 2\", maxRawVol: 15, newNoteVol: 15, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.length,\r\n            promptName: \"FM Slider 2\", promptDesc: [\"This setting affects the strength of the second FM slider, just like the corresponding slider on your instrument.\", \"It works in a multiplicative way, so at $HI your slider will sound the same is its default value, and at $LO it will sound like it has been moved all the way to the left.\", \"For the full range of control with this mod, move your underlying slider all the way to the right.\", \"[MULTIPLICATIVE] [$LO - $HI] [%]\" ] },\r\n        { name: \"fm slider 3\", pianoName: \"FM 3\", maxRawVol: 15, newNoteVol: 15, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.length,\r\n            promptName: \"FM Slider 3\", promptDesc: [\"This setting affects the strength of the third FM slider, just like the corresponding slider on your instrument.\", \"It works in a multiplicative way, so at $HI your slider will sound the same is its default value, and at $LO it will sound like it has been moved all the way to the left.\", \"For the full range of control with this mod, move your underlying slider all the way to the right.\", \"[MULTIPLICATIVE] [$LO - $HI] [%]\" ] },\r\n        { name: \"fm slider 4\", pianoName: \"FM 4\", maxRawVol: 15, newNoteVol: 15, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.length,\r\n            promptName: \"FM Slider 4\", promptDesc: [\"This setting affects the strength of the fourth FM slider, just like the corresponding slider on your instrument.\", \"It works in a multiplicative way, so at $HI your slider will sound the same is its default value, and at $LO it will sound like it has been moved all the way to the left.\", \"For the full range of control with this mod, move your underlying slider all the way to the right.\", \"[MULTIPLICATIVE] [$LO - $HI] [%]\"] },\r\n        { name: \"fm feedback\", pianoName: \"FM Feedback\", maxRawVol: 15, newNoteVol: 15, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.length,\r\n            promptName: \"FM Feedback\", promptDesc: [\"This setting affects the strength of the FM feedback slider, just like the corresponding slider on your instrument.\", \"It works in a multiplicative way, so at $HI your slider will sound the same is its default value, and at $LO it will sound like it has been moved all the way to the left.\", \"For the full range of control with this mod, move your underlying slider all the way to the right.\", \"[MULTIPLICATIVE] [$LO - $HI] [%]\"] },\r\n        { name: \"pulse width\", pianoName: \"Pulse Width\", maxRawVol: Config.pulseWidthRange, newNoteVol: Config.pulseWidthRange, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.length,\r\n            promptName: \"Pulse Width\", promptDesc: [\"This setting controls the width of this instrument's pulse wave, just like the pulse width slider.\", \"At $HI, your instrument will sound like a pure square wave (on 50% of the time). It will gradually sound narrower down to $LO, where it will be inaudible (as it is on 0% of the time).\", \"Changing pulse width randomly between a few values is a common strategy in chiptune music to lend some personality to a lead instrument.\", \"[OVERWRITING] [$LO - $HI] [%Duty]\"] },\r\n        { name: \"detune\", pianoName: \"Detune\", maxRawVol: Config.detuneMax - Config.detuneMin, newNoteVol: Config.detuneCenter, forSong: false, convertRealFactor: -Config.detuneCenter, associatedEffect: EffectType.detune,\r\n            promptName: \"Instrument Detune\", promptDesc: [\"This setting controls the detune for this instrument, just like the detune slider.\", \"At $MID, your instrument will have no detune applied. Each tick corresponds to one cent, or one-hundredth of a pitch. Thus, each change of 100 ticks corresponds to one half-step of detune, up to two half-steps up at $HI, or two half-steps down at $LO.\", \"[OVERWRITING] [$LO - $HI] [cents]\"] },\r\n        { name: \"vibrato depth\", pianoName: \"Vibrato Depth\", maxRawVol: 50, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.vibrato,\r\n            promptName: \"Vibrato Depth\", promptDesc: [\"This setting controls the amount that your pitch moves up and down by during vibrato, just like the vibrato depth slider.\", \"At $LO, your instrument will have no vibrato depth so its vibrato would be inaudible. This increases up to $HI, where an extreme pitch change will be noticeable.\", \"[OVERWRITING] [$LO - $HI] [pitch ÷25]\"] },\r\n        { name: \"song detune\", pianoName: \"Detune\", maxRawVol: Config.songDetuneMax - Config.songDetuneMin, newNoteVol: Math.ceil((Config.songDetuneMax - Config.songDetuneMin) / 2), forSong: true, convertRealFactor: -250, associatedEffect: EffectType.length,\r\n            promptName: \"Song Detune\", promptDesc: [\"This setting controls the overall detune of the entire song. There is no associated slider.\", \"At $MID, your song will have no extra detune applied and sound unchanged from default. Each tick corresponds to four cents, or four hundredths of a pitch. Thus, each change of 25 ticks corresponds to one half-step of detune, up to 10 half-steps up at $HI, or 10 half-steps down at $LO.\", \"[MULTIPLICATIVE] [$LO - $HI] [cents x4]\"] },\r\n        { name: \"vibrato speed\", pianoName: \"Vibrato Speed\", maxRawVol: 30, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.vibrato,\r\n            promptName: \"Vibrato Speed\", promptDesc: [\"This setting controls the speed your instrument will vibrato at, just like the slider.\", \"A setting of $LO means there will be no oscillation, and vibrato will be disabled. Higher settings will increase the speed, up to a dramatic trill at the max value, $HI.\", \"[OVERWRITING] [$LO - $HI]\"] },\r\n        { name: \"vibrato delay\", pianoName: \"Vibrato Delay\", maxRawVol: 50, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.vibrato,\r\n            promptName: \"Vibrato Delay\", promptDesc: [\"This setting controls the amount of time vibrato will be held off for before triggering for every new note, just like the slider.\", \"A setting of $LO means there will be no delay. A setting of 24 corresponds to one full beat of delay. As a sole exception to this scale, setting delay to $HI will completely disable vibrato (as if it had infinite delay).\", \"[OVERWRITING] [$LO - $HI] [beats ÷24]\"] },\r\n        { name: \"arp speed\", pianoName: \"Arp Speed\", maxRawVol: 50, newNoteVol: 10, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.chord,\r\n            promptName: \"Arpeggio Speed\", promptDesc: [\"This setting controls the speed at which your instrument's chords arpeggiate, just like the arpeggio speed slider.\", \"Each setting corresponds to a different speed, from the slowest to the fastest. The speeds are listed below.\",\r\n                \"[0-4]: x0, x1/16, x⅛, x⅕, x¼,\", \"[5-9]: x⅓, x⅖, x½, x⅔, x¾,\", \"[10-14]: x⅘, x0.9, x1, x1.1, x1.2,\", \"[15-19]: x1.3, x1.4, x1.5, x1.6, x1.7,\", \"[20-24]: x1.8, x1.9, x2, x2.1, x2.2,\", \"[25-29]: x2.3, x2.4, x2.5, x2.6, x2.7,\", \"[30-34]: x2.8, x2.9, x3, x3.1, x3.2,\", \"[35-39]: x3.3, x3.4, x3.5, x3.6, x3.7,\" ,\"[40-44]: x3.8, x3.9, x4, x4.15, x4.3,\", \"[45-50]: x4.5, x4.8, x5, x5.5, x6, x8\", \"[OVERWRITING] [$LO - $HI]\"] },\r\n        { name: \"pan delay\", pianoName: \"Pan Delay\", maxRawVol: 20, newNoteVol: 10, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.panning,\r\n            promptName: \"Panning Delay\", promptDesc: [\"This setting controls the delay applied to panning for your instrument, just like the pan delay slider.\", \"With more delay, the panning effect will generally be more pronounced. $MID is the default value, whereas $LO will remove any delay at all. No delay can be desirable for chiptune songs.\", \"[OVERWRITING] [$LO - $HI]\"] },\r\n        { name: \"reset arp\", pianoName: \"Reset Arp\", maxRawVol: 1, newNoteVol: 1, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.chord,\r\n            promptName: \"Reset Arpeggio\", promptDesc: [\"This setting functions a little different from most. Wherever a note is placed, the arpeggio of this instrument will reset at the very start of that note. This is most noticeable with lower arpeggio speeds. The lengths and values of notes for this setting don't matter, just the note start times.\", \"This mod can be used to sync up your apreggios so that they always sound the same, even if you are using an odd-ratio arpeggio speed or modulating arpeggio speed.\", \"[$LO - $HI]\"] },\r\n        { name: \"eq filter\", pianoName: \"EQFlt\", maxRawVol: 10, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.length,\r\n            promptName: \"EQ Filter\", promptDesc: [\"This setting controls a few separate things for your instrument's EQ filter.\", \"When the option 'morph' is selected, your modulator values will indicate a sub-filter index of your EQ filter to 'morph' to over time. For example, a change from 0 to 1 means your main filter (default) will morph to sub-filter 1 over the specified duration. You can shape the main filter and sub-filters in the large filter editor ('+' button). If your two filters' number, type, and order of filter dots all match up, the morph will happen smoothly and you'll be able to hear them changing. If they do not match up, the filters will simply jump between each other.\", \"Note that filters will morph based on endpoints in the pattern editor. So, if you specify a morph from sub-filter 1 to 4 but do not specifically drag in new endpoints for 2 and 3, it will morph directly between 1 and 4 without going through the others.\", \"If you target Dot X or Dot Y, you can finely tune the coordinates of a single dot for your filter. The number of available dots to choose is dependent on your main filter's dot count.\", \"[OVERWRITING] [$LO - $HI]\"] },\r\n        { name: \"note filter\", pianoName: \"N.Flt\", maxRawVol: 10, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.noteFilter,\r\n            promptName: \"Note Filter\", promptDesc: [\"This setting controls a few separate things for your instrument's note filter.\", \"When the option 'morph' is selected, your modulator values will indicate a sub-filter index of your note filter to 'morph' to over time. For example, a change from 0 to 1 means your main filter (default) will morph to sub-filter 1 over the specified duration. You can shape the main filter and sub-filters in the large filter editor ('+' button). If your two filters' number, type, and order of filter dots all match up, the morph will happen smoothly and you'll be able to hear them changing. If they do not match up, the filters will simply jump between each other.\", \"Note that filters will morph based on endpoints in the pattern editor. So, if you specify a morph from sub-filter 1 to 4 but do not specifically drag in new endpoints for 2 and 3, it will morph directly between 1 and 4 without going through the others.\", \"If you target Dot X or Dot Y, you can finely tune the coordinates of a single dot for your filter. The number of available dots to choose is dependent on your main filter's dot count.\", \"[OVERWRITING] [$LO - $HI]\"] },\r\n        { name: \"bit crush\", pianoName: \"Bitcrush\", maxRawVol: Config.bitcrusherQuantizationRange-1, newNoteVol: Math.round(Config.bitcrusherQuantizationRange / 2), forSong: false, convertRealFactor: 0, associatedEffect: EffectType.bitcrusher,\r\n            promptName: \"Instrument Bit Crush\", promptDesc: [\"This setting controls the bit crush of your instrument, just like the bit crush slider.\", \"At a value of $LO, no bit crush will be applied. This increases and the bit crush effect gets more noticeable up to the max value, $HI.\", \"[OVERWRITING] [$LO - $HI]\"] },\r\n        { name: \"freq crush\", pianoName: \"Freq Crush\", maxRawVol: Config.bitcrusherFreqRange-1, newNoteVol: Math.round(Config.bitcrusherFreqRange / 2), forSong: false, convertRealFactor: 0, associatedEffect: EffectType.bitcrusher,\r\n            promptName: \"Instrument Frequency Crush\", promptDesc: [\"This setting controls the frequency crush of your instrument, just like the freq crush slider.\", \"At a value of $LO, no frequency crush will be applied. This increases and the frequency crush effect gets more noticeable up to the max value, $HI.\", \"[OVERWRITING] [$LO - $HI]\"] },\r\n        { name: \"echo\", pianoName: \"Echo\", maxRawVol: Config.echoSustainRange-1, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.echo,\r\n            promptName: \"Instrument Echo Sustain\", promptDesc: [\"This setting controls the echo sustain (echo loudness) of your instrument, just like the echo slider.\", \"At $LO, your instrument will have no echo sustain and echo will not be audible. Echo sustain increases and the echo effect gets more noticeable up to the max value, $HI.\", \"[OVERWRITING] [$LO - $HI]\"] },\r\n        { name: \"echo delay\", pianoName: \"Echo Delay\", maxRawVol: Config.echoDelayRange, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.length,\r\n            promptName: \"Instrument Echo Delay\", promptDesc: [\"This setting controls the echo delay of your instrument, just like the echo delay slider.\", \"At $LO, your instrument will have very little echo delay, and this increases up to 2 beats of delay at $HI.\", \"[OVERWRITING] [$LO - $HI] [~beats ÷12]\" ]\r\n        }, // Disabled via associatedEffect and manually in list build in SongEditor, enable and set back to echo after fixing bugginess!\r\n        { name: \"chorus\", pianoName: \"Chorus\", maxRawVol: Config.chorusRange, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.chorus,\r\n            promptName: \"Instrument Chorus\", promptDesc: [\"This setting controls the chorus strength of your instrument, just like the chorus slider.\", \"At $LO, the chorus effect will be disabled. The strength of the chorus effect increases up to the max value, $HI.\", \"[OVERWRITING] [$LO - $HI]\"] },\r\n        { name: \"eq filt cut\", pianoName: \"EQFlt Cut\", maxRawVol: Config.filterSimpleCutRange - 1, newNoteVol: Config.filterSimpleCutRange - 1, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.length,\r\n            promptName: \"EQ Filter Cutoff Frequency\", promptDesc: [\"This setting controls the filter cut position of your instrument, just like the filter cut slider.\", \"This setting is roughly analagous to the horizontal position of a single low-pass dot on the advanced filter editor. At lower values, a wider range of frequencies is cut off.\", \"[OVERWRITING] [$LO - $HI]\"] },\r\n        { name: \"eq filt peak\", pianoName: \"EQFlt Peak\", maxRawVol: Config.filterSimplePeakRange - 1, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.length,\r\n            promptName: \"EQ Filter Peak Gain\", promptDesc: [\"This setting controls the filter peak position of your instrument, just like the filter peak slider.\", \"This setting is roughly analagous to the vertical position of a single low-pass dot on the advanced filter editor. At lower values, the cutoff frequency will not be emphasized, and at higher values you will hear emphasis on the cutoff frequency.\", \"[OVERWRITING] [$LO - $HI]\"] },\r\n        { name: \"note filt cut\", pianoName: \"N.Flt Cut\", maxRawVol: Config.filterSimpleCutRange - 1, newNoteVol: Config.filterSimpleCutRange - 1, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.noteFilter,\r\n            promptName: \"Note Filter Cutoff Frequency\", promptDesc: [\"This setting controls the filter cut position of your instrument, just like the filter cut slider.\", \"This setting is roughly analagous to the horizontal position of a single low-pass dot on the advanced filter editor. At lower values, a wider range of frequencies is cut off.\", \"[OVERWRITING] [$LO - $HI]\"] },\r\n        { name: \"note filt peak\", pianoName: \"N.Flt Peak\", maxRawVol: Config.filterSimplePeakRange - 1, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.noteFilter,\r\n            promptName: \"Note Filter Peak Gain\", promptDesc: [\"This setting controls the filter peak position of your instrument, just like the filter peak slider.\", \"This setting is roughly analagous to the vertical position of a single low-pass dot on the advanced filter editor. At lower values, the cutoff frequency will not be emphasized, and at higher values you will hear emphasis on the cutoff frequency.\", \"[OVERWRITING] [$LO - $HI]\"] },\r\n        { name: \"pitch shift\", pianoName: \"Pitch Shift\", maxRawVol: Config.pitchShiftRange - 1, newNoteVol: Config.pitchShiftCenter, forSong: false, convertRealFactor: -Config.pitchShiftCenter, associatedEffect: EffectType.pitchShift,\r\n            promptName: \"Pitch Shift\", promptDesc: [\"This setting controls the pitch offset of your instrument, just like the pitch shift slider.\", \"At $MID your instrument will have no pitch shift. This increases as you decrease toward $LO pitches (half-steps) at the low end, or increases towards +$HI pitches at the high end.\", \"[OVERWRITING] [$LO - $HI] [pitch]\"] },\r\n        { name: \"sustain\", pianoName: \"Sustain\", maxRawVol: Config.stringSustainRange - 1, newNoteVol: 0, forSong: false, convertRealFactor: 0, associatedEffect: EffectType.length,\r\n            promptName: \"Picked String Sustain\", promptDesc: [\"This setting controls the sustain of your picked string instrument, just like the sustain slider.\", \"At $LO, your instrument will have minimum sustain and sound 'plucky'. This increases to a more held sound as your modulator approaches the maximum, $HI.\", \"[OVERWRITING] [$LO - $HI]\"] },\r\n        { name: \"mix volume\", pianoName: \"Mix Vol.\", maxRawVol: Config.volumeRange, newNoteVol: Math.ceil(Config.volumeRange / 2), forSong: false, convertRealFactor: Math.ceil(-Config.volumeRange / 2.0), associatedEffect: EffectType.length,\r\n            promptName: \"Mix Volume\", promptDesc: [\"This setting affects the volume of your instrument as if its volume slider had been moved.\", \"At $MID, an instrument's volume will be unchanged from default. This means you can still use the volume sliders to mix the base volume of instruments, since this setting and the default value work multiplicatively. The volume gradually increases up to $HI, or decreases down to mute at $LO.\", \"Unlike the 'note volume' setting, mix volume is very straightforward and simply affects the resultant instrument volume after all effects are applied.\", \"[MULTIPLICATIVE] [$LO - $HI]\"] },\r\n    ]);\r\n}\r\n\r\nfunction centerWave(wave: Array<number>): Float32Array {\r\n    let sum: number = 0.0;\r\n    for (let i: number = 0; i < wave.length; i++) sum += wave[i];\r\n    const average: number = sum / wave.length;\r\n    for (let i: number = 0; i < wave.length; i++) wave[i] -= average;\r\n    performIntegral(wave);\r\n    // The first sample should be zero, and we'll duplicate it at the end for easier interpolation.\r\n    wave.push(0);\r\n    return new Float32Array(wave);\r\n}\r\nfunction centerAndNormalizeWave(wave: Array<number>): Float32Array {\r\n    let magn: number = 0.0;\r\n\r\n    centerWave(wave);\r\n\r\n    // Going to length-1 because an extra 0 sample is added on the end as part of centerWave, which shouldn't impact magnitude calculation.\r\n    for (let i: number = 0; i < wave.length - 1; i++) {\r\n        magn += Math.abs(wave[i]);\r\n    }\r\n    const magnAvg: number = magn / (wave.length - 1);\r\n\r\n    for (let i: number = 0; i < wave.length - 1; i++) {\r\n        wave[i] = wave[i] / magnAvg;\r\n    }\r\n\r\n    return new Float32Array(wave);\r\n\r\n}\r\nexport function performIntegral(wave: { length: number, [index: number]: number }): Float32Array {\r\n    // Perform the integral on the wave. The synth function will perform the derivative to get the original wave back but with antialiasing.\r\n    let cumulative: number = 0.0;\r\n    let newWave: Float32Array = new Float32Array(wave.length);\r\n    for (let i: number = 0; i < wave.length; i++) {\r\n        newWave[i] = cumulative;\r\n        cumulative += wave[i];\r\n    }\r\n\r\n    return newWave;\r\n}\r\nexport function performIntegralOld(wave: { length: number, [index: number]: number }): void {\r\n\t// Old ver used in harmonics/picked string instruments, manipulates wave in place.\r\n\tlet cumulative: number = 0.0;\r\n\tfor (let i: number = 0; i < wave.length; i++) {\r\n\t\tconst temp = wave[i];\r\n\t\twave[i] = cumulative;\r\n\t\tcumulative += temp;\r\n\t}\r\n}\r\n\r\nexport function getPulseWidthRatio(pulseWidth: number): number {\r\n    // BeepBox formula for reference\r\n    //return Math.pow(0.5, (Config.pulseWidthRange - 1 - pulseWidth) * Config.pulseWidthStepPower) * 0.5;\r\n\r\n    return pulseWidth / (Config.pulseWidthRange * 2);\r\n}\r\n\r\n\r\n// The function arguments will be defined in FFT.ts, but I want\r\n// SynthConfig.ts to be at the top of the compiled JS so I won't directly\r\n// depend on FFT here. synth.ts will take care of importing FFT.ts.\r\n//function inverseRealFourierTransform(array: {length: number, [index: number]: number}, fullArrayLength: number): void;\r\n//function scaleElementsByFactor(array: {length: number, [index: number]: number}, factor: number): void;\r\nexport function getDrumWave(index: number, inverseRealFourierTransform: Function | null, scaleElementsByFactor: Function | null): Float32Array {\r\n    let wave: Float32Array | null = Config.chipNoises[index].samples;\r\n    if (wave == null) {\r\n        wave = new Float32Array(Config.chipNoiseLength + 1);\r\n        Config.chipNoises[index].samples = wave;\r\n\r\n        if (index == 0) {\r\n            // The \"retro\" drum uses a \"Linear Feedback Shift Register\" similar to the NES noise channel.\r\n            let drumBuffer: number = 1;\r\n            for (let i: number = 0; i < Config.chipNoiseLength; i++) {\r\n                wave[i] = (drumBuffer & 1) * 2.0 - 1.0;\r\n                let newBuffer: number = drumBuffer >> 1;\r\n                if (((drumBuffer + newBuffer) & 1) == 1) {\r\n                    newBuffer += 1 << 14;\r\n                }\r\n                drumBuffer = newBuffer;\r\n            }\r\n        } else if (index == 1) {\r\n            // White noise is just random values for each sample.\r\n            for (let i: number = 0; i < Config.chipNoiseLength; i++) {\r\n                wave[i] = Math.random() * 2.0 - 1.0;\r\n            }\r\n        } else if (index == 2) {\r\n            // The \"clang\" noise wave is based on a similar noise wave in the modded beepbox made by DAzombieRE.\r\n            let drumBuffer: number = 1;\r\n            for (let i: number = 0; i < Config.chipNoiseLength; i++) {\r\n                wave[i] = (drumBuffer & 1) * 2.0 - 1.0;\r\n                let newBuffer: number = drumBuffer >> 1;\r\n                if (((drumBuffer + newBuffer) & 1) == 1) {\r\n                    newBuffer += 2 << 14;\r\n                }\r\n                drumBuffer = newBuffer;\r\n            }\r\n        } else if (index == 3) {\r\n            // The \"buzz\" noise wave is based on a similar noise wave in the modded beepbox made by DAzombieRE.\r\n            let drumBuffer: number = 1;\r\n            for (let i: number = 0; i < Config.chipNoiseLength; i++) {\r\n                wave[i] = (drumBuffer & 1) * 2.0 - 1.0;\r\n                let newBuffer: number = drumBuffer >> 1;\r\n                if (((drumBuffer + newBuffer) & 1) == 1) {\r\n                    newBuffer += 10 << 2;\r\n                }\r\n                drumBuffer = newBuffer;\r\n            }\r\n        } else if (index == 4) {\r\n            // \"hollow\" drums, designed in frequency space and then converted via FFT:\r\n            drawNoiseSpectrum(wave, Config.chipNoiseLength, 10, 11, 1, 1, 0);\r\n            drawNoiseSpectrum(wave, Config.chipNoiseLength, 11, 14, .6578, .6578, 0);\r\n            inverseRealFourierTransform!(wave, Config.chipNoiseLength);\r\n            scaleElementsByFactor!(wave, 1.0 / Math.sqrt(Config.chipNoiseLength));\r\n        } else if (index == 5) {\r\n            // \"Shine\" drums from modbox!\r\n            var drumBuffer = 1;\r\n            for (var i = 0; i < Config.chipNoiseLength; i++) {\r\n                wave[i] = (drumBuffer & 1) * 2.0 - 1.0;\r\n                var newBuffer = drumBuffer >> 1;\r\n                if (((drumBuffer + newBuffer) & 1) == 1) {\r\n                    newBuffer += 10 << 2;\r\n                }\r\n                drumBuffer = newBuffer;\r\n            }\r\n        } else if (index == 6) {\r\n            // \"Deep\" drums from modbox!\r\n            drawNoiseSpectrum(wave, Config.chipNoiseLength, 1, 10, 1, 1, 0);\r\n            drawNoiseSpectrum(wave, Config.chipNoiseLength, 20, 14, -2, -2, 0);\r\n            inverseRealFourierTransform!(wave, Config.chipNoiseLength);\r\n            scaleElementsByFactor!(wave, 1.0 / Math.sqrt(Config.chipNoiseLength));\r\n        } else if (index == 7) {\r\n            // \"Cutter\" drums from modbox!\r\n            var drumBuffer = 1;\r\n            for (var i = 0; i < Config.chipNoiseLength; i++) {\r\n                wave[i] = (drumBuffer & 1) * 4.0 * (Math.random() * 14 + 1);\r\n                var newBuffer = drumBuffer >> 1;\r\n                if (((drumBuffer + newBuffer) & 1) == 1) {\r\n                    newBuffer += 15 << 2;\r\n                }\r\n                drumBuffer = newBuffer;\r\n            }\r\n        } else if (index == 8) {\r\n            // \"Metallic\" drums from modbox!\r\n            var drumBuffer = 1;\r\n            for (var i = 0; i < 32768; i++) {\r\n                wave[i] = (drumBuffer & 1) / 2.0 + 0.5;\r\n                var newBuffer = drumBuffer >> 1;\r\n                if (((drumBuffer + newBuffer) & 1) == 1) {\r\n                    newBuffer -= 10 << 2;\r\n                }\r\n                drumBuffer = newBuffer;\r\n            }\r\n        } else {\r\n            throw new Error(\"Unrecognized drum index: \" + index);\r\n        }\r\n\r\n        wave[Config.chipNoiseLength] = wave[0];\r\n    }\r\n\r\n    return wave;\r\n}\r\n\r\nexport function drawNoiseSpectrum(wave: Float32Array, waveLength: number, lowOctave: number, highOctave: number, lowPower: number, highPower: number, overallSlope: number): number {\r\n    const referenceOctave: number = 11;\r\n    const referenceIndex: number = 1 << referenceOctave;\r\n    const lowIndex: number = Math.pow(2, lowOctave) | 0;\r\n    const highIndex: number = Math.min(waveLength >> 1, Math.pow(2, highOctave) | 0);\r\n    const retroWave: Float32Array = getDrumWave(0, null, null);\r\n    let combinedAmplitude: number = 0.0;\r\n    for (let i: number = lowIndex; i < highIndex; i++) {\r\n\r\n        let lerped: number = lowPower + (highPower - lowPower) * (Math.log2(i) - lowOctave) / (highOctave - lowOctave);\r\n        let amplitude: number = Math.pow(2, (lerped - 1) * 7 + 1) * lerped;\r\n\r\n        amplitude *= Math.pow(i / referenceIndex, overallSlope);\r\n\r\n        combinedAmplitude += amplitude;\r\n\r\n        // Add two different sources of psuedo-randomness to the noise\r\n        // (individually they aren't random enough) but in a deterministic\r\n        // way so that live spectrum editing doesn't result in audible pops.\r\n        // Multiply all the sine wave amplitudes by 1 or -1 based on the\r\n        // LFSR retro wave (effectively random), and also rotate the phase\r\n        // of each sine wave based on the golden angle to disrupt the symmetry.\r\n        amplitude *= retroWave[i];\r\n        const radians: number = 0.61803398875 * i * i * Math.PI * 2.0;\r\n\r\n        wave[i] = Math.cos(radians) * amplitude;\r\n        wave[waveLength - i] = Math.sin(radians) * amplitude;\r\n    }\r\n\r\n    return combinedAmplitude;\r\n}\r\n\r\nfunction generateSineWave(): Float32Array {\r\n    const wave: Float32Array = new Float32Array(Config.sineWaveLength + 1);\r\n    for (let i: number = 0; i < Config.sineWaveLength + 1; i++) {\r\n        wave[i] = Math.sin(i * Math.PI * 2.0 / Config.sineWaveLength);\r\n    }\r\n    return wave;\r\n}\r\n\r\nfunction generateTriWave(): Float32Array {\r\n    const wave: Float32Array = new Float32Array(Config.sineWaveLength + 1);\r\n    for (let i: number = 0; i < Config.sineWaveLength + 1; i++) {\r\n        wave[i] = Math.asin(Math.sin(i * Math.PI * 2.0 / Config.sineWaveLength)) / (Math.PI / 2);\r\n    }\r\n    return wave;\r\n}\r\n\r\nfunction generateTrapezoidWave(drive: number = 2): Float32Array {\r\n    const wave: Float32Array = new Float32Array(Config.sineWaveLength + 1);\r\n    for (let i: number = 0; i < Config.sineWaveLength + 1; i++) {\r\n        wave[i] = Math.max(-1.0, Math.min(1.0, Math.asin(Math.sin(i * Math.PI * 2.0 / Config.sineWaveLength)) * drive));\r\n    }\r\n    return wave;\r\n}\r\n\r\nfunction generateSquareWave(phaseWidth: number = 0): Float32Array {\r\n    const wave: Float32Array = new Float32Array(Config.sineWaveLength + 1);\r\n    const centerPoint: number = Config.sineWaveLength / 4;\r\n    for (let i: number = 0; i < Config.sineWaveLength + 1; i++) {\r\n        wave[i] = +((Math.abs(i - centerPoint) < phaseWidth * Config.sineWaveLength / 2)\r\n            || ((Math.abs(i - Config.sineWaveLength - centerPoint) < phaseWidth * Config.sineWaveLength / 2))) * 2 - 1;\r\n    }\r\n    return wave;\r\n}\r\n\r\nfunction generateSawWave(inverse: boolean = false): Float32Array {\r\n    const wave: Float32Array = new Float32Array(Config.sineWaveLength + 1);\r\n    for (let i: number = 0; i < Config.sineWaveLength + 1; i++) {\r\n        wave[i] = ((i + (Config.sineWaveLength / 4.0)) * 2.0 / Config.sineWaveLength) % 2 - 1;\r\n        wave[i] = inverse ? -wave[i] : wave[i];\r\n    }\r\n    return wave;\r\n}\r\n\r\nexport function getArpeggioPitchIndex(pitchCount: number, useFastTwoNoteArp: boolean, arpeggio: number): number {\r\n    let arpeggioPattern: ReadonlyArray<number> = Config.arpeggioPatterns[pitchCount - 1];\r\n    if (arpeggioPattern != null) {\r\n        if (pitchCount == 2 && useFastTwoNoteArp == false) {\r\n            arpeggioPattern = [0, 0, 1, 1];\r\n        }\r\n        return arpeggioPattern[arpeggio % arpeggioPattern.length];\r\n    } else {\r\n        return arpeggio % pitchCount;\r\n    }\r\n}\r\n\r\n// Pardon the messy type casting. This allows accessing array members by numerical index or string name.\r\nexport function toNameMap<T extends BeepBoxOption>(array: Array<Pick<T, Exclude<keyof T, \"index\">>>): DictionaryArray<T> {\r\n    const dictionary: Dictionary<T> = {};\r\n    for (let i: number = 0; i < array.length; i++) {\r\n        const value: any = array[i];\r\n        value.index = i;\r\n        dictionary[value.name] = <T>value;\r\n    }\r\n    const result: DictionaryArray<T> = <DictionaryArray<T>><any>array;\r\n    result.dictionary = dictionary;\r\n    return result;\r\n}\r\n\r\nexport function effectsIncludeTransition(effects: number): boolean {\r\n    return (effects & (1 << EffectType.transition)) != 0;\r\n}\r\nexport function effectsIncludeChord(effects: number): boolean {\r\n    return (effects & (1 << EffectType.chord)) != 0;\r\n}\r\nexport function effectsIncludePitchShift(effects: number): boolean {\r\n    return (effects & (1 << EffectType.pitchShift)) != 0;\r\n}\r\nexport function effectsIncludeDetune(effects: number): boolean {\r\n    return (effects & (1 << EffectType.detune)) != 0;\r\n}\r\nexport function effectsIncludeVibrato(effects: number): boolean {\r\n    return (effects & (1 << EffectType.vibrato)) != 0;\r\n}\r\nexport function effectsIncludeNoteFilter(effects: number): boolean {\r\n    return (effects & (1 << EffectType.noteFilter)) != 0;\r\n}\r\nexport function effectsIncludeDistortion(effects: number): boolean {\r\n    return (effects & (1 << EffectType.distortion)) != 0;\r\n}\r\nexport function effectsIncludeBitcrusher(effects: number): boolean {\r\n    return (effects & (1 << EffectType.bitcrusher)) != 0;\r\n}\r\nexport function effectsIncludePanning(effects: number): boolean {\r\n    return (effects & (1 << EffectType.panning)) != 0;\r\n}\r\nexport function effectsIncludeChorus(effects: number): boolean {\r\n    return (effects & (1 << EffectType.chorus)) != 0;\r\n}\r\nexport function effectsIncludeEcho(effects: number): boolean {\r\n    return (effects & (1 << EffectType.echo)) != 0;\r\n}\r\nexport function effectsIncludeReverb(effects: number): boolean {\r\n    return (effects & (1 << EffectType.reverb)) != 0;\r\n}\r\nexport function effectsIncludeNoteRange(effects: number): boolean {\r\n    return (effects & (1 << EffectType.noteRange)) != 0;\r\n}\r\nexport function effectsIncludeInvertWave(effects: number): boolean {\r\n    return (effects & (1 << EffectType.invertWave)) != 0;\r\n}\r\nexport function rawChipToIntegrated(raw: DictionaryArray<ChipWave>): DictionaryArray<ChipWave> {\r\n    const newArray: Array<ChipWave> = new Array<ChipWave>(raw.length);\r\n    const dictionary: Dictionary<ChipWave> = {};\r\n    for (let i: number = 0; i < newArray.length; i++) {\r\n        newArray[i] = Object.assign([], raw[i]);\r\n        const value: any = newArray[i];\r\n        value.index = i;\r\n        dictionary[value.name] = <ChipWave>value;\r\n    }\r\n    for (let key in dictionary) {\r\n        dictionary[key].samples = performIntegral(dictionary[key].samples);\r\n    }\r\n    const result: DictionaryArray<ChipWave> = <DictionaryArray<ChipWave>><any>newArray;\r\n    result.dictionary = dictionary;\r\n    return result;\r\n}","// Copyright (c) 2012-2022 John Nesky and contributing authors, distributed under the MIT license, see accompanying the LICENSE.md file.\r\n\r\nimport { DictionaryArray, BeepBoxOption, InstrumentType, toNameMap } from \"../synth/SynthConfig\";\r\n\r\nexport interface PresetCategory extends BeepBoxOption {\r\n    readonly presets: DictionaryArray<Preset>;\r\n}\r\n\r\nexport interface Preset extends BeepBoxOption {\r\n    readonly isNoise?: boolean;\r\n    readonly isMod?: boolean;\r\n    readonly generalMidi?: boolean;\r\n    readonly midiProgram?: number;\r\n    readonly midiSubharmonicOctaves?: number;\r\n    readonly customType?: InstrumentType;\r\n    readonly settings?: any;\r\n}\r\n\r\nexport const isMobile: boolean = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|android|ipad|playbook|silk/i.test(navigator.userAgent);\r\n\r\nexport function prettyNumber(value: number): string {\r\n    return value.toFixed(2).replace(/\\.?0*$/, \"\");\r\n}\r\n\r\nexport class EditorConfig {\r\n    public static readonly version: string = \"1.1\"; // Not using patch versions in display right now, maybe someday.\r\n    public static readonly versionDisplayName: string = \"Dogebox2 \" + EditorConfig.version;\r\n\r\n    public static readonly releaseNotesURL: string = \"https://dogeiscut.github.io/dogebox2/patch_notes/\" + EditorConfig.version + \".html\";\r\n\r\n    public static readonly isOnMac: boolean = /^Mac/i.test(navigator.platform) || /Mac OS X/i.test(navigator.userAgent) || /^(iPhone|iPad|iPod)/i.test(navigator.platform) || /(iPhone|iPad|iPod)/i.test(navigator.userAgent);\r\n    public static readonly ctrlSymbol: string = EditorConfig.isOnMac ? \"⌘\" : \"Ctrl+\";\r\n    public static readonly ctrlName: string = EditorConfig.isOnMac ? \"command\" : \"control\";\r\n\r\n    public static readonly presetCategories: DictionaryArray<PresetCategory> = toNameMap([\r\n        {\r\n            name: \"Custom Instruments\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"chip wave\", customType: InstrumentType.chip },\r\n                { name: \"FM (expert)\", customType: InstrumentType.fm },\r\n                { name: \"basic noise\", customType: InstrumentType.noise },\r\n                { name: \"spectrum\", customType: InstrumentType.spectrum },\r\n                { name: \"drumset\", customType: InstrumentType.drumset },\r\n                { name: \"harmonics\", customType: InstrumentType.harmonics },\r\n                { name: \"pulse width\", customType: InstrumentType.pwm },\r\n                { name: \"picked string\", customType: InstrumentType.pickedString },\r\n                { name: \"custom chip\", customType: InstrumentType.customChipWave },\r\n            ])\r\n        },\r\n        {\r\n            name: \"Retro Presets\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"square wave\", midiProgram: 80, settings: { \"type\": \"chip\", \"eqFilter\": [], \"effects\": [\"aliasing\"], \"transition\": \"interrupt\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -1, \"chord\": \"arpeggio\", \"wave\": \"square\", \"unison\": \"none\", \"envelopes\": [] } },\r\n                { name: \"triangle wave\", midiProgram: 71, settings: { \"type\": \"chip\", \"eqFilter\": [], \"effects\": [\"aliasing\"], \"transition\": \"interrupt\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -1, \"chord\": \"arpeggio\", \"wave\": \"triangle\", \"unison\": \"none\", \"envelopes\": [] } },\r\n                { name: \"square lead\", midiProgram: 80, generalMidi: true, settings: { \"type\": \"chip\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 8000, \"linearGain\": 0.3536 }], \"effects\": [\"aliasing\"], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"simultaneous\", \"wave\": \"square\", \"unison\": \"hum\", \"envelopes\": [] } },\r\n                { name: \"sawtooth lead 1\", midiProgram: 81, generalMidi: true, settings: { \"type\": \"chip\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4000, \"linearGain\": 0.5 }], \"effects\": [\"aliasing\"], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"simultaneous\", \"wave\": \"sawtooth\", \"unison\": \"shimmer\", \"envelopes\": [] } },\r\n                { name: \"sawtooth lead 2\", midiProgram: 81, settings: { \"type\": \"chip\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 6727.17, \"linearGain\": 1 }], \"effects\": [\"vibrato\", \"aliasing\"], \"vibrato\": \"light\", \"transition\": \"normal\", \"fadeInSeconds\": 0.0125, \"fadeOutTicks\": 72, \"chord\": \"simultaneous\", \"wave\": \"sawtooth\", \"unison\": \"hum\", \"envelopes\": [] } },\r\n                { name: \"chip noise\", midiProgram: 116, isNoise: true, settings: { \"type\": \"noise\", \"transition\": \"hard\", \"effects\": [\"aliasing\"], \"chord\": \"arpeggio\", \"filterCutoffHz\": 4000, \"filterResonance\": 0, \"filterEnvelope\": \"steady\", \"wave\": \"retro\" } },\r\n                { name: \"FM twang\", midiProgram: 32, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"simultaneous\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 0, \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15 }, { \"frequency\": \"1×\", \"amplitude\": 15 }, { \"frequency\": \"1×\", \"amplitude\": 0 }, { \"frequency\": \"1×\", \"amplitude\": 0 }], \"envelopes\": [{ \"target\": \"operatorAmplitude\", \"envelope\": \"twang 2\", \"index\": 1 }] } },\r\n                { name: \"FM bass\", midiProgram: 36, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"custom interval\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 0, \"operators\": [{ \"frequency\": \"2×\", \"amplitude\": 11 }, { \"frequency\": \"1×\", \"amplitude\": 7 }, { \"frequency\": \"1×\", \"amplitude\": 9 }, { \"frequency\": \"20×\", \"amplitude\": 3 }], \"envelopes\": [{ \"target\": \"operatorAmplitude\", \"envelope\": \"twang 2\", \"index\": 1 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"twang 3\", \"index\": 2 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"twang 2\", \"index\": 3 }] } },\r\n                { name: \"FM flute\", midiProgram: 73, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [], \"transition\": \"normal\", \"fadeInSeconds\": 0.0263, \"fadeOutTicks\": -3, \"chord\": \"simultaneous\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 0, \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15 }, { \"frequency\": \"1×\", \"amplitude\": 6 }, { \"frequency\": \"1×\", \"amplitude\": 0 }, { \"frequency\": \"1×\", \"amplitude\": 0 }], \"envelopes\": [{ \"target\": \"operatorAmplitude\", \"envelope\": \"twang 2\", \"index\": 1 }] } },\r\n                { name: \"FM organ\", midiProgram: 16, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [\"vibrato\"], \"vibrato\": \"delayed\", \"transition\": \"normal\", \"fadeInSeconds\": 0.0263, \"fadeOutTicks\": -3, \"chord\": \"custom interval\", \"algorithm\": \"1←3 2←4\", \"feedbackType\": \"1⟲ 2⟲\", \"feedbackAmplitude\": 0, \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 14 }, { \"frequency\": \"2×\", \"amplitude\": 14 }, { \"frequency\": \"1×\", \"amplitude\": 11 }, { \"frequency\": \"2×\", \"amplitude\": 11 }], \"envelopes\": [] } },\r\n                { name: \"NES Pulse\", midiProgram: 80, settings: { \"type\": \"custom chip\", \"effects\": [\"aliasing\"], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"arpeggio\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 8000, \"linearGain\": 0.5 }], \"unison\": \"none\", \"vibrato\": \"none\", \"envelopes\": [], \"customChipWave\": [-24, -24, -24, -24, -23, -23, -23, -23, -22, -22, -22, -22, -21, -21, -21, -21, -20, -20, -20, -20, -19, -19, -19, -19, -18, -18, -18, -18, -17, -17, -17, -17, 24, 24, 24, 24, 23, 23, 23, 23, 22, 22, 22, 22, 21, 21, 21, 21, 20, 20, 20, 20, 19, 19, 19, 19, 18, 18, 18, 18, 17, 17, 17, 17] } },\r\n                { name: \"Gameboy Pulse\", midiProgram: 80, settings: { \"type\": \"custom chip\", \"effects\": [\"aliasing\"], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"arpeggio\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 8000, \"linearGain\": 0.5 }], \"unison\": \"none\", \"envelopes\": [], \"customChipWave\": [-24, -20, -17, -15, -13, -13, -11, -11, -11, -9, -9, -9, -9, -7, -7, -7, -7, -7, -5, -5, -5, -5, -5, -5, -3, -3, -3, -3, -3, -3, -3, -3, 24, 20, 17, 15, 13, 13, 11, 11, 11, 9, 9, 9, 9, 7, 7, 7, 7, 7, 5, 5, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3] } },\r\n                { name: \"VRC6 Sawtooth\", midiProgram: 81, settings: { \"type\": \"custom chip\", \"effects\": [\"aliasing\"], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"arpeggio\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 8000, \"linearGain\": 0.5 }], \"unison\": \"none\", \"envelopes\": [], \"customChipWave\": [-24, -20, -16, -13, -10, -8, -6, -5, -4, -4, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 12, 12, 12, 12, 12, 12, 12, 12, 16, 16, 16, 16, 16, 16, 16, 16, 20, 20, 20, 20, 20, 20, 20, 20, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24] } },\r\n                { name: \"Atari Square\", midiProgram: 80, settings: { \"type\": \"custom chip\", \"effects\": [\"aliasing\"], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"arpeggio\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4000, \"linearGain\": 0.5 }], \"unison\": \"none\", \"envelopes\": [], \"customChipWave\": [-24, -24, -24, -23, -23, -23, -22, -22, -22, -21, -21, -21, -20, -20, -20, -19, -19, -19, -18, -18, -18, -17, -17, -17, -16, -16, -16, -15, -15, -15, -14, -14, -14, -13, -13, -13, 24, 24, 24, 23, 23, 23, 22, 22, 22, 21, 21, 21, 20, 20, 20, 19, 19, 19, 18, 18, 18, 17, 17, 17, 16, 16, 15, 15] } },\r\n                { name: \"Atari Bass\", midiProgram: 36, settings: { \"type\": \"custom chip\", \"effects\": [\"aliasing\"], \"transition\": \"interrupt\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"arpeggio\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4000, \"linearGain\": 0.5 }], \"unison\": \"none\", \"envelopes\": [], \"customChipWave\": [-24, -24, -24, -24, -24, -24, -24, -24, -24, 24, 24, 24, 24, 24, 24, -24, -24, -24, 24, 24, 24, -24, -24, -24, 24, 24, 24, -24, -24, -24, 24, 24, -24, -24, -24, -24, -24, -24, -24, -24, -24, 24, 24, 24, 24, 24, 24, -24, -24, 24, 24, 24, 24, 24, -24, -24, -24, -24, 24, 24, -24, -24, 24, 24] } },\r\n                { name: \"Sunsoft Bass\", midiProgram: 36, settings: { \"type\": \"custom chip\", \"effects\": [\"aliasing\"], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"arpeggio\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4000, \"linearGain\": 0.5 }], \"unison\": \"none\", \"envelopes\": [], \"customChipWave\": [24, 24, 15, 15, 9, 9, -4, -4, 0, 0, -13, -13, -19, -19, -24, -24, -24, -24, -10, -10, 0, 0, -7, -7, -7, -7, 0, 0, 6, 6, -4, -4, 3, 3, -4, -4, 3, 3, 3, 3, 9, 9, 15, 15, 15, 15, 6, 6, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, 3, 3, 12, 12, 24, 24] } },\r\n\r\n            ])\r\n        },\r\n        {\r\n            name: \"Keyboard Presets\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"grand piano 1\", midiProgram: 0, generalMidi: true, settings: { \"type\": \"Picked String\", \"eqFilter\": [{ \"type\": \"high-pass\", \"cutoffHz\": 148.65, \"linearGain\": 0.7071 }, { \"type\": \"peak\", \"cutoffHz\": 2000, \"linearGain\": 2.8284 }], \"effects\": [\"note filter\", \"reverb\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 8000, \"linearGain\": 0.125 }], \"reverb\": 67, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 48, \"chord\": \"simultaneous\", \"harmonics\": [100, 100, 86, 86, 86, 71, 71, 71, 0, 86, 71, 71, 71, 57, 57, 71, 57, 14, 57, 57, 57, 57, 57, 57, 57, 57, 29, 57], \"unison\": \"piano\", \"stringSustain\": 79, \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"note size\" }] } },\r\n                { name: \"bright piano\", midiProgram: 1, generalMidi: true, settings: { \"type\": \"Picked String\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 1681.79, \"linearGain\": 0.7071 }, { \"type\": \"high-pass\", \"cutoffHz\": 148.65, \"linearGain\": 0.5 }, { \"type\": \"peak\", \"cutoffHz\": 3363.59, \"linearGain\": 1.4142 }], \"effects\": [\"reverb\"], \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 24, \"chord\": \"simultaneous\", \"harmonics\": [100, 100, 86, 86, 71, 71, 0, 71, 71, 71, 71, 71, 71, 14, 57, 57, 57, 57, 57, 57, 29, 57, 57, 57, 57, 57, 57, 57], \"unison\": \"piano\", \"stringSustain\": 86, \"envelopes\": [] } },\r\n                { name: \"electric grand\", midiProgram: 2, generalMidi: true, settings: { \"type\": \"chip\", \"eqFilter\": [], \"effects\": [\"note filter\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 2378.41, \"linearGain\": 0.5 }], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 48, \"chord\": \"simultaneous\", \"wave\": \"1/8 pulse\", \"unison\": \"shimmer\", \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"twang 3\" }] } },\r\n                { name: \"honky-tonk piano\", midiProgram: 3, generalMidi: true, settings: { \"type\": \"Picked String\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 5656.85, \"linearGain\": 0.3536 }], \"effects\": [\"reverb\"], \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 48, \"chord\": \"simultaneous\", \"harmonics\": [100, 100, 86, 71, 86, 71, 43, 71, 43, 43, 57, 57, 57, 29, 57, 57, 57, 57, 57, 57, 43, 57, 57, 57, 43, 43, 43, 43], \"unison\": \"honky tonk\", \"stringSustain\": 71, \"envelopes\": [] } },\r\n                { name: \"electric piano 1\", midiProgram: 4, generalMidi: true, settings: { \"type\": \"harmonics\", \"eqFilter\": [], \"effects\": [\"note filter\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 3363.59, \"linearGain\": 0.5 }], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"simultaneous\", \"harmonics\": [86, 100, 100, 71, 71, 57, 57, 43, 43, 43, 29, 29, 29, 14, 14, 14, 0, 0, 0, 0, 0, 57, 0, 0, 0, 0, 0, 0], \"unison\": \"none\", \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"twang 2\" }] } },\r\n                { name: \"electric piano 2\", midiProgram: 5, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [\"note filter\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 13454.34, \"linearGain\": 0.25 }], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 48, \"chord\": \"simultaneous\", \"algorithm\": \"1←3 2←4\", \"feedbackType\": \"1⟲ 2⟲\", \"feedbackAmplitude\": 0, \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 12 }, { \"frequency\": \"1×\", \"amplitude\": 6 }, { \"frequency\": \"1×\", \"amplitude\": 9 }, { \"frequency\": \"16×\", \"amplitude\": 6 }], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"twang 3\" }, { \"target\": \"operatorAmplitude\", \"envelope\": \"twang 3\", \"index\": 3 }] } },\r\n                { name: \"harpsichord\", midiProgram: 6, generalMidi: true, settings: { \"type\": \"Picked String\", \"eqFilter\": [{ \"type\": \"high-pass\", \"cutoffHz\": 250, \"linearGain\": 0.3536 }, { \"type\": \"peak\", \"cutoffHz\": 11313.71, \"linearGain\": 2.8284 }], \"effects\": [\"reverb\"], \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 24, \"chord\": \"simultaneous\", \"harmonics\": [100, 100, 100, 86, 57, 86, 86, 86, 86, 57, 57, 71, 71, 86, 86, 71, 71, 86, 86, 71, 71, 71, 71, 71, 71, 71, 71, 71], \"unison\": \"none\", \"stringSustain\": 79, \"envelopes\": [] } },\r\n                { name: \"clavinet\", midiProgram: 7, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [\"note filter\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 19027.31, \"linearGain\": 0.3536 }], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"simultaneous\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"3⟲\", \"feedbackAmplitude\": 6, \"operators\": [{ \"frequency\": \"3×\", \"amplitude\": 15 }, { \"frequency\": \"~1×\", \"amplitude\": 6 }, { \"frequency\": \"8×\", \"amplitude\": 4 }, { \"frequency\": \"1×\", \"amplitude\": 0 }], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"twang 2\" }, { \"target\": \"feedbackAmplitude\", \"envelope\": \"twang 2\" }] } },\r\n                { name: \"dulcimer\", midiProgram: 15, generalMidi: true, settings: { \"type\": \"Picked String\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 8000, \"linearGain\": 0.3536 }], \"effects\": [\"reverb\"], \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 48, \"chord\": \"strum\", \"harmonics\": [100, 100, 100, 86, 100, 86, 57, 100, 100, 86, 100, 86, 100, 86, 100, 71, 57, 71, 71, 100, 86, 71, 86, 86, 100, 86, 86, 86], \"unison\": \"piano\", \"stringSustain\": 79, \"envelopes\": [] } },\r\n                { name: \"grand piano 2\", midiProgram: 0, generalMidi: true, settings: { \"type\": \"harmonics\", \"eqFilter\": [{ \"type\": \"high-pass\", \"cutoffHz\": 148.65, \"linearGain\": 0.7071 }, { \"type\": \"peak\", \"cutoffHz\": 2000, \"linearGain\": 2.8284 }], \"effects\": [\"note filter\", \"reverb\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 8000, \"linearGain\": 0.125 }], \"reverb\": 67, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 48, \"chord\": \"simultaneous\", \"harmonics\": [100, 86, 86, 86, 86, 71, 71, 57, 0, 57, 29, 43, 57, 57, 57, 43, 43, 0, 29, 43, 43, 43, 43, 43, 43, 29, 0, 29], \"unison\": \"piano\", \"stringSustain\": 79, \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"note size\" }] } },\r\n\r\n            ])\r\n        },\r\n        {\r\n            name: \"Idiophone Presets\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"celesta\", midiProgram: 8, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 5657, \"filterResonance\": 14, \"filterEnvelope\": \"twang 2\", \"vibrato\": \"none\", \"algorithm\": \"(1 2)←(3 4)\", \"feedbackType\": \"1⟲ 2⟲\", \"feedbackAmplitude\": 0, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"~1×\", \"amplitude\": 11, \"envelope\": \"custom\" }, { \"frequency\": \"8×\", \"amplitude\": 6, \"envelope\": \"custom\" }, { \"frequency\": \"20×\", \"amplitude\": 3, \"envelope\": \"twang 1\" }, { \"frequency\": \"3×\", \"amplitude\": 1, \"envelope\": \"twang 2\" }] } },\r\n                { name: \"glockenspiel\", midiProgram: 9, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 5657, \"filterResonance\": 14, \"filterEnvelope\": \"twang 2\", \"vibrato\": \"none\", \"algorithm\": \"(1 2 3)←4\", \"feedbackType\": \"1⟲ 2⟲ 3⟲\", \"feedbackAmplitude\": 2, \"feedbackEnvelope\": \"decay 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 7, \"envelope\": \"custom\" }, { \"frequency\": \"5×\", \"amplitude\": 11, \"envelope\": \"custom\" }, { \"frequency\": \"8×\", \"amplitude\": 7, \"envelope\": \"custom\" }, { \"frequency\": \"20×\", \"amplitude\": 2, \"envelope\": \"twang 1\" }] } },\r\n                { name: \"music box 1\", midiProgram: 10, generalMidi: true, settings: { \"type\": \"Picked String\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4756.83, \"linearGain\": 0.5 }], \"effects\": [\"reverb\"], \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 48, \"chord\": \"strum\", \"harmonics\": [100, 0, 0, 100, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 86, 0, 0, 0, 0, 0, 0, 71, 0], \"unison\": \"none\", \"stringSustain\": 64, \"envelopes\": [] } },\r\n                { name: \"music box 2\", midiProgram: 10, settings: { \"type\": \"Picked String\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 2828.43, \"linearGain\": 0.7071 }], \"effects\": [\"reverb\"], \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 48, \"chord\": \"strum\", \"harmonics\": [100, 57, 57, 0, 0, 0, 0, 0, 0, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 0, 0, 0, 0, 0, 0, 0, 0], \"unison\": \"none\", \"stringSustain\": 29, \"envelopes\": [] } },\r\n                { name: \"vibraphone\", midiProgram: 11, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 2828, \"filterResonance\": 14, \"filterEnvelope\": \"twang 2\", \"vibrato\": \"none\", \"algorithm\": \"1 2 3 4\", \"feedbackType\": \"1→2→3→4\", \"feedbackAmplitude\": 3, \"feedbackEnvelope\": \"twang 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 9, \"envelope\": \"custom\" }, { \"frequency\": \"~1×\", \"amplitude\": 9, \"envelope\": \"custom\" }, { \"frequency\": \"9×\", \"amplitude\": 3, \"envelope\": \"custom\" }, { \"frequency\": \"4×\", \"amplitude\": 9, \"envelope\": \"custom\" }] } },\r\n                { name: \"marimba\", midiProgram: 12, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 2000, \"filterResonance\": 29, \"filterEnvelope\": \"decay 1\", \"vibrato\": \"none\", \"algorithm\": \"1 2←(3 4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 0, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 10, \"envelope\": \"custom\" }, { \"frequency\": \"4×\", \"amplitude\": 6, \"envelope\": \"custom\" }, { \"frequency\": \"13×\", \"amplitude\": 6, \"envelope\": \"twang 1\" }, { \"frequency\": \"1×\", \"amplitude\": 0, \"envelope\": \"steady\" }] } },\r\n                { name: \"kalimba\", midiProgram: 108, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 2828, \"filterResonance\": 14, \"filterEnvelope\": \"decay 1\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 0, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 11, \"envelope\": \"custom\" }, { \"frequency\": \"5×\", \"amplitude\": 3, \"envelope\": \"twang 2\" }, { \"frequency\": \"20×\", \"amplitude\": 3, \"envelope\": \"twang 1\" }, { \"frequency\": \"1×\", \"amplitude\": 0, \"envelope\": \"steady\" }] } },\r\n                { name: \"xylophone\", midiProgram: 13, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard\", \"chord\": \"strum\", \"filterCutoffHz\": 2000, \"filterResonance\": 14, \"filterEnvelope\": \"twang 1\", \"vibrato\": \"none\", \"algorithm\": \"(1 2 3)←4\", \"feedbackType\": \"1⟲ 2⟲ 3⟲\", \"feedbackAmplitude\": 0, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 9, \"envelope\": \"custom\" }, { \"frequency\": \"6×\", \"amplitude\": 9, \"envelope\": \"custom\" }, { \"frequency\": \"11×\", \"amplitude\": 9, \"envelope\": \"custom\" }, { \"frequency\": \"20×\", \"amplitude\": 6, \"envelope\": \"twang 1\" }] } },\r\n                { name: \"tubular bell\", midiProgram: 14, generalMidi: true, midiSubharmonicOctaves: 1, settings: { \"type\": \"Picked String\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4000, \"linearGain\": 0.5 }, { \"type\": \"high-pass\", \"cutoffHz\": 105.11, \"linearGain\": 0.3536 }], \"effects\": [\"reverb\"], \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 96, \"chord\": \"strum\", \"harmonics\": [43, 71, 0, 100, 0, 100, 0, 86, 0, 0, 86, 0, 14, 71, 14, 14, 57, 14, 14, 43, 14, 14, 43, 14, 14, 43, 14, 14], \"unison\": \"shimmer\", \"stringSustain\": 86, \"envelopes\": [] } },\r\n                { name: \"bell synth\", midiProgram: 14, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 2000, \"filterResonance\": 29, \"filterEnvelope\": \"twang 3\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 0, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"~2×\", \"amplitude\": 10, \"envelope\": \"custom\" }, { \"frequency\": \"7×\", \"amplitude\": 6, \"envelope\": \"twang 3\" }, { \"frequency\": \"20×\", \"amplitude\": 1, \"envelope\": \"twang 1\" }, { \"frequency\": \"1×\", \"amplitude\": 0, \"envelope\": \"steady\" }] } },\r\n                { name: \"rain drop\", midiProgram: 96, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 4000, \"filterResonance\": 14, \"filterEnvelope\": \"twang 1\", \"vibrato\": \"none\", \"algorithm\": \"(1 2)←(3 4)\", \"feedbackType\": \"1⟲ 2⟲\", \"feedbackAmplitude\": 0, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 12, \"envelope\": \"custom\" }, { \"frequency\": \"6×\", \"amplitude\": 4, \"envelope\": \"custom\" }, { \"frequency\": \"20×\", \"amplitude\": 3, \"envelope\": \"twang 1\" }, { \"frequency\": \"1×\", \"amplitude\": 6, \"envelope\": \"tremolo1\" }] } },\r\n                { name: \"crystal\", midiProgram: 98, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 2828, \"filterResonance\": 14, \"filterEnvelope\": \"twang 2\", \"vibrato\": \"delayed\", \"algorithm\": \"1 2 3 4\", \"feedbackType\": \"1⟲ 2⟲ 3⟲ 4⟲\", \"feedbackAmplitude\": 4, \"feedbackEnvelope\": \"twang 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 10, \"envelope\": \"custom\" }, { \"frequency\": \"3×\", \"amplitude\": 7, \"envelope\": \"custom\" }, { \"frequency\": \"6×\", \"amplitude\": 4, \"envelope\": \"custom\" }, { \"frequency\": \"13×\", \"amplitude\": 4, \"envelope\": \"custom\" }] } },\r\n                { name: \"tinkle bell\", midiProgram: 112, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard\", \"chord\": \"strum\", \"filterCutoffHz\": 2828, \"filterResonance\": 14, \"filterEnvelope\": \"twang 2\", \"vibrato\": \"none\", \"algorithm\": \"1 2 3 4\", \"feedbackType\": \"1→2→3→4\", \"feedbackAmplitude\": 5, \"feedbackEnvelope\": \"twang 3\", \"operators\": [{ \"frequency\": \"~2×\", \"amplitude\": 7, \"envelope\": \"custom\" }, { \"frequency\": \"5×\", \"amplitude\": 7, \"envelope\": \"custom\" }, { \"frequency\": \"7×\", \"amplitude\": 7, \"envelope\": \"custom\" }, { \"frequency\": \"16×\", \"amplitude\": 7, \"envelope\": \"custom\" }] } },\r\n                { name: \"agogo\", midiProgram: 113, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 4000, \"filterResonance\": 14, \"filterEnvelope\": \"decay 1\", \"vibrato\": \"none\", \"algorithm\": \"1 2 3 4\", \"feedbackType\": \"1→4\", \"feedbackAmplitude\": 15, \"feedbackEnvelope\": \"decay 1\", \"operators\": [{ \"frequency\": \"2×\", \"amplitude\": 9, \"envelope\": \"custom\" }, { \"frequency\": \"5×\", \"amplitude\": 6, \"envelope\": \"custom\" }, { \"frequency\": \"8×\", \"amplitude\": 9, \"envelope\": \"custom\" }, { \"frequency\": \"13×\", \"amplitude\": 11, \"envelope\": \"custom\" }] } },\r\n            ])\r\n        },\r\n        {\r\n            name: \"Guitar Presets\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"nylon guitar\", midiProgram: 24, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 5657, \"filterResonance\": 14, \"filterEnvelope\": \"twang 1\", \"vibrato\": \"none\", \"algorithm\": \"1←2←3←4\", \"feedbackType\": \"3⟲\", \"feedbackAmplitude\": 6, \"feedbackEnvelope\": \"twang 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 6, \"envelope\": \"steady\" }, { \"frequency\": \"5×\", \"amplitude\": 2, \"envelope\": \"steady\" }, { \"frequency\": \"7×\", \"amplitude\": 4, \"envelope\": \"steady\" }] } },\r\n                { name: \"steel guitar\", midiProgram: 25, generalMidi: true, settings: { \"type\": \"Picked String\", \"eqFilter\": [], \"effects\": [\"reverb\"], \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 48, \"chord\": \"strum\", \"harmonics\": [100, 100, 86, 71, 71, 71, 86, 86, 71, 57, 43, 43, 43, 57, 57, 57, 57, 57, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43], \"unison\": \"none\", \"stringSustain\": 71, \"envelopes\": [] } },\r\n                { name: \"jazz guitar\", midiProgram: 26, generalMidi: true, settings: { \"type\": \"harmonics\", \"effects\": \"reverb\", \"transition\": \"hard\", \"chord\": \"strum\", \"filterCutoffHz\": 2000, \"filterResonance\": 14, \"filterEnvelope\": \"twang 2\", \"interval\": \"union\", \"vibrato\": \"none\", \"harmonics\": [100, 100, 86, 71, 57, 71, 71, 43, 57, 71, 57, 43, 29, 29, 29, 29, 29, 29, 29, 29, 14, 14, 14, 14, 14, 14, 14, 0] } },\r\n                { name: \"clean guitar\", midiProgram: 27, generalMidi: true, settings: { \"type\": \"harmonics\", \"effects\": \"reverb\", \"transition\": \"hard\", \"chord\": \"strum\", \"filterCutoffHz\": 2828, \"filterResonance\": 14, \"filterEnvelope\": \"twang 2\", \"interval\": \"union\", \"vibrato\": \"none\", \"harmonics\": [86, 100, 100, 100, 86, 57, 86, 100, 100, 100, 71, 57, 43, 71, 86, 71, 57, 57, 71, 71, 71, 71, 57, 57, 57, 57, 57, 43] } },\r\n                { name: \"muted guitar\", midiProgram: 28, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard\", \"chord\": \"strum\", \"filterCutoffHz\": 2000, \"filterResonance\": 14, \"filterEnvelope\": \"twang 1\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 7, \"feedbackEnvelope\": \"twang 2\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 13, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 4, \"envelope\": \"twang 3\" }, { \"frequency\": \"4×\", \"amplitude\": 4, \"envelope\": \"twang 2\" }, { \"frequency\": \"16×\", \"amplitude\": 4, \"envelope\": \"twang 1\" }] } },\r\n            ])\r\n        },\r\n        {\r\n            name: \"Picked Bass Presets\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"acoustic bass\", midiProgram: 32, generalMidi: true, settings: { \"type\": \"harmonics\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 4000, \"filterResonance\": 14, \"filterEnvelope\": \"twang 1\", \"interval\": \"union\", \"vibrato\": \"none\", \"harmonics\": [100, 86, 71, 71, 71, 71, 57, 57, 57, 57, 43, 43, 43, 43, 43, 29, 29, 29, 29, 29, 29, 14, 14, 14, 14, 14, 14, 14] } },\r\n                { name: \"fingered bass\", midiProgram: 33, generalMidi: true, settings: { \"type\": \"harmonics\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 2828, \"filterResonance\": 14, \"filterEnvelope\": \"twang 1\", \"interval\": \"union\", \"vibrato\": \"none\", \"harmonics\": [100, 86, 71, 57, 71, 43, 57, 29, 29, 29, 29, 29, 29, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 0] } },\r\n                { name: \"picked bass\", midiProgram: 34, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 2828, \"filterResonance\": 0, \"filterEnvelope\": \"twang 1\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"3⟲\", \"feedbackAmplitude\": 4, \"feedbackEnvelope\": \"twang 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 5, \"envelope\": \"steady\" }, { \"frequency\": \"11×\", \"amplitude\": 1, \"envelope\": \"twang 3\" }, { \"frequency\": \"1×\", \"amplitude\": 9, \"envelope\": \"steady\" }] } },\r\n                { name: \"fretless bass\", midiProgram: 35, generalMidi: true, settings: { \"type\": \"harmonics\", \"effects\": \"reverb\", \"transition\": \"hard\", \"chord\": \"strum\", \"filterCutoffHz\": 1000, \"filterResonance\": 14, \"filterEnvelope\": \"flare 2\", \"interval\": \"union\", \"vibrato\": \"none\", \"harmonics\": [100, 100, 86, 71, 71, 57, 57, 71, 71, 71, 57, 57, 57, 57, 57, 57, 57, 43, 43, 43, 43, 43, 43, 43, 43, 29, 29, 14] } },\r\n                { name: \"slap bass 1\", midiProgram: 36, generalMidi: true, settings: { \"type\": \"harmonics\", \"effects\": \"reverb\", \"transition\": \"hard\", \"chord\": \"strum\", \"filterCutoffHz\": 4000, \"filterResonance\": 0, \"filterEnvelope\": \"twang 1\", \"interval\": \"union\", \"vibrato\": \"none\", \"harmonics\": [100, 100, 100, 100, 86, 71, 57, 29, 29, 43, 43, 57, 71, 57, 29, 29, 43, 57, 57, 57, 43, 43, 43, 57, 71, 71, 71, 71] } },\r\n                { name: \"slap bass 2\", midiProgram: 37, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard\", \"chord\": \"strum\", \"filterCutoffHz\": 5657, \"filterResonance\": 0, \"filterEnvelope\": \"twang 1\", \"vibrato\": \"none\", \"algorithm\": \"1←2←3←4\", \"feedbackType\": \"3⟲\", \"feedbackAmplitude\": 4, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"3×\", \"amplitude\": 13, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 7, \"envelope\": \"steady\" }, { \"frequency\": \"13×\", \"amplitude\": 3, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 11, \"envelope\": \"steady\" }] } },\r\n                { name: \"bass synth 1\", midiProgram: 38, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard\", \"chord\": \"strum\", \"filterCutoffHz\": 4000, \"filterResonance\": 43, \"filterEnvelope\": \"twang 2\", \"vibrato\": \"none\", \"algorithm\": \"1←3 2←4\", \"feedbackType\": \"3⟲ 4⟲\", \"feedbackAmplitude\": 9, \"feedbackEnvelope\": \"twang 2\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 10, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 14, \"envelope\": \"twang 1\" }, { \"frequency\": \"~1×\", \"amplitude\": 13, \"envelope\": \"twang 2\" }] } },\r\n                { name: \"bass synth 2\", midiProgram: 39, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 1000, \"filterResonance\": 57, \"filterEnvelope\": \"punch\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"1→2\", \"feedbackAmplitude\": 4, \"feedbackEnvelope\": \"twang 3\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 9, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 9, \"envelope\": \"steady\" }, { \"frequency\": \"3×\", \"amplitude\": 0, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 0, \"envelope\": \"steady\" }] } },\r\n                { name: \"bass & lead\", midiProgram: 87, generalMidi: true, settings: { \"type\": \"chip\", \"transition\": \"hard\", \"effects\": \"reverb\", \"chord\": \"harmony\", \"filterCutoffHz\": 4000, \"filterResonance\": 86, \"filterEnvelope\": \"twang 2\", \"wave\": \"sawtooth\", \"interval\": \"shimmer\", \"vibrato\": \"none\" } },\r\n                { name: \"dubstep yoi yoi\", midiProgram: 87, settings: { \"type\": \"chip\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 6727.17, \"linearGain\": 0.7071 }], \"effects\": [\"note filter\", \"bitcrusher\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 594.6, \"linearGain\": 11.3137 }], \"bitcrusherOctave\": 1.5, \"bitcrusherQuantization\": 0, \"transition\": \"slide\", \"fadeInSeconds\": 0.0263, \"fadeOutTicks\": -3, \"chord\": \"arpeggio\", \"wave\": \"sawtooth\", \"unison\": \"none\", \"envelopes\": [{ \"target\": \"noteFilterFreq\", \"envelope\": \"flare 2\", \"index\": 0 }] } },\r\n            ])\r\n        },\r\n        {\r\n            name: \"Picked String Presets\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"pizzicato strings\", midiProgram: 45, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"medium fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 1000, \"filterResonance\": 14, \"filterEnvelope\": \"twang 1\", \"vibrato\": \"none\", \"algorithm\": \"(1 2 3)←4\", \"feedbackType\": \"1⟲ 2⟲ 3⟲ 4⟲\", \"feedbackAmplitude\": 7, \"feedbackEnvelope\": \"twang 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 14, \"envelope\": \"custom\" }, { \"frequency\": \"3×\", \"amplitude\": 11, \"envelope\": \"custom\" }, { \"frequency\": \"6×\", \"amplitude\": 9, \"envelope\": \"custom\" }, { \"frequency\": \"~1×\", \"amplitude\": 10, \"envelope\": \"steady\" }] } },\r\n                { name: \"harp\", midiProgram: 46, generalMidi: true, settings: { \"type\": \"FM\", \"transition\": \"hard fade\", \"effects\": \"reverb\", \"chord\": \"strum\", \"filterCutoffHz\": 2828, \"filterResonance\": 0, \"filterEnvelope\": \"twang 1\", \"vibrato\": \"none\", \"algorithm\": \"1←3 2←4\", \"feedbackType\": \"3⟲\", \"feedbackAmplitude\": 6, \"feedbackEnvelope\": \"twang 2\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15, \"envelope\": \"custom\" }, { \"frequency\": \"4×\", \"amplitude\": 6, \"envelope\": \"custom\" }, { \"frequency\": \"~2×\", \"amplitude\": 3, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 6, \"envelope\": \"steady\" }] } },\r\n                { name: \"sitar\", midiProgram: 104, generalMidi: true, settings: { \"type\": \"FM\", \"transition\": \"hard fade\", \"effects\": \"reverb\", \"chord\": \"strum\", \"filterCutoffHz\": 8000, \"filterResonance\": 57, \"filterEnvelope\": \"twang 2\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 0, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 14, \"envelope\": \"twang 3\" }, { \"frequency\": \"9×\", \"amplitude\": 3, \"envelope\": \"twang 3\" }, { \"frequency\": \"16×\", \"amplitude\": 9, \"envelope\": \"swell 3\" }] } },\r\n                { name: \"banjo\", midiProgram: 105, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 2828, \"filterResonance\": 14, \"filterEnvelope\": \"twang 2\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"2⟲\", \"feedbackAmplitude\": 4, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"4×\", \"amplitude\": 14, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 10, \"envelope\": \"steady\" }, { \"frequency\": \"11×\", \"amplitude\": 3, \"envelope\": \"twang 3\" }, { \"frequency\": \"1×\", \"amplitude\": 11, \"envelope\": \"steady\" }] } },\r\n                { name: \"ukulele\", midiProgram: 105, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 2000, \"filterResonance\": 0, \"filterEnvelope\": \"twang 1\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"3⟲\", \"feedbackAmplitude\": 5, \"feedbackEnvelope\": \"twang 1\", \"operators\": [{ \"frequency\": \"2×\", \"amplitude\": 14, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 6, \"envelope\": \"steady\" }, { \"frequency\": \"9×\", \"amplitude\": 4, \"envelope\": \"twang 2\" }, { \"frequency\": \"1×\", \"amplitude\": 11, \"envelope\": \"steady\" }] } },\r\n                { name: \"shamisen\", midiProgram: 106, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 8000, \"filterResonance\": 14, \"filterEnvelope\": \"twang 1\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"3⟲\", \"feedbackAmplitude\": 9, \"feedbackEnvelope\": \"twang 3\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 12, \"envelope\": \"steady\" }, { \"frequency\": \"16×\", \"amplitude\": 4, \"envelope\": \"twang 3\" }, { \"frequency\": \"1×\", \"amplitude\": 7, \"envelope\": \"steady\" }] } },\r\n                { name: \"koto\", midiProgram: 107, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 4000, \"filterResonance\": 14, \"filterEnvelope\": \"twang 2\", \"vibrato\": \"none\", \"algorithm\": \"1←3 2←4\", \"feedbackType\": \"1⟲ 2⟲\", \"feedbackAmplitude\": 5, \"feedbackEnvelope\": \"twang 2\", \"operators\": [{ \"frequency\": \"~1×\", \"amplitude\": 12, \"envelope\": \"custom\" }, { \"frequency\": \"6×\", \"amplitude\": 10, \"envelope\": \"custom\" }, { \"frequency\": \"4×\", \"amplitude\": 8, \"envelope\": \"twang 3\" }, { \"frequency\": \"~2×\", \"amplitude\": 8, \"envelope\": \"twang 3\" }] } },\r\n            ])\r\n        },\r\n        {\r\n            name: \"Distortion Presets\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"overdrive guitar\", midiProgram: 29, generalMidi: true, settings: { \"type\": \"Picked String\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4756.83, \"linearGain\": 0.7071 }, { \"type\": \"high-pass\", \"cutoffHz\": 210.22, \"linearGain\": 1 }, { \"type\": \"low-pass\", \"cutoffHz\": 5656.85, \"linearGain\": 1 }, { \"type\": \"peak\", \"cutoffHz\": 840.9, \"linearGain\": 0.5 }], \"effects\": [\"note filter\", \"distortion\"], \"noteFilter\": [{ \"type\": \"high-pass\", \"cutoffHz\": 297.3, \"linearGain\": 2 }, { \"type\": \"low-pass\", \"cutoffHz\": 2378.41, \"linearGain\": 0.7071 }], \"distortion\": 71, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 12, \"chord\": \"strum\", \"harmonics\": [86, 100, 100, 86, 86, 86, 86, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57], \"unison\": \"none\", \"stringSustain\": 71, \"envelopes\": [{ \"target\": \"noteFilterFreq\", \"envelope\": \"note size\", \"index\": 1 }] } },\r\n                { name: \"distortion guitar\", midiProgram: 30, generalMidi: true, settings: { \"type\": \"Picked String\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4756.83, \"linearGain\": 0.7071 }, { \"type\": \"high-pass\", \"cutoffHz\": 210.22, \"linearGain\": 1 }, { \"type\": \"low-pass\", \"cutoffHz\": 5656.85, \"linearGain\": 1 }, { \"type\": \"peak\", \"cutoffHz\": 594.6, \"linearGain\": 0.3536 }, { \"type\": \"peak\", \"cutoffHz\": 1000, \"linearGain\": 0.25 }], \"effects\": [\"note filter\", \"distortion\", \"reverb\"], \"noteFilter\": [{ \"type\": \"high-pass\", \"cutoffHz\": 353.55, \"linearGain\": 2 }, { \"type\": \"low-pass\", \"cutoffHz\": 2000, \"linearGain\": 1 }], \"distortion\": 86, \"reverb\": 67, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 12, \"chord\": \"strum\", \"harmonics\": [86, 100, 100, 86, 86, 86, 86, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57], \"unison\": \"none\", \"stringSustain\": 71, \"envelopes\": [{ \"target\": \"noteFilterFreq\", \"envelope\": \"note size\", \"index\": 1 }] } },\r\n                { name: \"charango synth\", midiProgram: 84, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 11313.71, \"linearGain\": 1 }], \"effects\": [], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"strum\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"1→2→3→4\", \"feedbackAmplitude\": 8, \"operators\": [{ \"frequency\": \"3×\", \"amplitude\": 13 }, { \"frequency\": \"~1×\", \"amplitude\": 5 }, { \"frequency\": \"4×\", \"amplitude\": 6 }, { \"frequency\": \"3×\", \"amplitude\": 7 }], \"envelopes\": [{ \"target\": \"feedbackAmplitude\", \"envelope\": \"twang 3\" }] } },\r\n                { name: \"guitar harmonics\", midiProgram: 31, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4000, \"linearGain\": 2 }], \"effects\": [\"reverb\"], \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"strum\", \"algorithm\": \"1←(2 3)←4\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 2, \"operators\": [{ \"frequency\": \"4×\", \"amplitude\": 12 }, { \"frequency\": \"16×\", \"amplitude\": 5 }, { \"frequency\": \"1×\", \"amplitude\": 2 }, { \"frequency\": \"~1×\", \"amplitude\": 12 }], \"envelopes\": [{ \"target\": \"operatorAmplitude\", \"envelope\": \"swell 1\", \"index\": 1 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"punch\", \"index\": 2 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"twang 1\", \"index\": 3 }] } },\r\n                { name: \"PWM overdrive\", midiProgram: 29, settings: { \"type\": \"PWM\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 5656.85, \"linearGain\": 1.4142 }], \"effects\": [], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"strum\", \"pulseWidth\": 17.67767, \"envelopes\": [{ \"target\": \"pulseWidth\", \"envelope\": \"punch\" }] } },\r\n                { name: \"PWM distortion\", midiProgram: 30, settings: { \"type\": \"PWM\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 3363.59, \"linearGain\": 2 }], \"effects\": [\"vibrato\"], \"vibrato\": \"delayed\", \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"strum\", \"pulseWidth\": 50, \"envelopes\": [{ \"target\": \"pulseWidth\", \"envelope\": \"swell 1\" }] } },\r\n                { name: \"FM overdrive\", midiProgram: 29, settings: { \"type\": \"FM\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4756.83, \"linearGain\": 1 }], \"effects\": [\"reverb\"], \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"strum\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"1→2\", \"feedbackAmplitude\": 2, \"operators\": [{ \"frequency\": \"~1×\", \"amplitude\": 15 }, { \"frequency\": \"1×\", \"amplitude\": 12 }, { \"frequency\": \"~2×\", \"amplitude\": 6 }, { \"frequency\": \"1×\", \"amplitude\": 12 }], \"envelopes\": [{ \"target\": \"operatorAmplitude\", \"envelope\": \"twang 1\", \"index\": 2 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"swell 3\", \"index\": 3 }, { \"target\": \"feedbackAmplitude\", \"envelope\": \"punch\" }] } },\r\n                { name: \"FM distortion\", midiProgram: 30, settings: { \"type\": \"FM\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4000, \"linearGain\": 2 }], \"effects\": [\"reverb\"], \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"strum\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"1→2\", \"feedbackAmplitude\": 4, \"operators\": [{ \"frequency\": \"~1×\", \"amplitude\": 15 }, { \"frequency\": \"1×\", \"amplitude\": 11 }, { \"frequency\": \"1×\", \"amplitude\": 9 }, { \"frequency\": \"~2×\", \"amplitude\": 4 }], \"envelopes\": [{ \"target\": \"operatorAmplitude\", \"envelope\": \"swell 1\", \"index\": 2 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"swell 3\", \"index\": 3 }] } },\r\n            ])\r\n        },\r\n        {\r\n            name: \"Bellows Presets\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"drawbar organ 1\", midiProgram: 16, generalMidi: true, midiSubharmonicOctaves: 1, settings: { \"type\": \"harmonics\", \"effects\": \"reverb\", \"transition\": \"hard\", \"chord\": \"harmony\", \"filterCutoffHz\": 2828, \"filterResonance\": 14, \"filterEnvelope\": \"steady\", \"interval\": \"union\", \"vibrato\": \"none\", \"harmonics\": [86, 86, 0, 86, 0, 0, 0, 86, 0, 0, 0, 0, 0, 0, 0, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } },\r\n                { name: \"drawbar organ 2\", midiProgram: 16, midiSubharmonicOctaves: 1, settings: { \"type\": \"harmonics\", \"effects\": \"reverb\", \"transition\": \"hard\", \"chord\": \"harmony\", \"filterCutoffHz\": 2828, \"filterResonance\": 14, \"filterEnvelope\": \"steady\", \"interval\": \"union\", \"vibrato\": \"none\", \"harmonics\": [86, 29, 71, 86, 71, 14, 0, 100, 0, 0, 0, 86, 0, 0, 0, 71, 0, 0, 0, 57, 0, 0, 0, 29, 0, 0, 0, 0] } },\r\n                { name: \"percussive organ\", midiProgram: 17, generalMidi: true, midiSubharmonicOctaves: 1, settings: { \"type\": \"FM\", \"transition\": \"hard\", \"effects\": \"reverb\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 14, \"filterEnvelope\": \"punch\", \"vibrato\": \"light\", \"algorithm\": \"1 2 3 4\", \"feedbackType\": \"1→3 2→4\", \"feedbackAmplitude\": 7, \"feedbackEnvelope\": \"decay 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 7, \"envelope\": \"custom\" }, { \"frequency\": \"2×\", \"amplitude\": 7, \"envelope\": \"custom\" }, { \"frequency\": \"3×\", \"amplitude\": 8, \"envelope\": \"custom\" }, { \"frequency\": \"4×\", \"amplitude\": 8, \"envelope\": \"custom\" }] } },\r\n                { name: \"rock organ\", midiProgram: 18, generalMidi: true, midiSubharmonicOctaves: 1, settings: { \"type\": \"FM\", \"effects\": \"chorus & reverb\", \"transition\": \"hard\", \"chord\": \"harmony\", \"filterCutoffHz\": 4000, \"filterResonance\": 14, \"filterEnvelope\": \"punch\", \"vibrato\": \"delayed\", \"algorithm\": \"(1 2 3)←4\", \"feedbackType\": \"1⟲ 2⟲ 3⟲\", \"feedbackAmplitude\": 2, \"feedbackEnvelope\": \"flare 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 9, \"envelope\": \"custom\" }, { \"frequency\": \"4×\", \"amplitude\": 9, \"envelope\": \"custom\" }, { \"frequency\": \"6×\", \"amplitude\": 9, \"envelope\": \"custom\" }, { \"frequency\": \"2×\", \"amplitude\": 5, \"envelope\": \"steady\" }] } },\r\n                { name: \"pipe organ\", midiProgram: 19, generalMidi: true, midiSubharmonicOctaves: 1, settings: { \"type\": \"FM\", \"transition\": \"cross fade\", \"effects\": \"reverb\", \"chord\": \"harmony\", \"filterCutoffHz\": 5657, \"filterResonance\": 43, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"1 2 3 4\", \"feedbackType\": \"1⟲ 2⟲ 3⟲ 4⟲\", \"feedbackAmplitude\": 5, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 8, \"envelope\": \"custom\" }, { \"frequency\": \"2×\", \"amplitude\": 9, \"envelope\": \"custom\" }, { \"frequency\": \"4×\", \"amplitude\": 9, \"envelope\": \"custom\" }, { \"frequency\": \"8×\", \"amplitude\": 8, \"envelope\": \"custom\" }] } },\r\n                { name: \"reed organ\", midiProgram: 20, generalMidi: true, settings: { \"type\": \"harmonics\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 29, \"filterEnvelope\": \"steady\", \"interval\": \"union\", \"vibrato\": \"none\", \"harmonics\": [71, 86, 100, 86, 71, 100, 57, 71, 71, 71, 43, 43, 43, 71, 43, 71, 57, 57, 57, 57, 57, 57, 57, 29, 43, 29, 29, 14] } },\r\n                { name: \"accordion\", midiProgram: 21, generalMidi: true, settings: { \"type\": \"chip\", \"effects\": \"reverb\", \"transition\": \"cross fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 5657, \"filterResonance\": 0, \"filterEnvelope\": \"swell 1\", \"wave\": \"double saw\", \"interval\": \"honky tonk\", \"vibrato\": \"none\" } },\r\n                { name: \"bandoneon\", midiProgram: 23, generalMidi: true, settings: { \"type\": \"harmonics\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 4000, \"filterResonance\": 29, \"filterEnvelope\": \"swell 1\", \"interval\": \"hum\", \"vibrato\": \"none\", \"harmonics\": [86, 86, 86, 57, 71, 86, 57, 71, 71, 71, 57, 43, 57, 43, 71, 43, 71, 57, 57, 43, 43, 43, 57, 43, 43, 29, 29, 29] } },\r\n                { name: \"bagpipe\", midiProgram: 109, generalMidi: true, settings: { \"type\": \"harmonics\", \"effects\": \"reverb\", \"transition\": \"cross fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 5657, \"filterResonance\": 43, \"filterEnvelope\": \"punch\", \"interval\": \"hum\", \"vibrato\": \"none\", \"harmonics\": [71, 86, 86, 100, 100, 86, 57, 100, 86, 71, 71, 71, 57, 57, 57, 71, 57, 71, 57, 71, 43, 57, 57, 43, 43, 43, 43, 43] } },\r\n            ])\r\n        },\r\n        {\r\n            name: \"String Presets\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"violin 1\", midiProgram: 40, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4000, \"linearGain\": 1.4142 }, { \"type\": \"high-pass\", \"cutoffHz\": 105.11, \"linearGain\": 0.3536 }], \"effects\": [\"vibrato\", \"reverb\"], \"vibrato\": \"delayed\", \"reverb\": 67, \"transition\": \"normal\", \"fadeInSeconds\": 0.0413, \"fadeOutTicks\": 6, \"chord\": \"simultaneous\", \"algorithm\": \"(1 2)←(3 4)\", \"feedbackType\": \"1→2\", \"feedbackAmplitude\": 5, \"operators\": [{ \"frequency\": \"4×\", \"amplitude\": 9 }, { \"frequency\": \"3×\", \"amplitude\": 9 }, { \"frequency\": \"2×\", \"amplitude\": 7 }, { \"frequency\": \"7×\", \"amplitude\": 5 }], \"envelopes\": [{ \"target\": \"operatorAmplitude\", \"envelope\": \"swell 1\", \"index\": 3 }, { \"target\": \"feedbackAmplitude\", \"envelope\": \"twang 3\" }] } },\r\n                { name: \"viola\", midiProgram: 41, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"cross fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 29, \"filterEnvelope\": \"steady\", \"vibrato\": \"delayed\", \"algorithm\": \"(1 2 3)←4\", \"feedbackType\": \"1⟲ 2⟲ 3⟲\", \"feedbackAmplitude\": 8, \"feedbackEnvelope\": \"swell 1\", \"operators\": [{ \"frequency\": \"2×\", \"amplitude\": 11, \"envelope\": \"custom\" }, { \"frequency\": \"7×\", \"amplitude\": 7, \"envelope\": \"custom\" }, { \"frequency\": \"13×\", \"amplitude\": 4, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 5, \"envelope\": \"steady\" }] } },\r\n                { name: \"cello\", midiProgram: 42, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4000, \"linearGain\": 0.1768 }, { \"type\": \"high-pass\", \"cutoffHz\": 297.3, \"linearGain\": 0.7071 }, { \"type\": \"peak\", \"cutoffHz\": 4756.83, \"linearGain\": 5.6569 }], \"effects\": [\"note filter\", \"reverb\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 16000, \"linearGain\": 0.0884 }], \"reverb\": 67, \"transition\": \"normal\", \"fadeInSeconds\": 0.0125, \"fadeOutTicks\": 12, \"chord\": \"simultaneous\", \"algorithm\": \"(1 2)←3←4\", \"feedbackType\": \"1⟲ 2⟲\", \"feedbackAmplitude\": 3, \"operators\": [{ \"frequency\": \"16×\", \"amplitude\": 5 }, { \"frequency\": \"~1×\", \"amplitude\": 10 }, { \"frequency\": \"1×\", \"amplitude\": 9 }, { \"frequency\": \"6×\", \"amplitude\": 3 }], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"swell 1\" }, { \"target\": \"operatorAmplitude\", \"envelope\": \"swell 1\", \"index\": 3 }] } },\r\n                { name: \"contrabass\", midiProgram: 43, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"cross fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 29, \"filterEnvelope\": \"steady\", \"vibrato\": \"delayed\", \"algorithm\": \"(1 2)←3←4\", \"feedbackType\": \"1⟲ 2⟲\", \"feedbackAmplitude\": 0, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"16×\", \"amplitude\": 5, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 10, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 10, \"envelope\": \"steady\" }, { \"frequency\": \"6×\", \"amplitude\": 3, \"envelope\": \"swell 1\" }] } },\r\n                { name: \"fiddle\", midiProgram: 110, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 2828, \"filterResonance\": 29, \"filterEnvelope\": \"steady\", \"vibrato\": \"delayed\", \"algorithm\": \"(1 2)←(3 4)\", \"feedbackType\": \"3⟲ 4⟲\", \"feedbackAmplitude\": 5, \"feedbackEnvelope\": \"twang 1\", \"operators\": [{ \"frequency\": \"2×\", \"amplitude\": 10, \"envelope\": \"custom\" }, { \"frequency\": \"8×\", \"amplitude\": 8, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 8, \"envelope\": \"steady\" }, { \"frequency\": \"16×\", \"amplitude\": 3, \"envelope\": \"steady\" }] } },\r\n                { name: \"tremolo strings\", midiProgram: 44, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"chorus & reverb\", \"transition\": \"medium fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 0, \"filterEnvelope\": \"tremolo4\", \"vibrato\": \"none\", \"algorithm\": \"1 2 3 4\", \"feedbackType\": \"1→2→3→4\", \"feedbackAmplitude\": 12, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 8, \"envelope\": \"custom\" }, { \"frequency\": \"~2×\", \"amplitude\": 8, \"envelope\": \"custom\" }, { \"frequency\": \"4×\", \"amplitude\": 8, \"envelope\": \"custom\" }, { \"frequency\": \"7×\", \"amplitude\": 8, \"envelope\": \"custom\" }] } },\r\n                { name: \"strings\", midiProgram: 48, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"chorus & reverb\", \"transition\": \"cross fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 2828, \"filterResonance\": 43, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"(1 2)←(3 4)\", \"feedbackType\": \"4⟲\", \"feedbackAmplitude\": 5, \"feedbackEnvelope\": \"twang 3\", \"operators\": [{ \"frequency\": \"4×\", \"amplitude\": 9, \"envelope\": \"custom\" }, { \"frequency\": \"3×\", \"amplitude\": 9, \"envelope\": \"custom\" }, { \"frequency\": \"2×\", \"amplitude\": 7, \"envelope\": \"steady\" }, { \"frequency\": \"7×\", \"amplitude\": 3, \"envelope\": \"swell 1\" }] } },\r\n                { name: \"slow strings\", midiProgram: 49, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"chorus & reverb\", \"transition\": \"soft fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 1414, \"filterResonance\": 0, \"filterEnvelope\": \"swell 2\", \"vibrato\": \"none\", \"algorithm\": \"(1 2)←(3 4)\", \"feedbackType\": \"4⟲\", \"feedbackAmplitude\": 6, \"feedbackEnvelope\": \"flare 3\", \"operators\": [{ \"frequency\": \"4×\", \"amplitude\": 10, \"envelope\": \"custom\" }, { \"frequency\": \"3×\", \"amplitude\": 10, \"envelope\": \"custom\" }, { \"frequency\": \"2×\", \"amplitude\": 7, \"envelope\": \"steady\" }, { \"frequency\": \"7×\", \"amplitude\": 4, \"envelope\": \"swell 1\" }] } },\r\n                { name: \"strings synth 1\", midiProgram: 50, generalMidi: true, settings: { \"type\": \"chip\", \"transition\": \"soft fade\", \"effects\": \"chorus & reverb\", \"chord\": \"harmony\", \"filterCutoffHz\": 1414, \"filterResonance\": 43, \"filterEnvelope\": \"steady\", \"wave\": \"sawtooth\", \"interval\": \"hum\", \"vibrato\": \"delayed\" } },\r\n                { name: \"strings synth 2\", midiProgram: 51, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"chorus & reverb\", \"transition\": \"soft fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 43, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"1 2 3 4\", \"feedbackType\": \"1⟲ 2⟲ 3⟲ 4⟲\", \"feedbackAmplitude\": 12, \"feedbackEnvelope\": \"swell 1\", \"operators\": [{ \"frequency\": \"3×\", \"amplitude\": 6, \"envelope\": \"custom\" }, { \"frequency\": \"2×\", \"amplitude\": 7, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 8, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 9, \"envelope\": \"custom\" }] } },\r\n                { name: \"orchestra hit 1\", midiProgram: 55, generalMidi: true, midiSubharmonicOctaves: 1, settings: { \"type\": \"FM\", \"effects\": \"chorus & reverb\", \"transition\": \"hard fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 8000, \"filterResonance\": 14, \"filterEnvelope\": \"custom\", \"vibrato\": \"none\", \"algorithm\": \"1 2 3 4\", \"feedbackType\": \"1⟲ 2⟲ 3⟲ 4⟲\", \"feedbackAmplitude\": 14, \"feedbackEnvelope\": \"twang 3\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15, \"envelope\": \"twang 3\" }, { \"frequency\": \"2×\", \"amplitude\": 15, \"envelope\": \"flare 3\" }, { \"frequency\": \"4×\", \"amplitude\": 15, \"envelope\": \"flare 2\" }, { \"frequency\": \"8×\", \"amplitude\": 15, \"envelope\": \"flare 1\" }] } },\r\n                { name: \"violin 2\", midiProgram: 40, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 2828, \"linearGain\": 1.4142 }, { \"type\": \"high-pass\", \"cutoffHz\": 105.11, \"linearGain\": 0.3536 }], \"effects\": [\"vibrato\", \"reverb\"], \"vibrato\": \"light\", \"reverb\": 67, \"transition\": \"normal\", \"fadeInSeconds\": 0.0413, \"fadeOutTicks\": 6, \"chord\": \"simultaneous\", \"algorithm\": \"(1 2)←(3 4)\", \"feedbackType\": \"4⟲\", \"feedbackAmplitude\": 5, \"feedbackEnvelope\": \"twang 3\", \"operators\": [{ \"frequency\": \"4×\", \"amplitude\": 15, \"envelope\": \"custom\" }, { \"frequency\": \"3×\", \"amplitude\": 13, \"envelope\": \"custom\" }, { \"frequency\": \"2×\", \"amplitude\": 7, \"envelope\": \"steady\" }, { \"frequency\": \"7×\", \"amplitude\": 8, \"envelope\": \"swell 1\" }] } },\r\n                { name: \"orchestra hit 2\", midiProgram: 55, midiSubharmonicOctaves: 1, settings: { \"type\": \"FM\", \"effects\": \"chorus & reverb\", \"transition\": \"medium fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 8000, \"filterResonance\": 0, \"filterEnvelope\": \"decay 1\", \"vibrato\": \"delayed\", \"algorithm\": \"1 2 3 4\", \"feedbackType\": \"1⟲ 2⟲ 3⟲ 4⟲\", \"feedbackAmplitude\": 14, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 12, \"envelope\": \"custom\" }, { \"frequency\": \"2×\", \"amplitude\": 14, \"envelope\": \"custom\" }, { \"frequency\": \"3×\", \"amplitude\": 12, \"envelope\": \"custom\" }, { \"frequency\": \"4×\", \"amplitude\": 14, \"envelope\": \"custom\" }] } },\r\n            ])\r\n        },\r\n        {\r\n            name: \"Vocal Presets\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"choir soprano\", midiProgram: 94, generalMidi: true, settings: { \"type\": \"harmonics\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 2828.43, \"linearGain\": 2 }, { \"type\": \"peak\", \"cutoffHz\": 1189.21, \"linearGain\": 5.6569 }, { \"type\": \"high-pass\", \"cutoffHz\": 707.11, \"linearGain\": 2.8284 }, { \"type\": \"peak\", \"cutoffHz\": 2000, \"linearGain\": 0.0884 }, { \"type\": \"peak\", \"cutoffHz\": 840.9, \"linearGain\": 0.25 }, { \"type\": \"low-pass\", \"cutoffHz\": 6727.17, \"linearGain\": 11.3137 }], \"effects\": [\"vibrato\", \"chorus\", \"reverb\"], \"vibrato\": \"shaky\", \"chorus\": 100, \"reverb\": 33, \"fadeInSeconds\": 0.0413, \"fadeOutTicks\": 24, \"harmonics\": [100, 100, 86, 57, 29, 29, 57, 71, 57, 29, 14, 14, 14, 29, 43, 57, 43, 29, 14, 14, 14, 14, 14, 14, 0, 0, 0, 0], \"unison\": \"none\", \"envelopes\": [] } },\r\n                { name: \"choir tenor\", midiProgram: 52, generalMidi: true, settings: { \"type\": \"harmonics\", \"eqFilter\": [{ \"type\": \"peak\", \"cutoffHz\": 1000, \"linearGain\": 11.3137 }, { \"type\": \"peak\", \"cutoffHz\": 707.11, \"linearGain\": 5.6569 }, { \"type\": \"peak\", \"cutoffHz\": 840.9, \"linearGain\": 0.0884 }, { \"type\": \"peak\", \"cutoffHz\": 1681.79, \"linearGain\": 0.0884 }, { \"type\": \"high-pass\", \"cutoffHz\": 297.3, \"linearGain\": 0.7071 }, { \"type\": \"low-pass\", \"cutoffHz\": 2828.43, \"linearGain\": 11.3137 }], \"effects\": [\"vibrato\", \"chorus\", \"reverb\"], \"vibrato\": \"shaky\", \"chorus\": 100, \"reverb\": 67, \"transition\": \"normal\", \"fadeInSeconds\": 0.0413, \"fadeOutTicks\": 48, \"chord\": \"simultaneous\", \"harmonics\": [86, 100, 100, 86, 71, 57, 43, 29, 29, 29, 29, 43, 43, 43, 29, 29, 29, 29, 29, 29, 29, 29, 29, 14, 14, 14, 14, 14], \"unison\": \"none\", \"envelopes\": [] } },\r\n                { name: \"choir bass\", midiProgram: 52, settings: { \"type\": \"harmonics\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 2378.41, \"linearGain\": 11.3137 }, { \"type\": \"peak\", \"cutoffHz\": 594.6, \"linearGain\": 5.6569 }, { \"type\": \"peak\", \"cutoffHz\": 1681.79, \"linearGain\": 0.0884 }, { \"type\": \"peak\", \"cutoffHz\": 707.11, \"linearGain\": 0.0884 }, { \"type\": \"peak\", \"cutoffHz\": 840.9, \"linearGain\": 11.3137 }], \"effects\": [\"vibrato\", \"chorus\", \"reverb\"], \"vibrato\": \"shaky\", \"chorus\": 100, \"reverb\": 67, \"transition\": \"normal\", \"fadeInSeconds\": 0.0413, \"fadeOutTicks\": 48, \"chord\": \"simultaneous\", \"harmonics\": [71, 86, 100, 100, 86, 86, 57, 43, 29, 29, 29, 29, 29, 29, 43, 43, 43, 43, 43, 29, 29, 29, 29, 14, 14, 14, 14, 14], \"unison\": \"none\", \"envelopes\": [] } },\r\n                { name: \"solo soprano\", midiProgram: 85, settings: { \"type\": \"harmonics\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 2828.43, \"linearGain\": 2 }, { \"type\": \"peak\", \"cutoffHz\": 1189.21, \"linearGain\": 5.6569 }, { \"type\": \"high-pass\", \"cutoffHz\": 707.11, \"linearGain\": 2.8284 }, { \"type\": \"peak\", \"cutoffHz\": 2000, \"linearGain\": 0.0884 }, { \"type\": \"peak\", \"cutoffHz\": 840.9, \"linearGain\": 0.25 }], \"effects\": [\"vibrato\", \"reverb\"], \"vibrato\": \"shaky\", \"reverb\": 33, \"fadeInSeconds\": 0.0413, \"fadeOutTicks\": 12, \"harmonics\": [86, 100, 86, 43, 14, 14, 57, 71, 57, 14, 14, 14, 14, 14, 43, 57, 43, 14, 14, 14, 14, 14, 14, 14, 0, 0, 0, 0], \"unison\": \"none\", \"envelopes\": [] } },\r\n                { name: \"solo tenor\", midiProgram: 85, settings: { \"type\": \"harmonics\", \"eqFilter\": [{ \"type\": \"peak\", \"cutoffHz\": 1000, \"linearGain\": 11.3137 }, { \"type\": \"peak\", \"cutoffHz\": 707.11, \"linearGain\": 5.6569 }, { \"type\": \"peak\", \"cutoffHz\": 840.9, \"linearGain\": 0.0884 }, { \"type\": \"peak\", \"cutoffHz\": 1681.79, \"linearGain\": 0.0884 }, { \"type\": \"high-pass\", \"cutoffHz\": 297.3, \"linearGain\": 0.7071 }, { \"type\": \"low-pass\", \"cutoffHz\": 2828.43, \"linearGain\": 11.3137 }], \"effects\": [\"vibrato\", \"reverb\"], \"vibrato\": \"shaky\", \"reverb\": 33, \"fadeInSeconds\": 0.0413, \"fadeOutTicks\": 12, \"harmonics\": [86, 100, 100, 86, 71, 57, 43, 29, 29, 29, 29, 43, 43, 43, 29, 29, 29, 29, 29, 29, 29, 29, 29, 14, 14, 14, 14, 14], \"unison\": \"none\", \"envelopes\": [] } },\r\n                { name: \"solo bass\", midiProgram: 85, settings: { \"type\": \"harmonics\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 2378.41, \"linearGain\": 5.6569 }, { \"type\": \"peak\", \"cutoffHz\": 594.6, \"linearGain\": 8 }, { \"type\": \"peak\", \"cutoffHz\": 1681.79, \"linearGain\": 0.0884 }, { \"type\": \"peak\", \"cutoffHz\": 707.11, \"linearGain\": 0.0884 }, { \"type\": \"peak\", \"cutoffHz\": 840.9, \"linearGain\": 8 }, { \"type\": \"high-pass\", \"cutoffHz\": 210.22, \"linearGain\": 1.4142 }], \"effects\": [\"vibrato\", \"reverb\"], \"vibrato\": \"shaky\", \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0.0263, \"fadeOutTicks\": 12, \"chord\": \"simultaneous\", \"harmonics\": [71, 86, 100, 100, 86, 86, 57, 43, 29, 29, 29, 29, 29, 29, 43, 43, 43, 43, 43, 29, 29, 29, 29, 14, 14, 14, 14, 14], \"unison\": \"none\", \"envelopes\": [] } },\r\n                { name: \"voice ooh\", midiProgram: 53, generalMidi: true, settings: { \"type\": \"harmonics\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 1414, \"filterResonance\": 57, \"filterEnvelope\": \"steady\", \"interval\": \"union\", \"vibrato\": \"shaky\", \"harmonics\": [100, 57, 43, 43, 14, 14, 0, 0, 0, 14, 29, 29, 14, 0, 14, 29, 29, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } },\r\n                { name: \"voice synth\", midiProgram: 54, generalMidi: true, settings: { \"type\": \"chip\", \"transition\": \"medium fade\", \"effects\": \"chorus & reverb\", \"chord\": \"harmony\", \"filterCutoffHz\": 4000, \"filterResonance\": 57, \"filterEnvelope\": \"steady\", \"wave\": \"rounded\", \"interval\": \"union\", \"vibrato\": \"light\" } },\r\n                { name: \"vox synth lead\", midiProgram: 85, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"chorus & reverb\", \"transition\": \"cross fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 2828, \"filterResonance\": 14, \"filterEnvelope\": \"steady\", \"vibrato\": \"light\", \"algorithm\": \"(1 2 3)←4\", \"feedbackType\": \"1→2→3→4\", \"feedbackAmplitude\": 2, \"feedbackEnvelope\": \"punch\", \"operators\": [{ \"frequency\": \"2×\", \"amplitude\": 10, \"envelope\": \"custom\" }, { \"frequency\": \"9×\", \"amplitude\": 5, \"envelope\": \"custom\" }, { \"frequency\": \"20×\", \"amplitude\": 1, \"envelope\": \"custom\" }, { \"frequency\": \"~1×\", \"amplitude\": 4, \"envelope\": \"steady\" }] } },\r\n                { name: \"tiny robot\", midiProgram: 85, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [\"vibrato\", \"reverb\"], \"vibrato\": \"delayed\", \"reverb\": 33, \"transition\": \"slide\", \"fadeInSeconds\": 0.0263, \"fadeOutTicks\": -3, \"chord\": \"simultaneous\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 2, \"operators\": [{ \"frequency\": \"2×\", \"amplitude\": 15 }, { \"frequency\": \"1×\", \"amplitude\": 7 }, { \"frequency\": \"~1×\", \"amplitude\": 7 }, { \"frequency\": \"1×\", \"amplitude\": 0 }], \"envelopes\": [{ \"target\": \"operatorAmplitude\", \"envelope\": \"punch\", \"index\": 1 }, { \"target\": \"feedbackAmplitude\", \"envelope\": \"twang 3\" }] } },\r\n                { name: \"yowie\", midiProgram: 85, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"cross fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 86, \"filterEnvelope\": \"tremolo5\", \"vibrato\": \"none\", \"algorithm\": \"1←2←(3 4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 12, \"feedbackEnvelope\": \"tremolo3\", \"operators\": [{ \"frequency\": \"2×\", \"amplitude\": 12, \"envelope\": \"custom\" }, { \"frequency\": \"16×\", \"amplitude\": 5, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 5, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 0, \"envelope\": \"steady\" }] } },\r\n                { name: \"mouse\", midiProgram: 85, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [\"vibrato\", \"reverb\"], \"vibrato\": \"light\", \"reverb\": 33, \"transition\": \"slide in pattern\", \"fadeInSeconds\": 0.0263, \"fadeOutTicks\": -3, \"chord\": \"simultaneous\", \"algorithm\": \"1 2 3 4\", \"feedbackType\": \"1⟲ 2⟲\", \"feedbackAmplitude\": 5, \"operators\": [{ \"frequency\": \"2×\", \"amplitude\": 13 }, { \"frequency\": \"5×\", \"amplitude\": 12 }, { \"frequency\": \"1×\", \"amplitude\": 0 }, { \"frequency\": \"1×\", \"amplitude\": 0 }], \"envelopes\": [{ \"target\": \"noteVolume\", \"envelope\": \"note size\" }, { \"target\": \"feedbackAmplitude\", \"envelope\": \"flare 2\" }] } },\r\n                { name: \"gumdrop\", midiProgram: 85, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"hard\", \"chord\": \"harmony\", \"filterCutoffHz\": 8000, \"filterResonance\": 0, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"(1 2 3)←4\", \"feedbackType\": \"1⟲ 2⟲ 3⟲\", \"feedbackAmplitude\": 0, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"2×\", \"amplitude\": 15, \"envelope\": \"punch\" }, { \"frequency\": \"4×\", \"amplitude\": 15, \"envelope\": \"punch\" }, { \"frequency\": \"7×\", \"amplitude\": 15, \"envelope\": \"punch\" }, { \"frequency\": \"1×\", \"amplitude\": 10, \"envelope\": \"twang 1\" }] } },\r\n                { name: \"echo drop\", midiProgram: 102, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"chorus & reverb\", \"transition\": \"hard\", \"chord\": \"harmony\", \"filterCutoffHz\": 2828, \"filterResonance\": 14, \"filterEnvelope\": \"punch\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 2, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"~2×\", \"amplitude\": 11, \"envelope\": \"custom\" }, { \"frequency\": \"~1×\", \"amplitude\": 5, \"envelope\": \"steady\" }, { \"frequency\": \"11×\", \"amplitude\": 2, \"envelope\": \"steady\" }, { \"frequency\": \"16×\", \"amplitude\": 5, \"envelope\": \"swell 3\" }] } },\r\n                { name: \"dark choir\", midiProgram: 85, settings: { \"type\": \"spectrum\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 4000, \"filterResonance\": 29, \"filterEnvelope\": \"swell 1\", \"spectrum\": [43, 14, 14, 14, 14, 14, 14, 100, 14, 14, 14, 57, 14, 14, 100, 14, 43, 14, 43, 14, 14, 43, 14, 29, 14, 29, 14, 14, 29, 0] } },\r\n            ])\r\n        },\r\n        {\r\n            name: \"Brass Presets\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"trumpet\", midiProgram: 56, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 2828, \"filterResonance\": 43, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 9, \"feedbackEnvelope\": \"swell 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 14, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 8, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 5, \"envelope\": \"flare 2\" }, { \"frequency\": \"1×\", \"amplitude\": 0, \"envelope\": \"steady\" }] } },\r\n                { name: \"trombone\", midiProgram: 57, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 43, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"2⟲\", \"feedbackAmplitude\": 7, \"feedbackEnvelope\": \"swell 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 14, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 8, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 0, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 0, \"envelope\": \"steady\" }] } },\r\n                { name: \"tuba\", midiProgram: 58, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 43, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"2⟲\", \"feedbackAmplitude\": 8, \"feedbackEnvelope\": \"swell 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 14, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 6, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 0, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 0, \"envelope\": \"steady\" }] } },\r\n                { name: \"muted trumpet\", midiProgram: 59, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 8000, \"linearGain\": 2.8284 }, { \"type\": \"peak\", \"cutoffHz\": 4000, \"linearGain\": 2.8284 }], \"effects\": [\"note filter\", \"reverb\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 3363.59, \"linearGain\": 1 }], \"reverb\": 33, \"fadeInSeconds\": 0.0263, \"fadeOutTicks\": -3, \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 5, \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 13 }, { \"frequency\": \"1×\", \"amplitude\": 5 }, { \"frequency\": \"9×\", \"amplitude\": 5 }, { \"frequency\": \"13×\", \"amplitude\": 7 }], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"swell 1\" }, { \"target\": \"operatorAmplitude\", \"envelope\": \"swell 1\", \"index\": 3 }, { \"target\": \"feedbackAmplitude\", \"envelope\": \"flare 2\" }] } },\r\n                { name: \"french horn\", midiProgram: 60, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4000, \"linearGain\": 1 }, { \"type\": \"peak\", \"cutoffHz\": 2378.41, \"linearGain\": 2.8284 }], \"effects\": [\"reverb\"], \"reverb\": 33, \"fadeInSeconds\": 0.0263, \"fadeOutTicks\": -3, \"algorithm\": \"1←3 2←4\", \"feedbackType\": \"1⟲ 2⟲\", \"feedbackAmplitude\": 3, \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15 }, { \"frequency\": \"1×\", \"amplitude\": 12 }, { \"frequency\": \"1×\", \"amplitude\": 10 }, { \"frequency\": \"~1×\", \"amplitude\": 8 }], \"envelopes\": [{ \"target\": \"operatorAmplitude\", \"envelope\": \"swell 1\", \"index\": 2 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"flare 2\", \"index\": 3 }, { \"target\": \"feedbackAmplitude\", \"envelope\": \"swell 1\" }] } },\r\n                { name: \"brass section\", midiProgram: 61, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 2828, \"filterResonance\": 14, \"filterEnvelope\": \"punch\", \"vibrato\": \"none\", \"algorithm\": \"1←3 2←4\", \"feedbackType\": \"1⟲ 2⟲\", \"feedbackAmplitude\": 6, \"feedbackEnvelope\": \"swell 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 14, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 12, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 10, \"envelope\": \"swell 1\" }, { \"frequency\": \"~1×\", \"amplitude\": 10, \"envelope\": \"swell 1\" }] } },\r\n                { name: \"brass synth 1\", midiProgram: 62, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 4000, \"filterResonance\": 29, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"1←3 2←4\", \"feedbackType\": \"1⟲ 2⟲\", \"feedbackAmplitude\": 11, \"feedbackEnvelope\": \"swell 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 14, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 14, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 12, \"envelope\": \"flare 1\" }, { \"frequency\": \"~1×\", \"amplitude\": 8, \"envelope\": \"flare 2\" }] } },\r\n                { name: \"brass synth 2\", midiProgram: 63, generalMidi: true, settings: { \"type\": \"FM\", \"transition\": \"soft\", \"effects\": \"reverb\", \"chord\": \"harmony\", \"filterCutoffHz\": 4000, \"filterResonance\": 43, \"filterEnvelope\": \"twang 3\", \"vibrato\": \"none\", \"algorithm\": \"1←3 2←4\", \"feedbackType\": \"1⟲ 2⟲\", \"feedbackAmplitude\": 9, \"feedbackEnvelope\": \"swell 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 15, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 10, \"envelope\": \"flare 1\" }, { \"frequency\": \"~1×\", \"amplitude\": 7, \"envelope\": \"flare 1\" }] } },\r\n                { name: \"pulse brass\", midiProgram: 62, settings: { \"type\": \"PWM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 4000, \"filterResonance\": 29, \"filterEnvelope\": \"swell 1\", \"pulseWidth\": 50, \"pulseEnvelope\": \"flare 3\", \"vibrato\": \"none\" } },\r\n            ])\r\n        },\r\n        {\r\n            name: \"Reed Presets\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"soprano sax\", midiProgram: 64, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 29, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"1←2←3←4\", \"feedbackType\": \"4⟲\", \"feedbackAmplitude\": 5, \"feedbackEnvelope\": \"swell 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 13, \"envelope\": \"custom\" }, { \"frequency\": \"4×\", \"amplitude\": 4, \"envelope\": \"swell 1\" }, { \"frequency\": \"1×\", \"amplitude\": 7, \"envelope\": \"steady\" }, { \"frequency\": \"5×\", \"amplitude\": 4, \"envelope\": \"punch\" }] } },\r\n                { name: \"alto sax\", midiProgram: 65, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 43, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 4, \"feedbackEnvelope\": \"punch\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 13, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 6, \"envelope\": \"steady\" }, { \"frequency\": \"4×\", \"amplitude\": 6, \"envelope\": \"swell 1\" }, { \"frequency\": \"1×\", \"amplitude\": 12, \"envelope\": \"steady\" }] } },\r\n                { name: \"tenor sax\", midiProgram: 66, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 2828, \"filterResonance\": 29, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"1←2←3←4\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 6, \"feedbackEnvelope\": \"swell 1\", \"operators\": [{ \"frequency\": \"2×\", \"amplitude\": 12, \"envelope\": \"custom\" }, { \"frequency\": \"3×\", \"amplitude\": 7, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 3, \"envelope\": \"steady\" }, { \"frequency\": \"8×\", \"amplitude\": 3, \"envelope\": \"steady\" }] } },\r\n                { name: \"baritone sax\", midiProgram: 67, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 2828, \"filterResonance\": 0, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 2, \"feedbackEnvelope\": \"swell 2\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 12, \"envelope\": \"custom\" }, { \"frequency\": \"8×\", \"amplitude\": 4, \"envelope\": \"steady\" }, { \"frequency\": \"4×\", \"amplitude\": 5, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 4, \"envelope\": \"punch\" }] } },\r\n                { name: \"sax synth\", midiProgram: 64, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 8000, \"filterResonance\": 0, \"filterEnvelope\": \"steady\", \"vibrato\": \"light\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"1⟲ 2⟲\", \"feedbackAmplitude\": 4, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"4×\", \"amplitude\": 15, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 15, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 0, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 0, \"envelope\": \"steady\" }] } },\r\n                { name: \"shehnai\", midiProgram: 111, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 8000, \"filterResonance\": 0, \"filterEnvelope\": \"steady\", \"vibrato\": \"light\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 3, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"4×\", \"amplitude\": 15, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 8, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 0, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 0, \"envelope\": \"steady\" }] } },\r\n                { name: \"oboe\", midiProgram: 68, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"cross fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 4000, \"filterResonance\": 14, \"filterEnvelope\": \"swell 1\", \"vibrato\": \"none\", \"algorithm\": \"1 2←(3 4)\", \"feedbackType\": \"2⟲\", \"feedbackAmplitude\": 2, \"feedbackEnvelope\": \"tremolo5\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 7, \"envelope\": \"custom\" }, { \"frequency\": \"4×\", \"amplitude\": 12, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 6, \"envelope\": \"steady\" }, { \"frequency\": \"6×\", \"amplitude\": 2, \"envelope\": \"steady\" }] } },\r\n                { name: \"english horn\", midiProgram: 69, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"cross fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 14, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"1 2←(3 4)\", \"feedbackType\": \"2⟲\", \"feedbackAmplitude\": 2, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"4×\", \"amplitude\": 12, \"envelope\": \"custom\" }, { \"frequency\": \"2×\", \"amplitude\": 10, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 8, \"envelope\": \"punch\" }, { \"frequency\": \"8×\", \"amplitude\": 4, \"envelope\": \"steady\" }] } },\r\n                { name: \"bassoon\", midiProgram: 70, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 707, \"filterResonance\": 57, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 2, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"2×\", \"amplitude\": 11, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 6, \"envelope\": \"steady\" }, { \"frequency\": \"6×\", \"amplitude\": 6, \"envelope\": \"swell 1\" }, { \"frequency\": \"1×\", \"amplitude\": 0, \"envelope\": \"steady\" }] } },\r\n                { name: \"clarinet\", midiProgram: 71, generalMidi: true, settings: { \"type\": \"harmonics\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 1414, \"filterResonance\": 14, \"filterEnvelope\": \"steady\", \"interval\": \"union\", \"vibrato\": \"none\", \"harmonics\": [100, 43, 86, 57, 86, 71, 86, 71, 71, 71, 71, 71, 71, 43, 71, 71, 57, 57, 57, 57, 57, 57, 43, 43, 43, 29, 14, 0] } },\r\n                { name: \"harmonica\", midiProgram: 22, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 5657, \"filterResonance\": 29, \"filterEnvelope\": \"swell 1\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 9, \"feedbackEnvelope\": \"tremolo5\", \"operators\": [{ \"frequency\": \"2×\", \"amplitude\": 14, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 15, \"envelope\": \"steady\" }, { \"frequency\": \"~2×\", \"amplitude\": 2, \"envelope\": \"twang 3\" }, { \"frequency\": \"1×\", \"amplitude\": 0, \"envelope\": \"steady\" }] } },\r\n            ])\r\n        },\r\n        {\r\n            name: \"Flute Presets\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"flute 1\", midiProgram: 73, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 5657, \"filterResonance\": 14, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"4⟲\", \"feedbackAmplitude\": 7, \"feedbackEnvelope\": \"decay 2\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15, \"envelope\": \"custom\" }, { \"frequency\": \"2×\", \"amplitude\": 4, \"envelope\": \"steady\" }, { \"frequency\": \"1×\", \"amplitude\": 3, \"envelope\": \"steady\" }, { \"frequency\": \"~1×\", \"amplitude\": 1, \"envelope\": \"punch\" }] } },\r\n                { name: \"recorder\", midiProgram: 74, generalMidi: true, settings: { \"type\": \"harmonics\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 4000, \"filterResonance\": 29, \"filterEnvelope\": \"swell 2\", \"interval\": \"union\", \"vibrato\": \"none\", \"harmonics\": [100, 43, 57, 43, 57, 43, 43, 43, 43, 43, 43, 43, 43, 29, 29, 29, 29, 29, 29, 29, 14, 14, 14, 14, 14, 14, 14, 0] } },\r\n                { name: \"whistle\", midiProgram: 78, generalMidi: true, settings: { \"type\": \"harmonics\", \"effects\": \"chorus & reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 43, \"filterEnvelope\": \"steady\", \"interval\": \"union\", \"vibrato\": \"delayed\", \"harmonics\": [100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } },\r\n                { name: \"ocarina\", midiProgram: 79, generalMidi: true, settings: { \"type\": \"harmonics\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 2828, \"filterResonance\": 43, \"filterEnvelope\": \"steady\", \"interval\": \"union\", \"vibrato\": \"none\", \"harmonics\": [100, 14, 57, 14, 29, 14, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } },\r\n                { name: \"piccolo\", midiProgram: 72, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 5657, \"filterResonance\": 43, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"1←3 2←4\", \"feedbackType\": \"4⟲\", \"feedbackAmplitude\": 15, \"feedbackEnvelope\": \"twang 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15, \"envelope\": \"custom\" }, { \"frequency\": \"1×\", \"amplitude\": 10, \"envelope\": \"custom\" }, { \"frequency\": \"~2×\", \"amplitude\": 3, \"envelope\": \"punch\" }, { \"frequency\": \"~1×\", \"amplitude\": 5, \"envelope\": \"punch\" }] } },\r\n                { name: \"shakuhachi\", midiProgram: 77, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"chorus & reverb\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 4000, \"filterResonance\": 14, \"filterEnvelope\": \"steady\", \"vibrato\": \"delayed\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"3→4\", \"feedbackAmplitude\": 15, \"feedbackEnvelope\": \"steady\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15, \"envelope\": \"custom\" }, { \"frequency\": \"2×\", \"amplitude\": 3, \"envelope\": \"punch\" }, { \"frequency\": \"~1×\", \"amplitude\": 4, \"envelope\": \"twang 1\" }, { \"frequency\": \"20×\", \"amplitude\": 15, \"envelope\": \"steady\" }] } },\r\n                { name: \"pan flute\", midiProgram: 75, generalMidi: true, settings: { \"type\": \"spectrum\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 9513.66, \"linearGain\": 5.6569 }], \"effects\": [\"note filter\", \"reverb\"], \"noteFilter\": [{ \"type\": \"high-pass\", \"cutoffHz\": 4756.83, \"linearGain\": 0.7071 }], \"reverb\": 33, \"fadeInSeconds\": 0.0125, \"fadeOutTicks\": -3, \"spectrum\": [100, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 71, 0, 0, 14, 0, 57, 0, 29, 14, 29, 14, 14, 29, 14, 29, 14, 14, 29, 14], \"envelopes\": [{ \"target\": \"noteFilterFreq\", \"envelope\": \"twang 1\", \"index\": 0 }, { \"target\": \"noteVolume\", \"envelope\": \"punch\" }] } },\r\n                { name: \"blown bottle\", midiProgram: 76, generalMidi: true, settings: { \"type\": \"FM\", \"effects\": \"chorus & reverb\", \"transition\": \"cross fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 5657, \"filterResonance\": 57, \"filterEnvelope\": \"steady\", \"vibrato\": \"none\", \"algorithm\": \"1 2 3 4\", \"feedbackType\": \"1⟲ 2⟲ 3⟲ 4⟲\", \"feedbackAmplitude\": 7, \"feedbackEnvelope\": \"twang 1\", \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15, \"envelope\": \"custom\" }, { \"frequency\": \"3×\", \"amplitude\": 4, \"envelope\": \"custom\" }, { \"frequency\": \"6×\", \"amplitude\": 2, \"envelope\": \"custom\" }, { \"frequency\": \"11×\", \"amplitude\": 2, \"envelope\": \"custom\" }] } },\r\n                { name: \"calliope\", midiProgram: 82, generalMidi: true, settings: { \"type\": \"spectrum\", \"transition\": \"cross fade\", \"effects\": \"reverb\", \"chord\": \"harmony\", \"filterCutoffHz\": 5657, \"filterResonance\": 14, \"filterEnvelope\": \"steady\", \"spectrum\": [100, 0, 0, 0, 0, 0, 0, 86, 0, 0, 0, 71, 0, 0, 57, 0, 43, 0, 29, 14, 14, 29, 14, 14, 14, 14, 14, 14, 14, 14] } },\r\n                { name: \"chiffer\", midiProgram: 83, generalMidi: true, settings: { \"type\": \"spectrum\", \"effects\": \"reverb\", \"transition\": \"hard\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 14, \"filterEnvelope\": \"punch\", \"spectrum\": [86, 0, 0, 0, 0, 0, 0, 71, 0, 0, 0, 71, 0, 0, 57, 0, 57, 0, 43, 14, 14, 43, 14, 29, 14, 29, 29, 29, 29, 14] } },\r\n                { name: \"breath noise\", midiProgram: 121, generalMidi: true, settings: { \"type\": \"spectrum\", \"eqFilter\": [], \"effects\": [\"chord type\", \"note filter\", \"reverb\"], \"chord\": \"strum\", \"noteFilter\": [{ \"type\": \"high-pass\", \"cutoffHz\": 840.9, \"linearGain\": 0.3536 }, { \"type\": \"low-pass\", \"cutoffHz\": 16000, \"linearGain\": 0.3536 }], \"reverb\": 33, \"fadeInSeconds\": 0.0413, \"fadeOutTicks\": 12, \"spectrum\": [71, 0, 0, 0, 0, 0, 0, 29, 0, 0, 0, 71, 0, 0, 29, 0, 100, 29, 14, 29, 100, 29, 100, 14, 14, 71, 0, 29, 0, 0], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"twang 1\" }] } },\r\n                { name: \"flute 2\", midiProgram: 73, generalMidi: true, settings: { \"type\": \"harmonics\", \"effects\": \"reverb\", \"transition\": \"seamless\", \"chord\": \"harmony\", \"filterCutoffHz\": 1414, \"filterResonance\": 14, \"filterEnvelope\": \"steady\", \"interval\": \"union\", \"vibrato\": \"delayed\", \"harmonics\": [100, 43, 86, 57, 86, 71, 86, 71, 71, 71, 71, 71, 71, 43, 71, 71, 57, 57, 57, 57, 57, 57, 43, 43, 43, 29, 14, 0] } },\r\n            ])\r\n        },\r\n        {\r\n            name: \"Pad Presets\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"new age pad\", midiProgram: 88, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [\"chorus\"], \"chorus\": 100, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 48, \"chord\": \"simultaneous\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"1⟲ 2⟲\", \"feedbackAmplitude\": 3, \"operators\": [{ \"frequency\": \"2×\", \"amplitude\": 14 }, { \"frequency\": \"~1×\", \"amplitude\": 4 }, { \"frequency\": \"6×\", \"amplitude\": 3 }, { \"frequency\": \"13×\", \"amplitude\": 3 }], \"envelopes\": [{ \"target\": \"operatorAmplitude\", \"envelope\": \"swell 2\", \"index\": 1 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"twang 3\", \"index\": 2 }, { \"target\": \"feedbackAmplitude\", \"envelope\": \"swell 3\" }] } },\r\n                { name: \"warm pad\", midiProgram: 89, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [\"note filter\", \"chorus\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 3363.59, \"linearGain\": 1 }], \"chorus\": 100, \"transition\": \"normal\", \"fadeInSeconds\": 0.0575, \"fadeOutTicks\": 96, \"chord\": \"simultaneous\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 7, \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 14 }, { \"frequency\": \"1×\", \"amplitude\": 6 }, { \"frequency\": \"1×\", \"amplitude\": 0 }, { \"frequency\": \"1×\", \"amplitude\": 0 }], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"swell 3\" }, { \"target\": \"operatorAmplitude\", \"envelope\": \"swell 1\", \"index\": 1 }] } },\r\n                { name: \"polysynth pad\", midiProgram: 90, generalMidi: true, settings: { \"type\": \"chip\", \"eqFilter\": [], \"effects\": [\"vibrato\", \"note filter\", \"chorus\"], \"vibrato\": \"delayed\", \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 2828.43, \"linearGain\": 1 }], \"chorus\": 100, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 48, \"chord\": \"simultaneous\", \"wave\": \"sawtooth\", \"unison\": \"honky tonk\", \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"twang 3\" }] } },\r\n                { name: \"space voice pad\", midiProgram: 91, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 6727.17, \"linearGain\": 5.6569 }, { \"type\": \"peak\", \"cutoffHz\": 2828.43, \"linearGain\": 5.6569 }, { \"type\": \"peak\", \"cutoffHz\": 1414.21, \"linearGain\": 0.1768 }], \"effects\": [\"chorus\"], \"chorus\": 100, \"transition\": \"normal\", \"fadeInSeconds\": 0.0125, \"fadeOutTicks\": 72, \"chord\": \"simultaneous\", \"algorithm\": \"(1 2 3)←4\", \"feedbackType\": \"1⟲ 2⟲ 3⟲ 4⟲\", \"feedbackAmplitude\": 5, \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 10 }, { \"frequency\": \"2×\", \"amplitude\": 8 }, { \"frequency\": \"3×\", \"amplitude\": 7 }, { \"frequency\": \"11×\", \"amplitude\": 2 }], \"envelopes\": [{ \"target\": \"operatorAmplitude\", \"envelope\": \"punch\", \"index\": 3 }, { \"target\": \"feedbackAmplitude\", \"envelope\": \"swell 2\" }] } },\r\n                { name: \"bowed glass pad\", midiProgram: 92, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [\"note filter\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4756.83, \"linearGain\": 0.5 }], \"transition\": \"normal\", \"fadeInSeconds\": 0.0575, \"fadeOutTicks\": 96, \"chord\": \"simultaneous\", \"algorithm\": \"1←3 2←4\", \"feedbackType\": \"1⟲ 2⟲\", \"feedbackAmplitude\": 0, \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 10 }, { \"frequency\": \"2×\", \"amplitude\": 12 }, { \"frequency\": \"3×\", \"amplitude\": 7 }, { \"frequency\": \"7×\", \"amplitude\": 4 }], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"twang 3\" }, { \"target\": \"operatorAmplitude\", \"envelope\": \"twang 3\", \"index\": 2 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"flare 3\", \"index\": 3 }] } },\r\n                { name: \"metallic pad\", midiProgram: 93, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [\"note filter\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 6727.17, \"linearGain\": 0.5 }], \"transition\": \"normal\", \"fadeInSeconds\": 0.0125, \"fadeOutTicks\": 72, \"chord\": \"simultaneous\", \"algorithm\": \"1←3 2←4\", \"feedbackType\": \"1⟲ 2⟲\", \"feedbackAmplitude\": 13, \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15 }, { \"frequency\": \"~1×\", \"amplitude\": 9 }, { \"frequency\": \"1×\", \"amplitude\": 7 }, { \"frequency\": \"11×\", \"amplitude\": 7 }], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"twang 3\" }, { \"target\": \"operatorAmplitude\", \"envelope\": \"swell 2\", \"index\": 2 }, { \"target\": \"feedbackAmplitude\", \"envelope\": \"twang 3\" }] } },\r\n                { name: \"sweep pad\", midiProgram: 95, generalMidi: true, settings: { \"type\": \"chip\", \"eqFilter\": [], \"effects\": [\"note filter\", \"chorus\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4000, \"linearGain\": 4 }], \"chorus\": 100, \"transition\": \"normal\", \"fadeInSeconds\": 0.0575, \"fadeOutTicks\": 96, \"chord\": \"simultaneous\", \"wave\": \"sawtooth\", \"unison\": \"hum\", \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"flare 3\" }] } },\r\n                { name: \"atmosphere\", midiProgram: 99, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4756.83, \"linearGain\": 1 }], \"effects\": [\"chorus\", \"reverb\"], \"chorus\": 100, \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 48, \"chord\": \"strum\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"3⟲ 4⟲\", \"feedbackAmplitude\": 3, \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 14 }, { \"frequency\": \"~1×\", \"amplitude\": 10 }, { \"frequency\": \"3×\", \"amplitude\": 7 }, { \"frequency\": \"1×\", \"amplitude\": 7 }], \"envelopes\": [{ \"target\": \"operatorAmplitude\", \"envelope\": \"swell 3\", \"index\": 1 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"twang 2\", \"index\": 2 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"twang 3\", \"index\": 3 }] } },\r\n                { name: \"brightness\", midiProgram: 100, generalMidi: true, settings: { \"type\": \"Picked String\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4756.83, \"linearGain\": 2 }], \"effects\": [\"chorus\"], \"chorus\": 100, \"transition\": \"normal\", \"fadeInSeconds\": 0.0125, \"fadeOutTicks\": 72, \"chord\": \"simultaneous\", \"harmonics\": [100, 86, 86, 86, 43, 57, 43, 71, 43, 43, 43, 57, 43, 43, 57, 71, 57, 43, 29, 43, 57, 57, 43, 29, 29, 29, 29, 14], \"unison\": \"octave\", \"stringSustain\": 86, \"envelopes\": [] } },\r\n                { name: \"goblins\", midiProgram: 101, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [{ \"type\": \"peak\", \"cutoffHz\": 2828.43, \"linearGain\": 11.3137 }], \"effects\": [\"note filter\", \"chorus\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 1681.79, \"linearGain\": 0.5 }], \"chorus\": 100, \"transition\": \"normal\", \"fadeInSeconds\": 0.0575, \"fadeOutTicks\": 96, \"chord\": \"simultaneous\", \"algorithm\": \"1←2←3←4\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 10, \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15 }, { \"frequency\": \"4×\", \"amplitude\": 5 }, { \"frequency\": \"1×\", \"amplitude\": 10 }, { \"frequency\": \"1×\", \"amplitude\": 0 }], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"swell 2\" }, { \"target\": \"operatorAmplitude\", \"envelope\": \"swell 3\", \"index\": 1 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"tremolo1\", \"index\": 2 }, { \"target\": \"feedbackAmplitude\", \"envelope\": \"flare 3\" }] } },\r\n                { name: \"sci-fi\", midiProgram: 103, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [{ \"type\": \"peak\", \"cutoffHz\": 9513.66, \"linearGain\": 2.8284 }], \"effects\": [\"note filter\", \"chorus\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 6727.17, \"linearGain\": 0.5 }], \"chorus\": 100, \"transition\": \"normal\", \"fadeInSeconds\": 0.0125, \"fadeOutTicks\": 48, \"chord\": \"simultaneous\", \"algorithm\": \"(1 2)←3←4\", \"feedbackType\": \"1⟲ 2⟲ 3⟲ 4⟲\", \"feedbackAmplitude\": 8, \"operators\": [{ \"frequency\": \"~1×\", \"amplitude\": 13 }, { \"frequency\": \"2×\", \"amplitude\": 10 }, { \"frequency\": \"5×\", \"amplitude\": 5 }, { \"frequency\": \"11×\", \"amplitude\": 8 }], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"twang 3\" }, { \"target\": \"operatorAmplitude\", \"envelope\": \"twang 3\", \"index\": 2 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"tremolo5\", \"index\": 3 }, { \"target\": \"feedbackAmplitude\", \"envelope\": \"twang 3\" }] } },\r\n                { name: \"flutter pad\", midiProgram: 90, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [\"vibrato\", \"note filter\", \"chorus\"], \"vibrato\": \"delayed\", \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4000, \"linearGain\": 4 }], \"chorus\": 100, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 48, \"chord\": \"simultaneous\", \"algorithm\": \"(1 2)←(3 4)\", \"feedbackType\": \"1⟲ 2⟲ 3⟲\", \"feedbackAmplitude\": 9, \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 13 }, { \"frequency\": \"5×\", \"amplitude\": 7 }, { \"frequency\": \"7×\", \"amplitude\": 5 }, { \"frequency\": \"~1×\", \"amplitude\": 6 }], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"twang 3\" }, { \"target\": \"operatorAmplitude\", \"envelope\": \"tremolo1\", \"index\": 2 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"punch\", \"index\": 3 }] } },\r\n                { name: \"feedback pad\", midiProgram: 89, settings: { \"type\": \"FM\", \"eqFilter\": [{ \"type\": \"peak\", \"cutoffHz\": 2378.41, \"linearGain\": 8 }], \"effects\": [], \"transition\": \"normal\", \"fadeInSeconds\": 0.0575, \"fadeOutTicks\": 96, \"chord\": \"custom interval\", \"algorithm\": \"1 2 3 4\", \"feedbackType\": \"1⟲ 2⟲ 3⟲ 4⟲\", \"feedbackAmplitude\": 8, \"operators\": [{ \"frequency\": \"1×\", \"amplitude\": 15 }, { \"frequency\": \"1×\", \"amplitude\": 15 }, { \"frequency\": \"1×\", \"amplitude\": 15 }, { \"frequency\": \"~1×\", \"amplitude\": 15 }], \"envelopes\": [{ \"target\": \"feedbackAmplitude\", \"envelope\": \"swell 2\" }] } },\r\n            ])\r\n        },\r\n        {\r\n            name: \"Drum Presets\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"standard drumset\", midiProgram: 116, isNoise: true, settings: { \"type\": \"drumset\", \"effects\": \"reverb\", \"drums\": [{ \"filterEnvelope\": \"twang 1\", \"spectrum\": [57, 71, 71, 86, 86, 86, 71, 71, 71, 71, 57, 57, 57, 57, 43, 43, 43, 43, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29] }, { \"filterEnvelope\": \"twang 1\", \"spectrum\": [0, 0, 0, 100, 71, 71, 57, 86, 57, 57, 57, 71, 43, 43, 57, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43] }, { \"filterEnvelope\": \"twang 1\", \"spectrum\": [0, 0, 0, 0, 100, 57, 43, 43, 29, 57, 43, 29, 71, 43, 43, 43, 43, 57, 43, 43, 43, 43, 43, 43, 43, 43, 29, 43, 43, 43] }, { \"filterEnvelope\": \"twang 1\", \"spectrum\": [0, 0, 0, 0, 0, 71, 57, 43, 43, 43, 57, 57, 43, 29, 57, 43, 43, 43, 29, 43, 57, 43, 43, 43, 43, 43, 43, 29, 43, 43] }, { \"filterEnvelope\": \"decay 2\", \"spectrum\": [0, 14, 29, 43, 86, 71, 29, 43, 43, 43, 43, 29, 71, 29, 71, 29, 43, 43, 43, 43, 57, 43, 43, 57, 43, 43, 43, 57, 57, 57] }, { \"filterEnvelope\": \"decay 1\", \"spectrum\": [0, 0, 14, 14, 14, 14, 29, 29, 29, 43, 43, 43, 57, 57, 57, 71, 71, 71, 71, 71, 71, 71, 71, 57, 57, 57, 57, 43, 43, 43] }, { \"filterEnvelope\": \"twang 3\", \"spectrum\": [43, 43, 43, 71, 29, 29, 43, 43, 43, 29, 43, 43, 43, 29, 29, 43, 43, 29, 29, 29, 57, 14, 57, 43, 43, 57, 43, 43, 57, 57] }, { \"filterEnvelope\": \"decay 3\", \"spectrum\": [29, 43, 43, 43, 43, 29, 29, 43, 29, 29, 43, 29, 14, 29, 43, 29, 43, 29, 57, 29, 43, 57, 43, 71, 43, 71, 57, 57, 71, 71] }, { \"filterEnvelope\": \"twang 3\", \"spectrum\": [43, 29, 29, 43, 29, 29, 29, 57, 29, 29, 29, 57, 43, 43, 29, 29, 57, 43, 43, 43, 71, 43, 43, 71, 57, 71, 71, 71, 71, 71] }, { \"filterEnvelope\": \"decay 3\", \"spectrum\": [57, 57, 57, 43, 57, 57, 43, 43, 57, 43, 43, 43, 71, 57, 43, 57, 86, 71, 57, 86, 71, 57, 86, 100, 71, 86, 86, 86, 86, 86] }, { \"filterEnvelope\": \"flare 1\", \"spectrum\": [0, 0, 14, 14, 14, 14, 29, 29, 29, 43, 43, 43, 57, 57, 71, 71, 86, 86, 100, 100, 100, 100, 100, 100, 100, 100, 86, 57, 29, 0] }, { \"filterEnvelope\": \"decay 2\", \"spectrum\": [14, 14, 14, 14, 29, 14, 14, 29, 14, 43, 14, 43, 57, 86, 57, 57, 100, 57, 43, 43, 57, 100, 57, 43, 29, 14, 0, 0, 0, 0] }] } },\r\n                { name: \"steel pan\", midiProgram: 114, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [{ \"type\": \"high-pass\", \"cutoffHz\": 62.5, \"linearGain\": 0.1768 }], \"effects\": [\"note filter\", \"chorus\", \"reverb\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 13454.34, \"linearGain\": 0.25 }], \"chorus\": 67, \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 24, \"chord\": \"simultaneous\", \"algorithm\": \"1←(2 3←4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 0, \"operators\": [{ \"frequency\": \"~1×\", \"amplitude\": 14 }, { \"frequency\": \"7×\", \"amplitude\": 3 }, { \"frequency\": \"3×\", \"amplitude\": 5 }, { \"frequency\": \"4×\", \"amplitude\": 4 }], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"decay 2\" }, { \"target\": \"operatorAmplitude\", \"envelope\": \"flare 1\", \"index\": 1 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"flare 2\", \"index\": 2 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"swell 2\", \"index\": 3 }] } },\r\n                { name: \"steel pan synth\", midiProgram: 114, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [\"note filter\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 13454.34, \"linearGain\": 0.25 }], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -3, \"chord\": \"simultaneous\", \"algorithm\": \"1 2 3←4\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 5, \"operators\": [{ \"frequency\": \"~1×\", \"amplitude\": 12 }, { \"frequency\": \"2×\", \"amplitude\": 15 }, { \"frequency\": \"4×\", \"amplitude\": 14 }, { \"frequency\": \"~1×\", \"amplitude\": 3 }], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"twang 1\" }, { \"target\": \"operatorAmplitude\", \"envelope\": \"note size\", \"index\": 0 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"note size\", \"index\": 1 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"flare 1\", \"index\": 2 }, { \"target\": \"operatorAmplitude\", \"envelope\": \"flare 2\", \"index\": 3 }, { \"target\": \"feedbackAmplitude\", \"envelope\": \"flare 1\" }] } },\r\n                { name: \"timpani\", midiProgram: 47, generalMidi: true, settings: { \"type\": \"spectrum\", \"eqFilter\": [{ \"type\": \"peak\", \"cutoffHz\": 6727.17, \"linearGain\": 5.6569 }], \"effects\": [\"pitch shift\", \"note filter\", \"reverb\"], \"pitchShiftSemitones\": 15, \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 19027.31, \"linearGain\": 0.5 }], \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 48, \"chord\": \"simultaneous\", \"spectrum\": [100, 0, 0, 0, 86, 0, 0, 71, 0, 14, 43, 14, 43, 43, 0, 29, 43, 29, 29, 29, 43, 29, 43, 29, 43, 43, 43, 43, 43, 43], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"twang 1\" }, { \"target\": \"pitchShift\", \"envelope\": \"twang 1\" }] } },\r\n                { name: \"dark strike\", midiProgram: 47, settings: { \"type\": \"spectrum\", \"eqFilter\": [], \"effects\": [\"note filter\", \"reverb\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 4756.83, \"linearGain\": 0.7071 }], \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 48, \"chord\": \"simultaneous\", \"spectrum\": [0, 0, 14, 14, 14, 29, 29, 43, 43, 86, 43, 43, 43, 29, 86, 29, 29, 29, 86, 29, 14, 14, 14, 14, 0, 0, 0, 0, 0, 0], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"twang 2\" }] } },\r\n                { name: \"woodblock\", midiProgram: 115, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -2.5, settings: { \"type\": \"spectrum\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 2828, \"filterResonance\": 14, \"filterEnvelope\": \"twang 1\", \"spectrum\": [0, 14, 29, 43, 43, 57, 86, 86, 71, 57, 57, 43, 43, 57, 86, 86, 43, 43, 71, 57, 57, 57, 57, 57, 86, 86, 71, 71, 71, 71] } },\r\n                { name: \"taiko drum\", midiProgram: 116, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -0.5, settings: { \"type\": \"spectrum\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 2828, \"filterResonance\": 29, \"filterEnvelope\": \"twang 1\", \"spectrum\": [71, 100, 100, 43, 43, 71, 71, 43, 43, 43, 43, 43, 43, 57, 29, 57, 43, 57, 43, 43, 57, 43, 43, 43, 43, 43, 43, 43, 43, 43] } },\r\n                { name: \"melodic drum\", midiProgram: 117, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -1.5, settings: { \"type\": \"spectrum\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 2828, \"filterResonance\": 43, \"filterEnvelope\": \"twang 1\", \"spectrum\": [100, 71, 71, 57, 57, 43, 43, 71, 43, 43, 43, 57, 43, 43, 57, 43, 43, 43, 43, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29] } },\r\n                { name: \"drum synth\", midiProgram: 118, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -2, settings: { \"type\": \"spectrum\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 4000, \"filterResonance\": 43, \"filterEnvelope\": \"decay 1\", \"spectrum\": [100, 86, 71, 57, 43, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29] } },\r\n                { name: \"tom-tom\", midiProgram: 116, isNoise: true, midiSubharmonicOctaves: -1, settings: { \"type\": \"spectrum\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 2000, \"filterResonance\": 14, \"filterEnvelope\": \"twang 1\", \"spectrum\": [100, 29, 14, 0, 0, 86, 14, 43, 29, 86, 29, 14, 29, 57, 43, 43, 43, 43, 57, 43, 43, 43, 29, 57, 43, 43, 43, 43, 43, 43] } },\r\n                { name: \"metal pipe\", midiProgram: 117, isNoise: true, midiSubharmonicOctaves: -1.5, settings: { \"type\": \"spectrum\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 8000, \"filterResonance\": 14, \"filterEnvelope\": \"twang 2\", \"spectrum\": [29, 43, 86, 43, 43, 43, 43, 43, 100, 29, 14, 14, 100, 14, 14, 0, 0, 0, 0, 0, 14, 29, 29, 14, 0, 0, 14, 29, 0, 0] } },\r\n                { name: \"synth kick\", midiProgram: 47, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -6, \"chord\": \"simultaneous\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 0, \"operators\": [{ \"frequency\": \"8×\", \"amplitude\": 15 }, { \"frequency\": \"1×\", \"amplitude\": 0 }, { \"frequency\": \"1×\", \"amplitude\": 0 }, { \"frequency\": \"1×\", \"amplitude\": 0 }], \"envelopes\": [{ \"target\": \"operatorFrequency\", \"envelope\": \"twang 1\", \"index\": 0 }, { \"target\": \"noteVolume\", \"envelope\": \"twang 2\" }] } },\r\n                { name: \"synth kick 2\", midiProgram: 47, isNoise: true, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [], \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": -6, \"chord\": \"simultaneous\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 0, \"operators\": [{ \"frequency\": \"8×\", \"amplitude\": 15 }, { \"frequency\": \"1×\", \"amplitude\": 0 }, { \"frequency\": \"1×\", \"amplitude\": 0 }, { \"frequency\": \"1×\", \"amplitude\": 0 }], \"envelopes\": [{ \"target\": \"operatorFrequency\", \"envelope\": \"twang 1\", \"index\": 0 }, { \"target\": \"noteVolume\", \"envelope\": \"twang 2\" }, { \"target\": \"noteVolume\", \"envelope\": \"punch\" }] } },\r\n            ])\r\n        },\r\n        {\r\n            name: \"Novelty Presets\", presets: <DictionaryArray<Preset>>toNameMap([\r\n                { name: \"guitar fret noise\", midiProgram: 120, generalMidi: true, settings: { \"type\": \"spectrum\", \"eqFilter\": [{ \"type\": \"high-pass\", \"cutoffHz\": 1000, \"linearGain\": 0.1768 }], \"effects\": [\"note filter\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 6727.17, \"linearGain\": 5.6569 }], \"transition\": \"normal\", \"fadeInSeconds\": 0.0125, \"fadeOutTicks\": -3, \"chord\": \"simultaneous\", \"spectrum\": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 29, 14, 0, 0, 43, 0, 43, 0, 71, 43, 0, 57, 0], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"flare 1\" }, { \"target\": \"noteVolume\", \"envelope\": \"twang 2\" }] } },\r\n                { name: \"fifth saw lead\", midiProgram: 86, generalMidi: true, midiSubharmonicOctaves: 1, settings: { \"type\": \"chip\", \"eqFilter\": [], \"effects\": [\"note filter\", \"chorus\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 2828.43, \"linearGain\": 1.4142 }], \"chorus\": 67, \"transition\": \"normal\", \"fadeInSeconds\": 0, \"fadeOutTicks\": 48, \"chord\": \"simultaneous\", \"wave\": \"sawtooth\", \"unison\": \"fifth\", \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"twang 3\" }] } },\r\n                { name: \"fifth swell\", midiProgram: 86, midiSubharmonicOctaves: 1, settings: { \"type\": \"chip\", \"eqFilter\": [], \"effects\": [\"note filter\", \"chorus\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 2000, \"linearGain\": 2 }], \"chorus\": 100, \"transition\": \"normal\", \"fadeInSeconds\": 0.0125, \"fadeOutTicks\": 72, \"chord\": \"simultaneous\", \"wave\": \"sawtooth\", \"unison\": \"fifth\", \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"swell 3\" }] } },\r\n                { name: \"soundtrack\", midiProgram: 97, generalMidi: true, settings: { \"type\": \"chip\", \"eqFilter\": [], \"effects\": [\"note filter\", \"chorus\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 2378.41, \"linearGain\": 0.5 }], \"chorus\": 67, \"transition\": \"normal\", \"fadeInSeconds\": 0.0413, \"fadeOutTicks\": 72, \"chord\": \"simultaneous\", \"wave\": \"sawtooth\", \"unison\": \"fifth\", \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"flare 3\" }] } },\r\n                { name: \"reverse cymbal\", midiProgram: 119, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -3, settings: { \"type\": \"spectrum\", \"effects\": \"none\", \"transition\": \"soft\", \"chord\": \"harmony\", \"filterCutoffHz\": 4000, \"filterResonance\": 14, \"filterEnvelope\": \"swell 3\", \"spectrum\": [29, 57, 57, 29, 57, 57, 29, 29, 43, 29, 29, 43, 29, 29, 57, 57, 14, 57, 14, 57, 71, 71, 57, 86, 57, 100, 86, 86, 86, 86] } },\r\n                { name: \"seashore\", midiProgram: 122, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -3, settings: { \"type\": \"spectrum\", \"transition\": \"soft fade\", \"effects\": \"reverb\", \"chord\": \"harmony\", \"filterCutoffHz\": 2828, \"filterResonance\": 0, \"filterEnvelope\": \"swell 3\", \"spectrum\": [14, 14, 29, 29, 43, 43, 43, 57, 57, 57, 57, 57, 57, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 57] } },\r\n                { name: \"bird tweet\", midiProgram: 123, generalMidi: true, settings: { \"type\": \"harmonics\", \"eqFilter\": [], \"effects\": [\"chord type\", \"vibrato\", \"reverb\"], \"chord\": \"strum\", \"vibrato\": \"heavy\", \"reverb\": 67, \"fadeInSeconds\": 0.0575, \"fadeOutTicks\": -6, \"harmonics\": [0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"unison\": \"hum\", \"envelopes\": [{ \"target\": \"noteVolume\", \"envelope\": \"decay 1\" }] } },\r\n                { name: \"telephone ring\", midiProgram: 124, generalMidi: true, settings: { \"type\": \"FM\", \"eqFilter\": [], \"effects\": [\"note filter\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 5656.85, \"linearGain\": 1 }], \"transition\": \"normal\", \"fadeInSeconds\": 0.0125, \"fadeOutTicks\": -3, \"chord\": \"arpeggio\", \"algorithm\": \"1←(2 3 4)\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 0, \"operators\": [{ \"frequency\": \"2×\", \"amplitude\": 12 }, { \"frequency\": \"1×\", \"amplitude\": 4 }, { \"frequency\": \"20×\", \"amplitude\": 1 }, { \"frequency\": \"1×\", \"amplitude\": 0 }], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"tremolo4\" }, { \"target\": \"operatorAmplitude\", \"envelope\": \"tremolo1\", \"index\": 1 }] } },\r\n                { name: \"helicopter\", midiProgram: 125, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -0.5, settings: { \"type\": \"spectrum\", \"effects\": \"reverb\", \"transition\": \"seamless\", \"chord\": \"arpeggio\", \"filterCutoffHz\": 1414, \"filterResonance\": 14, \"filterEnvelope\": \"tremolo4\", \"spectrum\": [14, 43, 43, 57, 57, 57, 71, 71, 71, 71, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 71, 71, 71, 71, 71, 71, 71, 57, 57] } },\r\n                { name: \"applause\", midiProgram: 126, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -3, settings: { \"type\": \"spectrum\", \"effects\": \"reverb\", \"transition\": \"soft fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 14, \"filterEnvelope\": \"swell 3\", \"spectrum\": [14, 14, 29, 29, 29, 43, 43, 57, 71, 71, 86, 86, 86, 71, 71, 57, 57, 57, 71, 86, 86, 86, 86, 86, 71, 71, 57, 57, 57, 57] } },\r\n                { name: \"gunshot\", midiProgram: 127, generalMidi: true, isNoise: true, midiSubharmonicOctaves: -2, settings: { \"type\": \"spectrum\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"strum\", \"filterCutoffHz\": 1414, \"filterResonance\": 29, \"filterEnvelope\": \"twang 1\", \"spectrum\": [14, 29, 43, 43, 57, 57, 57, 71, 71, 71, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 71, 71, 71, 71, 57, 57, 57, 57, 43] } },\r\n                { name: \"scoot\", midiProgram: 92, settings: { \"type\": \"chip\", \"eqFilter\": [], \"effects\": [\"note filter\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 707.11, \"linearGain\": 4 }], \"transition\": \"normal\", \"fadeInSeconds\": 0.0125, \"fadeOutTicks\": -3, \"chord\": \"simultaneous\", \"wave\": \"double saw\", \"unison\": \"shimmer\", \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"flare 1\" }] } },\r\n                { name: \"buzz saw\", midiProgram: 30, settings: { \"type\": \"FM\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 9513.66, \"linearGain\": 0.5 }], \"effects\": [], \"transition\": \"normal\", \"fadeInSeconds\": 0.0263, \"fadeOutTicks\": -3, \"chord\": \"custom interval\", \"algorithm\": \"1←2←3←4\", \"feedbackType\": \"1⟲\", \"feedbackAmplitude\": 4, \"operators\": [{ \"frequency\": \"5×\", \"amplitude\": 13 }, { \"frequency\": \"1×\", \"amplitude\": 10 }, { \"frequency\": \"~1×\", \"amplitude\": 6 }, { \"frequency\": \"11×\", \"amplitude\": 12 }], \"envelopes\": [] } },\r\n                { name: \"mosquito\", midiProgram: 93, settings: { \"type\": \"PWM\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 2828.43, \"linearGain\": 2 }], \"effects\": [\"vibrato\"], \"vibrato\": \"shaky\", \"transition\": \"normal\", \"fadeInSeconds\": 0.0575, \"fadeOutTicks\": -6, \"chord\": \"simultaneous\", \"pulseWidth\": 4.41942, \"envelopes\": [{ \"target\": \"pulseWidth\", \"envelope\": \"tremolo6\" }] } },\r\n                { name: \"breathing\", midiProgram: 126, isNoise: true, midiSubharmonicOctaves: -1, settings: { \"type\": \"spectrum\", \"effects\": \"reverb\", \"transition\": \"hard fade\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 14, \"filterEnvelope\": \"swell 2\", \"spectrum\": [14, 14, 14, 29, 29, 29, 29, 29, 43, 29, 29, 43, 43, 43, 29, 29, 71, 43, 86, 86, 57, 100, 86, 86, 86, 86, 71, 86, 71, 57] } },\r\n                { name: \"klaxon synth\", midiProgram: 125, isNoise: true, midiSubharmonicOctaves: -1, settings: { \"type\": \"noise\", \"effects\": \"reverb\", \"transition\": \"slide\", \"chord\": \"harmony\", \"filterCutoffHz\": 2000, \"filterResonance\": 86, \"filterEnvelope\": \"steady\", \"wave\": \"buzz\" } },\r\n                { name: \"theremin\", midiProgram: 40, settings: { \"type\": \"harmonics\", \"eqFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 8000, \"linearGain\": 0.7071 }], \"effects\": [\"vibrato\", \"reverb\"], \"vibrato\": \"heavy\", \"reverb\": 33, \"transition\": \"slide in pattern\", \"fadeInSeconds\": 0.0263, \"fadeOutTicks\": -6, \"chord\": \"simultaneous\", \"harmonics\": [100, 71, 57, 43, 29, 29, 14, 14, 14, 14, 14, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"unison\": \"none\", \"envelopes\": [] } },\r\n                { name: \"sonar ping\", midiProgram: 121, settings: { \"type\": \"spectrum\", \"eqFilter\": [], \"effects\": [\"note filter\", \"reverb\"], \"noteFilter\": [{ \"type\": \"low-pass\", \"cutoffHz\": 1681.79, \"linearGain\": 0.5 }], \"reverb\": 33, \"transition\": \"normal\", \"fadeInSeconds\": 0.0125, \"fadeOutTicks\": 72, \"chord\": \"simultaneous\", \"spectrum\": [100, 43, 29, 29, 14, 14, 14, 14, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"envelopes\": [{ \"target\": \"noteFilterAllFreqs\", \"envelope\": \"twang 2\" }] } },\r\n            ])\r\n        }\r\n    ]);\r\n\r\n    public static valueToPreset(presetValue: number): Preset | null {\r\n        const categoryIndex: number = presetValue >> 6;\r\n        const presetIndex: number = presetValue & 0x3F;\r\n        return EditorConfig.presetCategories[categoryIndex].presets[presetIndex];\r\n    }\r\n\r\n    public static midiProgramToPresetValue(program: number): number | null {\r\n        for (let categoryIndex: number = 0; categoryIndex < EditorConfig.presetCategories.length; categoryIndex++) {\r\n            const category: PresetCategory = EditorConfig.presetCategories[categoryIndex];\r\n            for (let presetIndex: number = 0; presetIndex < category.presets.length; presetIndex++) {\r\n                const preset: Preset = category.presets[presetIndex];\r\n                if (preset.generalMidi && preset.midiProgram == program) return (categoryIndex << 6) + presetIndex;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static nameToPresetValue(presetName: string): number | null {\r\n        for (let categoryIndex: number = 0; categoryIndex < EditorConfig.presetCategories.length; categoryIndex++) {\r\n            const category: PresetCategory = EditorConfig.presetCategories[categoryIndex];\r\n            for (let presetIndex: number = 0; presetIndex < category.presets.length; presetIndex++) {\r\n                const preset: Preset = category.presets[presetIndex];\r\n                if (preset.name == presetName) return (categoryIndex << 6) + presetIndex;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n","// Copyright (c) 2012-2022 John Nesky and contributing authors, distributed under the MIT license, see accompanying the LICENSE.md file.\r\n\r\n// interface shared by number[], Float32Array, and other typed arrays in JavaScript.\r\ninterface NumberArray {\r\n\tlength: number;\r\n\t[index: number]: number;\r\n}\r\n\r\n// A basic FFT operation scales the overall magnitude of elements by the\r\n// square root of the length of the array, √N. Performing a forward FFT and\r\n// then an inverse FFT results in the original array, but multiplied by N.\r\n// This helper function can be used to compensate for that. \r\nexport function scaleElementsByFactor(array: NumberArray, factor: number): void {\r\n\tfor (let i: number = 0; i < array.length; i++) {\r\n\t\tarray[i] *= factor;\r\n\t}\r\n}\r\n\r\nfunction isPowerOf2(n: number): boolean {\r\n\treturn !!n && !(n & (n - 1));\r\n}\r\n\r\nfunction countBits(n: number): number {\r\n\tif (!isPowerOf2(n)) throw new Error(\"FFT array length must be a power of 2.\");\r\n\treturn Math.round(Math.log(n) / Math.log(2));\r\n}\r\n\r\n// Rearranges the elements of the array, swapping the element at an index\r\n// with an element at an index that is the bitwise reverse of the first\r\n// index in base 2. Useful for computing the FFT.\r\nfunction reverseIndexBits(array: NumberArray, fullArrayLength: number): void {\r\n\tconst bitCount: number = countBits(fullArrayLength);\r\n\tif (bitCount > 16) throw new Error(\"FFT array length must not be greater than 2^16.\");\r\n\tconst finalShift: number = 16 - bitCount;\r\n\tfor (let i: number = 0; i < fullArrayLength; i++) {\r\n\t\t// Dear Javascript: Please support bit order reversal intrinsics. Thanks! :D\r\n\t\tlet j: number;\r\n\t\tj = ((i & 0xaaaa) >> 1) | ((i & 0x5555) << 1);\r\n\t\tj = ((j & 0xcccc) >> 2) | ((j & 0x3333) << 2);\r\n\t\tj = ((j & 0xf0f0) >> 4) | ((j & 0x0f0f) << 4);\r\n\t\t\tj = ((j           >> 8) | ((j &   0xff) << 8)) >> finalShift;\r\n\t\tif (j > i) {\r\n\t\t\tlet temp: number = array[i];\r\n\t\t\tarray[i] = array[j];\r\n\t\t\tarray[j] = temp;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Provided for educational purposes. Easier to read than\r\n// fastFourierTransform(), but computes the same result.\r\n// Takes two parallel arrays representing the real and imaginary elements,\r\n// respectively, and returns an array containing two new arrays, which\r\n// contain the complex result of the transform.\r\nexport function discreteFourierTransform(realArray: NumberArray, imagArray: NumberArray): number[][] {\r\n\tconst fullArrayLength: number = realArray.length;\r\n\tif (fullArrayLength != imagArray.length) throw new Error(\"FFT arrays must be the same length.\");\r\n\tconst realOut: number[] = [];\r\n\tconst imagOut: number[] = [];\r\n\tfor (let i: number = 0; i < fullArrayLength; i++) {\r\n\t\trealOut[i] = 0.0;\r\n\t\timagOut[i] = 0.0;\r\n\t\tfor (let j: number = 0; j < fullArrayLength; j++) {\r\n\t\t\tconst radians: number = -6.2831853 * j * i / fullArrayLength;\r\n\t\t\tconst c: number = Math.cos(radians);\r\n\t\t\tconst s: number = Math.sin(radians);\r\n\t\t\trealOut[i] += realArray[j] * c - imagArray[j] * s;\r\n\t\t\timagOut[i] += realArray[j] * s + imagArray[j] * c;\r\n\t\t}\r\n\t}\r\n\treturn [realOut, imagOut];\r\n}\r\n\r\n// Performs a Fourier transform in O(N log(N)) operations. Overwrites the\r\n// input real and imaginary arrays. Can be used for both forward and inverse\r\n// transforms: swap the order of the arguments for the inverse.\r\nexport function fastFourierTransform(realArray: NumberArray, imagArray: NumberArray): void {\r\n\tconst fullArrayLength: number = realArray.length;\r\n\tif (!isPowerOf2(fullArrayLength)) throw new Error(\"FFT array length must be a power of 2.\");\r\n\tif (fullArrayLength < 4) throw new Error(\"FFT array length must be at least 4.\");\r\n\tif (fullArrayLength != imagArray.length) throw new Error(\"FFT arrays must be the same length.\");\r\n\t\t\r\n\treverseIndexBits(realArray, fullArrayLength);\r\n\treverseIndexBits(imagArray, fullArrayLength);\r\n\t\t\r\n\t// First two passes, with strides of 2 and 4, can be combined and optimized.\r\n\tfor (let startIndex: number = 0; startIndex < fullArrayLength; startIndex += 4) {\r\n\t\tconst startIndex1: number = startIndex + 1;\r\n\t\tconst startIndex2: number = startIndex + 2;\r\n\t\tconst startIndex3: number = startIndex + 3;\r\n\t\t\tconst real0: number = realArray[startIndex ];\r\n\t\tconst real1: number = realArray[startIndex1];\r\n\t\tconst real2: number = realArray[startIndex2];\r\n\t\tconst real3: number = realArray[startIndex3];\r\n\t\t\tconst imag0: number = imagArray[startIndex ];\r\n\t\tconst imag1: number = imagArray[startIndex1];\r\n\t\tconst imag2: number = imagArray[startIndex2];\r\n\t\tconst imag3: number = imagArray[startIndex3];\r\n\t\tconst realTemp0: number = real0 + real1;\r\n\t\tconst realTemp1: number = real0 - real1;\r\n\t\tconst realTemp2: number = real2 + real3;\r\n\t\tconst realTemp3: number = real2 - real3;\r\n\t\tconst imagTemp0: number = imag0 + imag1;\r\n\t\tconst imagTemp1: number = imag0 - imag1;\r\n\t\tconst imagTemp2: number = imag2 + imag3;\r\n\t\tconst imagTemp3: number = imag2 - imag3;\r\n\t\t\trealArray[startIndex ] = realTemp0 + realTemp2;\r\n\t\trealArray[startIndex1] = realTemp1 + imagTemp3;\r\n\t\trealArray[startIndex2] = realTemp0 - realTemp2;\r\n\t\trealArray[startIndex3] = realTemp1 - imagTemp3;\r\n\t\t\timagArray[startIndex ] = imagTemp0 + imagTemp2;\r\n\t\timagArray[startIndex1] = imagTemp1 - realTemp3;\r\n\t\timagArray[startIndex2] = imagTemp0 - imagTemp2;\r\n\t\timagArray[startIndex3] = imagTemp1 + realTemp3;\r\n\t}\r\n\t\t\r\n\tfor (let stride: number = 8; stride <= fullArrayLength; stride += stride) {\r\n\t\tconst halfLength: number = stride >>> 1;\r\n\t\tconst radiansIncrement: number = Math.PI * 2.0 / stride;\r\n\t\tconst cosIncrement: number = Math.cos(radiansIncrement);\r\n\t\tconst sinIncrement: number = Math.sin(radiansIncrement);\r\n\t\tconst oscillatorMultiplier: number = 2.0 * cosIncrement;\r\n\t\tfor (let startIndex: number = 0; startIndex < fullArrayLength; startIndex += stride) {\r\n\t\t\tlet c: number = 1.0;\r\n\t\t\tlet s: number = 0.0;\r\n\t\t\tlet cPrev: number = cosIncrement;\r\n\t\t\tlet sPrev: number = sinIncrement;\r\n\t\t\tconst secondHalf: number = startIndex + halfLength;\r\n\t\t\tfor (let i: number = startIndex; i < secondHalf; i++) {\r\n\t\t\t\tconst j: number = i + halfLength;\r\n\t\t\t\tconst real0: number = realArray[i];\r\n\t\t\t\tconst imag0: number = imagArray[i];\r\n\t\t\t\tconst real1: number = realArray[j] * c - imagArray[j] * s;\r\n\t\t\t\tconst imag1: number = realArray[j] * s + imagArray[j] * c;\r\n\t\t\t\trealArray[i] = real0 + real1;\r\n\t\t\t\timagArray[i] = imag0 + imag1;\r\n\t\t\t\trealArray[j] = real0 - real1;\r\n\t\t\t\timagArray[j] = imag0 - imag1;\r\n\t\t\t\tconst cTemp: number = oscillatorMultiplier * c - cPrev;\r\n\t\t\t\tconst sTemp: number = oscillatorMultiplier * s - sPrev;\r\n\t\t\t\tcPrev = c;\r\n\t\t\t\tsPrev = s;\r\n\t\t\t\tc = cTemp;\r\n\t\t\t\ts = sTemp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Computes the Fourier transform from an array of real-valued time-domain\r\n// samples. The output is specially formatted for space efficieny: elements\r\n// 0 through N/2 represent cosine wave amplitudes in ascending frequency,\r\n// and elements N/2+1 through N-1 represent sine wave amplitudes in\r\n// descending frequency. Overwrites the input array.\r\nexport function forwardRealFourierTransform(array: NumberArray): void {\r\n\tconst fullArrayLength: number = array.length;\r\n\tconst totalPasses: number = countBits(fullArrayLength);\r\n\tif (fullArrayLength < 4) throw new Error(\"FFT array length must be at least 4.\");\r\n\t\t\r\n\treverseIndexBits(array, fullArrayLength);\r\n\t\t\r\n\t// First and second pass.\r\n\tfor (let index: number = 0; index < fullArrayLength; index += 4) {\r\n\t\tconst index1: number = index + 1;\r\n\t\tconst index2: number = index + 2;\r\n\t\tconst index3: number = index + 3;\r\n\t\t\tconst real0: number = array[index ];\r\n\t\tconst real1: number = array[index1];\r\n\t\tconst real2: number = array[index2];\r\n\t\tconst real3: number = array[index3];\r\n\t\t// no imaginary elements yet since the input is fully real.\r\n\t\tconst tempA: number = real0 + real1;\r\n\t\tconst tempB: number = real2 + real3;\r\n\t\t\tarray[index ] = tempA + tempB;\r\n\t\tarray[index1] = real0 - real1;\r\n\t\tarray[index2] = tempA - tempB;\r\n\t\tarray[index3] = real2 - real3;\r\n\t}\r\n\t\t\r\n\t// Third pass.\r\n\tconst sqrt2over2: number = Math.sqrt(2.0) / 2.0;\r\n\tfor (let index: number = 0; index < fullArrayLength; index += 8) {\r\n\t\tconst index1: number = index + 1;\r\n\t\tconst index3: number = index + 3;\r\n\t\tconst index4: number = index + 4;\r\n\t\tconst index5: number = index + 5;\r\n\t\tconst index7: number = index + 7;\r\n\t\t\tconst real0: number = array[index ];\r\n\t\tconst real1: number = array[index1];\r\n\t\tconst imag3: number = array[index3];\r\n\t\tconst real4: number = array[index4];\r\n\t\tconst real5: number = array[index5];\r\n\t\tconst imag7: number = array[index7];\r\n\t\tconst tempA: number = (real5 - imag7) * sqrt2over2;\r\n\t\tconst tempB: number = (real5 + imag7) * sqrt2over2;\r\n\t\t\tarray[index ] = real0 + real4;\r\n\t\tarray[index1] = real1 + tempA;\r\n\t\tarray[index3] = real1 - tempA;\r\n\t\tarray[index4] = real0 - real4;\r\n\t\tarray[index5] = tempB - imag3;\r\n\t\tarray[index7] = tempB + imag3;\r\n\t}\r\n\t\t\r\n\t// Handle remaining passes.\r\n\tfor (let pass: number = 3; pass < totalPasses; pass++) {\r\n\t\tconst subStride: number = 1 << pass;\r\n\t\tconst midSubStride: number = subStride >> 1;\r\n\t\tconst stride: number = subStride << 1;\r\n\t\tconst radiansIncrement: number = Math.PI * 2.0 / stride;\r\n\t\tconst cosIncrement: number = Math.cos(radiansIncrement);\r\n\t\tconst sinIncrement: number = Math.sin(radiansIncrement);\r\n\t\tconst oscillatorMultiplier: number = 2.0 * cosIncrement;\r\n\t\tfor (let startIndex: number = 0; startIndex < fullArrayLength; startIndex += stride) {\r\n\t\t\tconst startIndexA: number = startIndex;\r\n\t\t\tconst startIndexB: number = startIndexA + subStride;\r\n\t\t\tconst stopIndex: number = startIndexB + subStride;\r\n\t\t\tconst realStartA: number = array[startIndexA];\r\n\t\t\tconst realStartB: number = array[startIndexB];\r\n\t\t\tarray[startIndexA] = realStartA + realStartB;\r\n\t\t\tarray[startIndexB] = realStartA - realStartB;\r\n\t\t\tlet c: number = cosIncrement;\r\n\t\t\tlet s: number = -sinIncrement;\r\n\t\t\tlet cPrev: number = 1.0;\r\n\t\t\tlet sPrev: number = 0.0;\r\n\t\t\tfor (let index: number = 1; index < midSubStride; index++) {\r\n\t\t\t\tconst indexA0: number = startIndexA + index;\r\n\t\t\t\tconst indexA1: number = startIndexB - index;\r\n\t\t\t\tconst indexB0: number = startIndexB + index;\r\n\t\t\t\t\tconst indexB1: number = stopIndex   - index;\r\n\t\t\t\tconst real0: number = array[indexA0];\r\n\t\t\t\tconst imag0: number = array[indexA1];\r\n\t\t\t\tconst real1: number = array[indexB0];\r\n\t\t\t\tconst imag1: number = array[indexB1];\r\n\t\t\t\tconst tempA: number = real1 * c + imag1 * s;\r\n\t\t\t\tconst tempB: number = real1 * s - imag1 * c;\r\n\t\t\t\tarray[indexA0] = real0 + tempA;\r\n\t\t\t\tarray[indexA1] = real0 - tempA;\r\n\t\t\t\t\tarray[indexB0] =-imag0 - tempB;\r\n\t\t\t\tarray[indexB1] = imag0 - tempB;\r\n\t\t\t\tconst cTemp: number = oscillatorMultiplier * c - cPrev;\r\n\t\t\t\tconst sTemp: number = oscillatorMultiplier * s - sPrev;\r\n\t\t\t\tcPrev = c;\r\n\t\t\t\tsPrev = s;\r\n\t\t\t\tc = cTemp;\r\n\t\t\t\ts = sTemp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Computes the inverse Fourier transform from a specially formatted array of\r\n// scalar values. Elements 0 through N/2 are expected to be the real values of\r\n// the corresponding complex elements, representing cosine wave amplitudes in\r\n// ascending frequency, and elements N/2+1 through N-1 correspond to the\r\n// imaginary values, representing sine wave amplitudes in descending frequency.\r\n// Generates real-valued time-domain samples. Overwrites the input array.\r\nexport function inverseRealFourierTransform(array: NumberArray, fullArrayLength: number): void {\r\n\tconst totalPasses: number = countBits(fullArrayLength);\r\n\tif (fullArrayLength < 4) throw new Error(\"FFT array length must be at least 4.\");\r\n\r\n\t// Perform all but the last few passes in reverse.\r\n\tfor (let pass: number = totalPasses - 1; pass >= 2; pass--) {\r\n\t\tconst subStride: number = 1 << pass;\r\n\t\tconst midSubStride: number = subStride >> 1;\r\n\t\tconst stride: number = subStride << 1;\r\n\t\tconst radiansIncrement: number = Math.PI * 2.0 / stride;\r\n\t\tconst cosIncrement: number = Math.cos(radiansIncrement);\r\n\t\tconst sinIncrement: number = Math.sin(radiansIncrement);\r\n\t\tconst oscillatorMultiplier: number = 2.0 * cosIncrement;\r\n\t\t\t\r\n\t\tfor (let startIndex: number = 0; startIndex < fullArrayLength; startIndex += stride) {\r\n\t\t\tconst startIndexA: number = startIndex;\r\n\t\t\tconst midIndexA: number = startIndexA + midSubStride;\r\n\t\t\tconst startIndexB: number = startIndexA + subStride;\r\n\t\t\tconst midIndexB: number = startIndexB + midSubStride;\r\n\t\t\tconst stopIndex: number = startIndexB + subStride;\r\n\t\t\tconst realStartA: number = array[startIndexA];\r\n\t\t\tconst imagStartB: number = array[startIndexB];\r\n\t\t\tarray[startIndexA] = realStartA + imagStartB;\r\n\t\t\tarray[midIndexA] *= 2;\r\n\t\t\tarray[startIndexB] = realStartA - imagStartB;\r\n\t\t\tarray[midIndexB] *= 2;\r\n\t\t\tlet c: number = cosIncrement;\r\n\t\t\tlet s: number = -sinIncrement;\r\n\t\t\tlet cPrev: number = 1.0;\r\n\t\t\tlet sPrev: number = 0.0;\r\n\t\t\tfor (let index: number = 1; index < midSubStride; index++) {\r\n\t\t\t\tconst indexA0: number = startIndexA + index;\r\n\t\t\t\tconst indexA1: number = startIndexB - index;\r\n\t\t\t\tconst indexB0: number = startIndexB + index;\r\n\t\t\t\t\tconst indexB1: number = stopIndex   - index;\r\n\t\t\t\tconst real0: number = array[indexA0];\r\n\t\t\t\tconst real1: number = array[indexA1];\r\n\t\t\t\tconst imag0: number = array[indexB0];\r\n\t\t\t\tconst imag1: number = array[indexB1];\r\n\t\t\t\tconst tempA: number = real0 - real1;\r\n\t\t\t\tconst tempB: number = imag0 + imag1;\r\n\t\t\t\tarray[indexA0] = real0 + real1;\r\n\t\t\t\tarray[indexA1] = imag1 - imag0;\r\n\t\t\t\tarray[indexB0] = tempA * c - tempB * s;\r\n\t\t\t\tarray[indexB1] = tempB * c + tempA * s;\r\n\t\t\t\tconst cTemp: number = oscillatorMultiplier * c - cPrev;\r\n\t\t\t\tconst sTemp: number = oscillatorMultiplier * s - sPrev;\r\n\t\t\t\tcPrev = c;\r\n\t\t\t\tsPrev = s;\r\n\t\t\t\tc = cTemp;\r\n\t\t\t\ts = sTemp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t/*\r\n\t// Commented out this block (and compensated with an extra pass above)\r\n\t// because it's slower in my testing so far.\r\n\t// Pass with stride 8.\r\n\tconst sqrt2over2: number = Math.sqrt(2.0) / 2.0;\r\n\tfor (let index: number = 0; index < fullArrayLength; index += 8) {\r\n\t\tconst index1: number = index + 1;\r\n\t\tconst index2: number = index + 2;\r\n\t\tconst index3: number = index + 3;\r\n\t\tconst index4: number = index + 4;\r\n\t\tconst index5: number = index + 5;\r\n\t\tconst index6: number = index + 6;\r\n\t\tconst index7: number = index + 7;\r\n\t\tconst real0: number = array[index ];\r\n\t\tconst real1: number = array[index1];\r\n\t\tconst real2: number = array[index2];\r\n\t\tconst real3: number = array[index3];\r\n\t\tconst imag4: number = array[index4];\r\n\t\tconst imag5: number = array[index5];\r\n\t\tconst imag6: number = array[index6];\r\n\t\tconst imag7: number = array[index7];\r\n\t\tconst tempA: number = real1 - real3;\r\n\t\tconst tempB: number = imag5 + imag7;\r\n\t\tarray[index ] = real0 + imag4;\r\n\t\tarray[index1] = real1 + real3;\r\n\t\tarray[index2] = real2 * 2;\r\n\t\tarray[index3] = imag7 - imag5;\r\n\t\tarray[index4] = real0 - imag4;\r\n\t\tarray[index5] = (tempA + tempB) * sqrt2over2;\r\n\t\tarray[index6] = imag6 * 2;\r\n\t\tarray[index7] = (tempB - tempA) * sqrt2over2;\r\n\t}\r\n\t*/\r\n\t// The final passes with strides 4 and 2, combined into one loop.\r\n\tfor (let index: number = 0; index < fullArrayLength; index += 4) {\r\n\t\tconst index1: number = index + 1;\r\n\t\tconst index2: number = index + 2;\r\n\t\tconst index3: number = index + 3;\r\n\t\t\tconst real0: number = array[index ];\r\n\t\tconst real1: number = array[index1] * 2;\r\n\t\tconst imag2: number = array[index2];\r\n\t\tconst imag3: number = array[index3] * 2;\r\n\t\tconst tempA: number = real0 + imag2;\r\n\t\tconst tempB: number = real0 - imag2;\r\n\t\t\tarray[index ] = tempA + real1;\r\n\t\tarray[index1] = tempA - real1;\r\n\t\tarray[index2] = tempB + imag3;\r\n\t\tarray[index3] = tempB - imag3;\r\n\t}\r\n\t\t\r\n\treverseIndexBits(array, fullArrayLength);\r\n}\r\n","// Copyright (c) 2012-2022 John Nesky and contributing authors, distributed under the MIT license, see accompanying the LICENSE.md file.\r\n\r\nexport class Deque<T> {\r\n\tprivate _capacity: number = 1;\r\n\tprivate _buffer: Array<T | undefined> = [undefined];\r\n\tprivate _mask: number = 0;\r\n\tprivate _offset: number = 0;\r\n\tprivate _count: number = 0;\r\n\r\n\tpublic pushFront(element: T): void {\r\n\t\tif (this._count >= this._capacity) this._expandCapacity();\r\n\t\tthis._offset = (this._offset - 1) & this._mask;\r\n\t\tthis._buffer[this._offset] = element;\r\n\t\tthis._count++;\r\n\t}\r\n\tpublic pushBack(element: T): void {\r\n\t\tif (this._count >= this._capacity) this._expandCapacity();\r\n\t\tthis._buffer[(this._offset + this._count) & this._mask] = element;\r\n\t\tthis._count++;\r\n\t}\r\n\tpublic popFront(): T {\r\n\t\tif (this._count <= 0) throw new Error(\"No elements left to pop.\");\r\n\t\tconst element: T = <T>this._buffer[this._offset];\r\n\t\tthis._buffer[this._offset] = undefined;\r\n\t\tthis._offset = (this._offset + 1) & this._mask;\r\n\t\tthis._count--;\r\n\t\treturn element;\r\n\t}\r\n\tpublic popBack(): T {\r\n\t\tif (this._count <= 0) throw new Error(\"No elements left to pop.\");\r\n\t\tthis._count--;\r\n\t\tconst index: number = (this._offset + this._count) & this._mask;\r\n\t\tconst element: T = <T>this._buffer[index];\r\n\t\tthis._buffer[index] = undefined;\r\n\t\treturn element;\r\n\t}\r\n\tpublic peakFront(): T {\r\n\t\tif (this._count <= 0) throw new Error(\"No elements left to pop.\");\r\n\t\treturn <T>this._buffer[this._offset];\r\n\t}\r\n\tpublic peakBack(): T {\r\n\t\tif (this._count <= 0) throw new Error(\"No elements left to pop.\");\r\n\t\treturn <T>this._buffer[(this._offset + this._count - 1) & this._mask];\r\n\t}\r\n\tpublic count(): number {\r\n\t\treturn this._count;\r\n\t}\r\n\tpublic set(index: number, element: T): void {\r\n\t\tif (index < 0 || index >= this._count) throw new Error(\"Invalid index\");\r\n\t\tthis._buffer[(this._offset + index) & this._mask] = element;\r\n\t}\r\n\tpublic get(index: number): T {\r\n\t\tif (index < 0 || index >= this._count) throw new Error(\"Invalid index\");\r\n\t\treturn <T>this._buffer[(this._offset + index) & this._mask];\r\n\t}\r\n\tpublic remove(index: number): void {\r\n\t\tif (index < 0 || index >= this._count) throw new Error(\"Invalid index\");\r\n\t\tif (index <= (this._count >> 1)) {\r\n\t\t\twhile (index > 0) {\r\n\t\t\t\tthis.set(index, this.get(index - 1));\r\n\t\t\t\tindex--;\r\n\t\t\t}\r\n\t\t\tthis.popFront();\r\n\t\t} else {\r\n\t\t\tindex++;\r\n\t\t\twhile (index < this._count) {\r\n\t\t\t\tthis.set(index - 1, this.get(index));\r\n\t\t\t\tindex++;\r\n\t\t\t}\r\n\t\t\tthis.popBack();\r\n\t\t}\r\n\t}\r\n\tprivate _expandCapacity(): void {\r\n\t\tif (this._capacity >= 0x40000000) throw new Error(\"Capacity too big.\");\r\n\t\tthis._capacity = this._capacity << 1;\r\n\t\tconst oldBuffer: Array<T | undefined> = this._buffer;\r\n\t\tconst newBuffer: Array<T | undefined> = new Array(this._capacity);\r\n\t\tconst size: number = this._count | 0;\r\n\t\tconst offset: number = this._offset | 0;\r\n\t\tfor (let i = 0; i < size; i++) {\r\n\t\t\tnewBuffer[i] = oldBuffer[(offset + i) & this._mask];\r\n\t\t}\r\n\t\tfor (let i = size; i < this._capacity; i++) {\r\n\t\t\tnewBuffer[i] = undefined;\r\n\t\t}\r\n\t\tthis._offset = 0;\r\n\t\tthis._buffer = newBuffer;\r\n\t\tthis._mask = this._capacity - 1;\r\n\t}\r\n}","/*\r\nThis file contains code to compute digital audio filter coefficients based on\r\nthe desired type, cutoff frequency, and other parameters. You can use these\r\ncoefficients to apply the filter to audio samples. It also contains code to\r\nanalyze these filters, which is useful for graphically displaying their effects.\r\n\r\nAll of the filters in this file are known as \"Infinite Impulse Response\" or IIR\r\nfilters, because older output samples contribute feedback to newer output\r\nsamples and thus contribute to all future samples, although typically filters\r\nare design to reduce the contribution of older samples over time.\r\n\r\nLow-pass filters aka high-cut filters preserve audio signals below the cutoff\r\nfrequency, and attenuate audio signals above the cutoff frequency. High-pass\r\nfilters aka low-cut filters are the reverse. All-pass filters do not affect the\r\nvolume of the signal at all but induce phase changes above the cutoff frequency.\r\nPeak/Notch filters maintain the volume on either side of the cutoff frequency,\r\nbut raise or lower the volume at that frequency. \r\n\r\nThe number of old samples used in the filter determines the \"order\" of the\r\nfilter. First-order filters generally have shallower slopes, and second-order\r\nfilters generally have steeper slopes and can be configured to \"resonate\",\r\nmeaning they have a louder peak at the cutoff frequency. This file contains\r\nfirst-order filters and second-order filters, meaning one or two older samples\r\nare involved, as well as the current input sample.\r\n\r\nThe class FilterCoefficients is defined lower in this file. You can use it to\r\nset up a first order filter like this:\r\n\r\n\tconst cutoffRadiansPerSample: number = 2 * Math.PI * cutoffHz / sampleRate;\r\n\tconst filter: FilterCoefficients = new FilterCoefficients();\r\n\tfilter.lowPass1stOrderButterworth(cutoffRadiansPerSample);\r\n\t// output sample coefficients are conventionally called a0, a1, etc. Note\r\n\t// that a[0] is typically normalized to 1.0 and need not be used directly.\r\n\tconst a: number[] = filter.a;\r\n\t// input sample coefficients are conventionally called b0, b1, etc\r\n\tconst b: number[] = filter.b;\r\n\t// filter input samples, x[0] is the most recent, x[1] is the previous one, etc.\r\n\tconst x: number[] = [0, 0, 0];\r\n\t// filter output samples, y[0] will be computed by the filter based on input\r\n\t// samples and older output samples.\r\n\tconst y: number[] = [0, 0, 0];\r\n\r\nThen to apply the first-order filter to samples inside a loop, using the current\r\ninput sample (x[0]) as well as previous input and output samples, do this:\r\n\r\n\t// Compute the next output sample y[0]:\r\n\ty[0] = b[0] * x[0] + b[1] * x[1] - a[1] * y[1];\r\n\t// Remember the input and output samples for next time:\r\n\tx[1] = x[0];\r\n\ty[1] = y[0];\r\n\r\n2nd order filters are similar, but have more parameters and require more old\r\nsamples:\r\n\r\n\t// Compute the next output sample y[0]:\r\n\ty[0] = b[0] * x[0] + b[1] * x[1] + b[2] * x[2] - a[1] * y[1] - a[2] * y[2];\r\n\t// Remember the input and output samples for next time:\r\n\tx[2] = x[1];\r\n\tx[1] = x[0];\r\n\ty[2] = y[1];\r\n\ty[1] = y[0];\r\n\r\nYou can compose multiple filters into a higher order filter, although doing so\r\nreduces the numerical stability of the filter:\r\n\r\n\tfilter3.combination(filter1, filter2);\r\n\t// filter3.order will equal: filter1.order + filter2.order\r\n\t// The number of coefficients in filter3.a and filter3.b will be: order + 1\r\n\r\nThis file also contains a class called FrequencyResponse. You can use it to\r\ndetermine how much gain or attenuation a filter would apply to sounds at a\r\nspecific input frequency, as well as the phase offset:\r\n\r\n\tconst inputRadians: number = 2 * Math.PI * cutoffHz / sampleRate;\r\n\tconst response: FrequencyResponse = new FrequencyResponse();\r\n\tresponse.analyze(filter, inputRadians);\r\n\tconst gainResponse = response.magnitude();\r\n\tconst phaseResponse = response.angle();\r\n\r\nThat's basically all you need to know to use this code, but I'll also explain\r\nhow the analysis works.\r\n\r\nA first-order digital IIR filter is ordinarily implemented in a form like this:\r\n\r\n\toutput = inputCoeff * input + prevInputCoeff * prevInput - prevOutputCoeff * prevOutput;\r\n\r\nIf we adopt standard naming conventions for audio filters, this same code would\r\ninstead look like:\r\n\r\n\t// x0 = current input, x1 = prevInput, y0 = current output, y1 = prevOutput\r\n\ty0 = b0*x0 + b1*x1 - a1*y1;\r\n\r\nLeaving behind the world of code for a moment and entering the world of algebra,\r\nwe can rewrite this equation by moving all the output terms to the left side,\r\nand we can add a coefficient to the y0 term called a0 (which is typically\r\nnormalized to 1.0, which is why I didn't bother including it until now):\r\n\r\n\ta0*y0 + a1*y1 = b0*x0 + b1*x1\r\n\r\nThis is known as the symmetrical form of the filter, and it will help us analyze\r\nthe impact of the filter on an input audio signal. Here's a lesson that helped\r\nme understand the symmetrical form:\r\nhttps://web.archive.org/web/20200626183458/http://123.physics.ucdavis.edu/week_5_files/filters/digital_filter.pdf\r\n\r\nThe end of that lesson introduces a concept called the \"delay operator\" which\r\nlooks like \"z^-1\", which (magically) turns a sample into the previous sample\r\nwhen you multiply them. For example:\r\n\r\n\tx0 * z^-1 = x1\r\n\r\nThe lesson doesn't explain how it actually works. Audio signals aren't always\r\npredictable, which means that you generally can't do math on a single sample to\r\ncompute what the previous sample was. However, some audio signals ARE\r\npredictable, such as pure sine waves. Fortunately, all audio signals can be\r\nbroken down into a sum of independent sine waves. We can pick one sine wave at a\r\ntime, and use it to analyze the filter's impact on waves at that frequency. In\r\npractice, this tells us what the filter will do to unpredictable input samples\r\nthat contain a partial sine wave at that frequency.\r\n\r\nTechnically, you can't just use a single sine wave sample to determine the\r\nprevious sine wave sample, because each possible value is passed going upwards\r\nand downwards once per period and the direction is ambigous. This is where we\r\nneed to move into the complex number domain, where the real and imaginary\r\ncomponents can provide enough information to compute the previous position on\r\nthe input signal. So now instead of talking about sine waves, we're talking\r\nabout waves where the imaginary component is a sine wave and the real component\r\nis a cosine wave at the same frequency. Together, they trace around a unit\r\ncircle in the complex domain, and each sample is just a consistent rotation\r\napplied to the previous sample. The \"delay operator\" described above, z^-1, is\r\nthis same rotation applied in reverse, and it can be computed as:\r\n\r\n\tz^-1 = cos(radiansPerSample) - i * sin(radiansPerSample)\r\n\r\nMath nerds may be interested to know that \"Euler's formula\" was used here, but\r\nexplaining what that means is probably beyond the scope of this documentation\r\naside from noting that a complex number on the unit circle represents a 2D\r\nrotation that you can apply via multiplication.\r\n\r\nNow we can rewrite the symmetrical form using the delay operator and algebra:\r\n\r\n\ta0*y0 + a1*y0*z^-1 = b0*x0 + b1*x0*z^-1\r\n\ty0 * (a0 + a1*z^-1) = x0 * (b0 + b1*z^-1)\r\n\ty0 = x0 * (b0 + b1*z^-1) / (a0 + a1*z^-1)\r\n\ty0 / x0 = (b0 + b1*z^-1) / (a0 + a1*z^-1)\r\n\r\nThat last equation expresses the relationship between the input and output\r\nsignals (y0/x0) in terms of the filter coefficients and delay operator. At this\r\npoint, the specific values of the input and output samples don't even matter!\r\nThis is called the \"transfer function\", and it's conventionally named \"H(z)\":\r\n\r\n\tH(z) = (b0 + b1*z^-1) / (a0 + a1*z^-1)\r\n\r\nIf you plug in actual filter coefficients and express the delay operators as\r\ncomplex numbers with the appropriate trigonometry functions, the transfer\r\nfunction can be computed and produces a complex number that represents the\r\nrelationship between the input and output signals, whose magnitude represents\r\nthe volume gain (or attenuation) of signals at that frequency, and whose angle\r\nrepresents how much phase shift is applied by the filter to signals at that\r\nfrequency.\r\n\r\n(Note that in order to compute the transfer function, you'll need to do\r\nsomething about the complex number in the denominator. It turns out you can turn\r\nthe denominator into a real number by multiplying both the numerator and\r\ndenominator by the complex conjugate of the denominator, which is just the\r\ndenominator with the imaginary component negated.)\r\n\r\nFinally, I'll list some of the links that helped me understand filters and\r\nprovided some of the algorithms I that use here.\r\n\r\nHere's where I found accurate 2nd order low-pass and high-pass digital filters:\r\nhttps://web.archive.org/web/20120531011328/http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt\r\n\r\nThis page is how I found a link to the cookbook article above. It claims these\r\nfilters are Butterworth filters:\r\nhttp://web.archive.org/web/20191213120120/https://crypto.stanford.edu/~blynn/sound/analog.html\r\n\r\nI found the first-order digital Butterworth filter coefficients at:\r\nhttps://www.researchgate.net/publication/338022014_Digital_Implementation_of_Butterworth_First-Order_Filter_Type_IIR\r\n\r\nThis meta-paper helped me understand how to make 2nd order peak/notch filters:\r\nhttps://web.archive.org/web/20170706085655/https://www.thesounddesign.com/MIO/EQ-Coefficients.pdf\r\n\r\nBeepBox originally used simpler low-pass filters that I adapted from SFXR:\r\nhttps://www.drpetter.se/project_sfxr.html\r\nFor low cutoff frequencies, the simpler filters and the Butterworth filters are\r\nnearly identical, but when closer to the nyquist frequency the simpler filters\r\ncreate extra resonance.\r\n*/\r\n\r\nexport class FilterCoefficients {\r\n\tpublic readonly a: number[] = [1.0]; // output coefficients (negated, keep a[0]=1)\r\n\tpublic readonly b: number[] = [1.0]; // input coefficients\r\n\tpublic order: number = 0;\r\n\t\r\n\tpublic linearGain0thOrder(linearGain: number): void {\r\n\t\t//a[0] = 1.0; // a0 should always be normalized to 1.0, no need to assign it directly.\r\n\t\tthis.b[0] = linearGain;\r\n\t\tthis.order = 0;\r\n\t}\r\n\t\r\n\tpublic lowPass1stOrderButterworth(cornerRadiansPerSample: number): void {\r\n\t\t// First-order Butterworth low-pass filter according to:\r\n\t\t// https://www.researchgate.net/publication/338022014_Digital_Implementation_of_Butterworth_First-Order_Filter_Type_IIR\r\n\t\t// A butterworth filter is one where the amplitude response is equal to:\r\n\t\t// 1 / √(1 + (freq / cutoffFreq)^(2 * order))\r\n\t\tconst g: number = 1.0 / Math.tan(cornerRadiansPerSample * 0.5);\r\n\t\tconst a0: number = 1.0 + g;\r\n\t\tthis.a[1] = (1.0 - g) / a0;\r\n\t\tthis.b[1] = this.b[0] = 1 / a0;\r\n\t\tthis.order = 1;\r\n\t}\r\n\t\r\n\tpublic lowPass1stOrderSimplified(cornerRadiansPerSample: number): void {\r\n\t\t// The output of this filter is nearly identical to the 1st order\r\n\t\t// Butterworth low-pass above, except if the cutoff is set to nyquist/3,\r\n\t\t// then the output is the same as the input, and if the cutoff is higher\r\n\t\t// than that, then the output actually resonates at high frequencies\r\n\t\t// instead of attenuating.\r\n\t\t// I'm guessing this filter was converted from analog to digital using\r\n\t\t// the \"matched z-transform\" method instead of the \"bilinear transform\"\r\n\t\t// method. The difference is that the bilinear transform warps\r\n\t\t// frequencies so that the lowpass response of zero at analogue ∞hz maps\r\n\t\t// to the digital nyquist frequency, whereas the matched z-transform\r\n\t\t// preserves the frequency of the filter response but also adds the\r\n\t\t// reflected response from above the nyquist frequency.\r\n\t\tconst g: number = 2.0 * Math.sin(cornerRadiansPerSample * 0.5);\r\n\t\tthis.a[1] = g - 1.0;\r\n\t\tthis.b[0] = g;\r\n\t\tthis.b[1] = 0.0;\r\n\t\t/*\r\n\t\t// Alternatively:\r\n\t\tconst g: number = 1.0 / (2.0 * Math.sin(cornerRadiansPerSample / 2));\r\n\t\tconst a0: number = g;\r\n\t\tthis.a[1] = (1.0 - g) / a0;\r\n\t\tthis.b[0] = 1.0 / a0;\r\n\t\tthis.b[1] = 0.0 / a0;\r\n\t\t*/\r\n\t\tthis.order = 1;\r\n\t}\r\n\t\r\n\tpublic highPass1stOrderButterworth(cornerRadiansPerSample: number): void {\r\n\t\t// First-order Butterworth high-pass filter according to:\r\n\t\t// https://www.researchgate.net/publication/338022014_Digital_Implementation_of_Butterworth_First-Order_Filter_Type_IIR\r\n\t\tconst g: number = 1.0 / Math.tan(cornerRadiansPerSample * 0.5);\r\n\t\tconst a0: number = 1.0 + g;\r\n\t\tthis.a[1] = (1.0 - g) / a0;\r\n\t\tthis.b[0] = g / a0;\r\n\t\tthis.b[1] = -g / a0;\r\n\t\tthis.order = 1;\r\n\t}\r\n\t/*\r\n\tpublic highPass1stOrderSimplified(cornerRadiansPerSample: number): void {\r\n\t\t// The output of this filter is nearly identical to the 1st order\r\n\t\t// Butterworth high-pass above, except it resonates when the cutoff\r\n\t\t// appoaches the nyquist.\r\n\t\tconst g: number = 2.0 * Math.sin(cornerRadiansPerSample * 0.5);\r\n\t\tthis.a[1] = g - 1.0;\r\n\t\tthis.b[0] = 1.0;\r\n\t\tthis.b[1] = -1.0;\r\n\t\tthis.order = 1;\r\n\t}\r\n\t*/\r\n\tpublic highShelf1stOrder(cornerRadiansPerSample: number, shelfLinearGain: number): void {\r\n\t\t// I had trouble figuring this one out because I couldn't find any\r\n\t\t// online algorithms that I understood. There are 3 degrees of freedom\r\n\t\t// and I could narrow down a couple of them based on the desired gain at\r\n\t\t// DC and nyquist, but getting the cutoff frequency correct took a\r\n\t\t// little bit of trial and error in my attempts to interpret page 53 of\r\n\t\t// this chapter: http://www.music.mcgill.ca/~ich/classes/FiltersChap2.pdf\r\n\t\t// Obviously I don't fully understand the bilinear transform yet!\r\n\t\tconst tan: number = Math.tan(cornerRadiansPerSample * 0.5);\r\n\t\tconst sqrtGain: number = Math.sqrt(shelfLinearGain);\r\n\t\tconst g: number = (tan * sqrtGain - 1) / (tan * sqrtGain + 1.0);\r\n\t\tconst a0: number = 1.0;\r\n\t\tthis.a[1] = g / a0;\r\n\t\tthis.b[0] = (1.0 + g + shelfLinearGain * (1.0 - g)) / (2.0 * a0);\r\n\t\tthis.b[1] = (1.0 + g - shelfLinearGain * (1.0 - g)) / (2.0 * a0);\r\n\t\tthis.order = 1;\r\n\t}\r\n\t\r\n\tpublic allPass1stOrderInvertPhaseAbove(cornerRadiansPerSample: number): void {\r\n\t\tconst g: number = (Math.sin(cornerRadiansPerSample) - 1.0) / Math.cos(cornerRadiansPerSample);\r\n\t\tthis.a[1] = g;\r\n\t\tthis.b[0] = g;\r\n\t\tthis.b[1] = 1.0;\r\n\t\tthis.order = 1;\r\n\t}\r\n\t\r\n\t/*\r\n\t// I haven't found a practical use for this version of the all pass filter.\r\n\t// It seems to create a weird subharmonic when used in a delay feedback loop.\r\n\tpublic allPass1stOrderInvertPhaseBelow(cornerRadiansPerSample: number): void {\r\n\t\tconst g: number = (Math.sin(cornerRadiansPerSample) - 1.0) / Math.cos(cornerRadiansPerSample);\r\n\t\tthis.a[1] = g;\r\n\t\tthis.b[0] = -g;\r\n\t\tthis.b[1] = -1.0;\r\n\t\tthis.order = 1;\r\n\t}\r\n\t*/\r\n\t\r\n\tpublic allPass1stOrderFractionalDelay(delay: number) {\r\n\t\t// Very similar to allPass1stOrderInvertPhaseAbove, but configured\r\n\t\t// differently and for a different purpose! Useful for interpolating\r\n\t\t// between samples in a delay line.\r\n\t\tconst g: number = (1.0 - delay) / (1.0 + delay);\r\n\t\tthis.a[1] = g;\r\n\t\tthis.b[0] = g;\r\n\t\tthis.b[1] = 1.0;\r\n\t\tthis.order = 1;\r\n\t}\r\n\t\r\n\tpublic lowPass2ndOrderButterworth(cornerRadiansPerSample: number, peakLinearGain: number): void {\r\n\t\t// This is Butterworth if peakLinearGain=1/√2 according to:\r\n\t\t// http://web.archive.org/web/20191213120120/https://crypto.stanford.edu/~blynn/sound/analog.html\r\n\t\t// An interesting property is that if peakLinearGain=1/16 then the\r\n\t\t// output resembles a first-order lowpass at a cutoff 4 octaves lower,\r\n\t\t// although it gets distorted near the nyquist.\r\n\t\tconst alpha: number = Math.sin(cornerRadiansPerSample) / (2.0 * peakLinearGain);\r\n\t\tconst cos: number = Math.cos(cornerRadiansPerSample);\r\n\t\tconst a0: number = 1.0 + alpha;\r\n\t\tthis.a[1] = -2.0*cos / a0;\r\n\t\tthis.a[2] = (1 - alpha) / a0;\r\n\t\tthis.b[2] = this.b[0] = (1 - cos) / (2.0*a0);\r\n\t\tthis.b[1] = (1 - cos) / a0;\r\n\t\tthis.order = 2;\r\n\t}\r\n\t\r\n\tpublic lowPass2ndOrderSimplified(cornerRadiansPerSample: number, peakLinearGain: number): void {\r\n\t\t// This filter is adapted from the one in the SFXR source code:\r\n\t\t// https://www.drpetter.se/project_sfxr.html\r\n\t\t// The output is nearly identical to the resonant Butterworth low-pass\r\n\t\t// above, except it resonates too much when the cutoff appoaches the\r\n\t\t// nyquist. If the resonance is set to zero and the cutoff is set to\r\n\t\t// nyquist/3, then the output is the same as the input.\r\n\t\tconst g: number = 2.0 * Math.sin(cornerRadiansPerSample / 2.0);\r\n\t\tconst filterResonance: number = 1.0 - 1.0 / (2.0 * peakLinearGain);\r\n\t\tconst feedback: number = filterResonance + filterResonance / (1.0 - g);\r\n\t\tthis.a[1] = 2.0*g + (g - 1.0) * g*feedback - 2.0;\r\n\t\tthis.a[2] = (g - 1.0) * (g - g*feedback - 1.0);\r\n\t\tthis.b[0] = g*g;\r\n\t\tthis.b[1] = 0;\r\n\t\tthis.b[2] = 0;\r\n\t\tthis.order = 2;\r\n\t}\r\n\t\r\n\tpublic highPass2ndOrderButterworth(cornerRadiansPerSample: number, peakLinearGain: number): void {\r\n\t\tconst alpha: number = Math.sin(cornerRadiansPerSample) / (2 * peakLinearGain);\r\n\t\tconst cos: number = Math.cos(cornerRadiansPerSample);\r\n\t\tconst a0: number = 1.0 + alpha;\r\n\t\tthis.a[1] = -2.0*cos / a0;\r\n\t\tthis.a[2] = (1.0 - alpha) / a0;\r\n\t\tthis.b[2] = this.b[0] = (1.0 + cos) / (2.0*a0);\r\n\t\tthis.b[1] = -(1.0 + cos) / a0;\r\n\t\tthis.order = 2;\r\n\t}\r\n\t/*\r\n\tpublic highPass2ndOrderSimplified(cornerRadiansPerSample: number, peakLinearGain: number): void {\r\n\t\tconst g: number = 2.0 * Math.sin(cornerRadiansPerSample * 0.5);\r\n\t\tconst filterResonance: number = 1.0 - 1.0 / (2.0 * peakLinearGain);\r\n\t\tconst feedback: number = filterResonance + filterResonance / (1.0 - g);\r\n\t\tthis.a[1] = 2.0*g + (g - 1.0) * g*feedback - 2.0;\r\n\t\tthis.a[2] = (g - 1.0) * (g - g*feedback - 1.0);\r\n\t\tthis.b[0] = 1.0;\r\n\t\tthis.b[1] = -2.0;\r\n\t\tthis.b[2] = 1.0;\r\n\t\tthis.order = 2;\r\n\t}\r\n\t*/\r\n\tpublic peak2ndOrder(cornerRadiansPerSample: number, peakLinearGain: number, bandWidthScale: number): void {\r\n\t\tconst sqrtGain: number = Math.sqrt(peakLinearGain);\r\n\t\tconst bandWidth: number = bandWidthScale * cornerRadiansPerSample / (sqrtGain >= 1 ? sqrtGain : 1/sqrtGain);\r\n\t\t//const bandWidth: number = bandWidthScale * cornerRadiansPerSample / Math.max(sqrtGain, 1.0);\r\n\t\tconst alpha: number = Math.tan(bandWidth * 0.5);\r\n\t\tconst a0: number = 1.0 + alpha / sqrtGain;\r\n\t\tthis.b[0] = (1.0 + alpha * sqrtGain) / a0;\r\n\t\tthis.b[1] = this.a[1] = -2.0 * Math.cos(cornerRadiansPerSample) / a0;\r\n\t\tthis.b[2] = (1.0 - alpha * sqrtGain) / a0;\r\n\t\tthis.a[2] = (1.0 - alpha / sqrtGain) / a0;\r\n\t\tthis.order = 2;\r\n\t}\r\n\t/*\r\n\t// Create a higher order filter by combining two lower order filters.\r\n\t// However, making high order filters in this manner results in instability.\r\n\t// It is recommended to apply the 2nd order filters (biquads) in sequence instead.\r\n\tpublic combination(filter1: FilterCoefficients, filter2: FilterCoefficients): void {\r\n\t\tthis.order = filter1.order + filter2.order;\r\n\t\tfor (let i: number = 0; i <= this.order; i++) {\r\n\t\t\tthis.a[i] = 0.0;\r\n\t\t\tthis.b[i] = 0.0;\r\n\t\t}\r\n\t\tfor (let i: number = 0; i <= filter1.order; i++) {\r\n\t\t\tfor (let j: number = 0; j <= filter2.order; j++) {\r\n\t\t\t\tthis.a[i + j] += filter1.a[i] * filter2.a[j];\r\n\t\t\t\tthis.b[i + j] += filter1.b[i] * filter2.b[j];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic scaledDifference(other: FilterCoefficients, scale: number): void {\r\n\t\tif (other.order != this.order) throw new Error();\r\n\t\tfor (let i: number = 0; i <= this.order; i++) {\r\n\t\t\tthis.a[i] = (this.a[i] - other.a[i]) * scale;\r\n\t\t\tthis.b[i] = (this.b[i] - other.b[i]) * scale;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic copy(other: FilterCoefficients): void {\r\n\t\tthis.order = other.order;\r\n\t\tfor (let i: number = 0; i <= this.order; i++) {\r\n\t\t\tthis.a[i] = other.a[i];\r\n\t\t\tthis.b[i] = other.b[i];\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\nexport class FrequencyResponse {\r\n\tpublic real: number = 0.0;\r\n\tpublic imag: number = 0.0;\r\n\tpublic denom: number = 1.0;\r\n\t\r\n\tpublic analyze(filter: FilterCoefficients, radiansPerSample: number): void {\r\n\t\tthis.analyzeComplex(filter, Math.cos(radiansPerSample), Math.sin(radiansPerSample));\r\n\t}\r\n\t\r\n\tpublic analyzeComplex(filter: FilterCoefficients, real: number, imag: number): void {\r\n\t\tconst a: number[] = filter.a;\r\n\t\tconst b: number[] = filter.b;\r\n\t\tconst realZ1: number = real;\r\n\t\tconst imagZ1: number = -imag;\r\n\t\tlet realNum: number = b[0] + b[1] * realZ1;\r\n\t\tlet imagNum: number = b[1] * imagZ1;\r\n\t\tlet realDenom: number = 1.0 + a[1] * realZ1;\r\n\t\tlet imagDenom: number = a[1] * imagZ1;\r\n\t\tlet realZ: number = realZ1;\r\n\t\tlet imagZ: number = imagZ1;\r\n\t\tfor (let i: number = 2; i <= filter.order; i++) {\r\n\t\t\tconst realTemp: number = realZ * realZ1 - imagZ * imagZ1;\r\n\t\t\tconst imagTemp: number = realZ * imagZ1 + imagZ * realZ1;\r\n\t\t\trealZ = realTemp;\r\n\t\t\timagZ = imagTemp;\r\n\t\t\trealNum += b[i] * realZ;\r\n\t\t\timagNum += b[i] * imagZ;\r\n\t\t\trealDenom += a[i] * realZ;\r\n\t\t\timagDenom += a[i] * imagZ;\r\n\t\t}\r\n\t\tthis.denom = realDenom * realDenom + imagDenom * imagDenom;\r\n\t\tthis.real = realNum * realDenom + imagNum * imagDenom;\r\n\t\tthis.imag = imagNum * realDenom - realNum * imagDenom;\r\n\t}\r\n\t\r\n\tpublic magnitude(): number {\r\n\t\treturn Math.sqrt(this.real * this.real + this.imag * this.imag) / this.denom;\r\n\t}\r\n\t\r\n\tpublic angle(): number {\r\n\t\treturn Math.atan2(this.imag, this.real);\r\n\t}\r\n}\r\n\r\nexport class DynamicBiquadFilter {\r\n\tpublic a1: number = 0.0;\r\n\tpublic a2: number = 0.0;\r\n\tpublic b0: number = 1.0;\r\n\tpublic b1: number = 0.0;\r\n\tpublic b2: number = 0.0;\r\n\tpublic a1Delta: number = 0.0;\r\n\tpublic a2Delta: number = 0.0;\r\n\tpublic b0Delta: number = 0.0;\r\n\tpublic b1Delta: number = 0.0;\r\n\tpublic b2Delta: number = 0.0;\r\n\tpublic output1: number = 0.0;\r\n\tpublic output2: number = 0.0;\r\n\t\r\n\t// Some filter types are more stable when interpolating between coefficients\r\n\t// if the \"b\" coefficient interpolation is multiplicative. Don't enable this\r\n\t// for filter types where the \"b\" coefficients might change sign!\r\n\tpublic useMultiplicativeInputCoefficients: boolean = false;\r\n\t\r\n\tpublic resetOutput(): void {\r\n\t\tthis.output1 = 0.0;\r\n\t\tthis.output2 = 0.0;\r\n\t}\r\n\t\r\n\tpublic loadCoefficientsWithGradient(start: FilterCoefficients, end: FilterCoefficients, deltaRate: number, useMultiplicativeInputCoefficients: boolean): void {\r\n\t\tif (start.order != 2 || end.order != 2) throw new Error();\r\n\t\tthis.a1 = start.a[1];\r\n\t\tthis.a2 = start.a[2];\r\n\t\tthis.b0 = start.b[0];\r\n\t\tthis.b1 = start.b[1];\r\n\t\tthis.b2 = start.b[2];\r\n\t\tthis.a1Delta = (end.a[1] - start.a[1]) * deltaRate;\r\n\t\tthis.a2Delta = (end.a[2] - start.a[2]) * deltaRate;\r\n\t\tif (useMultiplicativeInputCoefficients) {\r\n\t\t\tthis.b0Delta = Math.pow(end.b[0] / start.b[0], deltaRate);\r\n\t\t\tthis.b1Delta = Math.pow(end.b[1] / start.b[1], deltaRate);\r\n\t\t\tthis.b2Delta = Math.pow(end.b[2] / start.b[2], deltaRate);\r\n\t\t} else {\r\n\t\t\tthis.b0Delta = (end.b[0] - start.b[0]) * deltaRate;\r\n\t\t\tthis.b1Delta = (end.b[1] - start.b[1]) * deltaRate;\r\n\t\t\tthis.b2Delta = (end.b[2] - start.b[2]) * deltaRate;\r\n\t\t}\r\n\t\tthis.useMultiplicativeInputCoefficients = useMultiplicativeInputCoefficients;\r\n\t}\r\n}\r\n","// Copyright (c) 2012-2022 John Nesky and contributing authors, distributed under the MIT license, see accompanying the LICENSE.md file.\r\n\r\nimport { Dictionary, DictionaryArray, FilterType, EnvelopeType, InstrumentType, EffectType, EnvelopeComputeIndex, Transition, Unison, Chord, Vibrato, Envelope, AutomationTarget, Config, getDrumWave, drawNoiseSpectrum, getArpeggioPitchIndex, performIntegralOld, getPulseWidthRatio, effectsIncludeTransition, effectsIncludeChord, effectsIncludePitchShift, effectsIncludeDetune, effectsIncludeVibrato, effectsIncludeNoteFilter, effectsIncludeDistortion, effectsIncludeBitcrusher, effectsIncludePanning, effectsIncludeChorus, effectsIncludeEcho, effectsIncludeReverb, OperatorWave, effectsIncludeNoteRange, effectsIncludeInvertWave } from \"./SynthConfig\";\r\nimport { EditorConfig } from \"../editor/EditorConfig\";\r\nimport { scaleElementsByFactor, inverseRealFourierTransform } from \"./FFT\";\r\nimport { Deque } from \"./Deque\";\r\nimport { FilterCoefficients, FrequencyResponse, DynamicBiquadFilter } from \"./filtering\";\r\n\r\ndeclare global {\r\n    interface Window {\r\n        AudioContext: any;\r\n        webkitAudioContext: any;\r\n    }\r\n}\r\n\r\nconst epsilon: number = (1.0e-24); // For detecting and avoiding float denormals, which have poor performance.\r\n\r\n// For performance debugging:\r\n//let samplesAccumulated: number = 0;\r\n//let samplePerformance: number = 0;\r\n\r\nexport function clamp(min: number, max: number, val: number): number {\r\n    max = max - 1;\r\n    if (val <= max) {\r\n        if (val >= min) return val;\r\n        else return min;\r\n    } else {\r\n        return max;\r\n    }\r\n}\r\n\r\nfunction validateRange(min: number, max: number, val: number): number {\r\n    if (min <= val && val <= max) return val;\r\n    throw new Error(`Value ${val} not in range [${min}, ${max}]`);\r\n}\r\n\r\nconst enum CharCode {\r\n    SPACE = 32,\r\n    HASH = 35,\r\n    PERCENT = 37,\r\n    AMPERSAND = 38,\r\n    PLUS = 43,\r\n    DASH = 45,\r\n    DOT = 46,\r\n    NUM_0 = 48,\r\n    NUM_1 = 49,\r\n    NUM_2 = 50,\r\n    NUM_3 = 51,\r\n    NUM_4 = 52,\r\n    NUM_5 = 53,\r\n    NUM_6 = 54,\r\n    NUM_7 = 55,\r\n    NUM_8 = 56,\r\n    NUM_9 = 57,\r\n    EQUALS = 61,\r\n    A = 65,\r\n    B = 66,\r\n    C = 67,\r\n    D = 68,\r\n    E = 69,\r\n    F = 70,\r\n    G = 71,\r\n    H = 72,\r\n    I = 73,\r\n    J = 74,\r\n    K = 75,\r\n    L = 76,\r\n    M = 77,\r\n    N = 78,\r\n    O = 79,\r\n    P = 80,\r\n    Q = 81,\r\n    R = 82,\r\n    S = 83,\r\n    T = 84,\r\n    U = 85,\r\n    V = 86,\r\n    W = 87,\r\n    X = 88,\r\n    Y = 89,\r\n    Z = 90,\r\n    UNDERSCORE = 95,\r\n    a = 97,\r\n    b = 98,\r\n    c = 99,\r\n    d = 100,\r\n    e = 101,\r\n    f = 102,\r\n    g = 103,\r\n    h = 104,\r\n    i = 105,\r\n    j = 106,\r\n    k = 107,\r\n    l = 108,\r\n    m = 109,\r\n    n = 110,\r\n    o = 111,\r\n    p = 112,\r\n    q = 113,\r\n    r = 114,\r\n    s = 115,\r\n    t = 116,\r\n    u = 117,\r\n    v = 118,\r\n    w = 119,\r\n    x = 120,\r\n    y = 121,\r\n    z = 122,\r\n    LEFT_CURLY_BRACE = 123,\r\n    RIGHT_CURLY_BRACE = 125,\r\n}\r\n\r\nconst enum SongTagCode {\r\n    beatCount = CharCode.a, // added in song url version 2\r\n    bars = CharCode.b, // added in 2\r\n    vibrato = CharCode.c, // added in 2, DEPRECATED\r\n    fadeInOut = CharCode.d, // added in 3 for transition, switched to fadeInOut in 9\r\n    loopEnd = CharCode.e, // added in 2\r\n    eqFilter = CharCode.f, // added in 3\r\n    barCount = CharCode.g, // added in 3\r\n    unison = CharCode.h, // added in 2\r\n    instrumentCount = CharCode.i, // added in 3\r\n    patternCount = CharCode.j, // added in 3\r\n    key = CharCode.k, // added in 2\r\n    loopStart = CharCode.l, // added in 2\r\n    reverb = CharCode.m, // added in 5, DEPRECATED\r\n    channelCount = CharCode.n, // added in 6\r\n    channelOctave = CharCode.o, // added in 3\r\n    patterns = CharCode.p, // added in 2\r\n    effects = CharCode.q, // added in 7\r\n    rhythm = CharCode.r, // added in 2\r\n    scale = CharCode.s, // added in 2\r\n    tempo = CharCode.t, // added in 2\r\n    preset = CharCode.u, // added in 7\r\n    volume = CharCode.v, // added in 2\r\n    wave = CharCode.w, // added in 2\r\n\r\n    filterResonance = CharCode.y, // added in 7, DEPRECATED\r\n    drumsetEnvelopes = CharCode.z, // added in 7 for filter envelopes, still used for drumset envelopes\r\n    algorithm = CharCode.A, // added in 6\r\n    feedbackAmplitude = CharCode.B, // added in 6\r\n    chord = CharCode.C, // added in 7, DEPRECATED\r\n    detune = CharCode.D, // [JB], added in 3(?), DEPRECATED\r\n    envelopes = CharCode.E, // added in 6 for FM operator envelopes, repurposed in 9 for general envelopes.\r\n    feedbackType = CharCode.F, // added in 6\r\n    arpeggioSpeed = CharCode.G, // [JB], added in 3, DEPRECATED\r\n    harmonics = CharCode.H, // added in 7\r\n    stringSustain = CharCode.I, // added in 9\r\n\r\n    pan = CharCode.L, // added between 8 and 9, DEPRECATED\r\n    customChipWave = CharCode.M, // [JB], added in 1(?)\r\n    songTitle = CharCode.N, // [JB], added in 1(?)\r\n    limiterSettings = CharCode.O, // [JB], added in 3(?)\r\n\r\n    operatorAmplitudes = CharCode.P, // added in 6\r\n    operatorFrequencies = CharCode.Q, // added in 6\r\n    operatorWaves = CharCode.R, // [JB], added in 4\r\n    spectrum = CharCode.S, // added in 7\r\n    startInstrument = CharCode.T, // added in 6\r\n    channelNames = CharCode.U, // [JB], added in 4(?)\r\n    feedbackEnvelope = CharCode.V, // added in 6, DEPRECATED\r\n    pulseWidth = CharCode.W, // added in 7\r\n    aliases = CharCode.X, // [JB], added in 4, DEPRECATED\r\n\r\n}\r\n\r\nconst base64IntToCharCode: ReadonlyArray<number> = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 45, 95];\r\nconst base64CharCodeToInt: ReadonlyArray<number> = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 62, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 63, 0, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 0, 0, 0, 0, 0]; // 62 could be represented by either \"-\" or \".\" for historical reasons. New songs should use \"-\".\r\n\r\nclass BitFieldReader {\r\n    private _bits: number[] = [];\r\n    private _readIndex: number = 0;\r\n\r\n    constructor(source: string, startIndex: number, stopIndex: number) {\r\n        for (let i: number = startIndex; i < stopIndex; i++) {\r\n            const value: number = base64CharCodeToInt[source.charCodeAt(i)];\r\n            this._bits.push((value >> 5) & 0x1);\r\n            this._bits.push((value >> 4) & 0x1);\r\n            this._bits.push((value >> 3) & 0x1);\r\n            this._bits.push((value >> 2) & 0x1);\r\n            this._bits.push((value >> 1) & 0x1);\r\n            this._bits.push(value & 0x1);\r\n        }\r\n    }\r\n\r\n    public read(bitCount: number): number {\r\n        let result: number = 0;\r\n        while (bitCount > 0) {\r\n            result = result << 1;\r\n            result += this._bits[this._readIndex++];\r\n            bitCount--;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public readLongTail(minValue: number, minBits: number): number {\r\n        let result: number = minValue;\r\n        let numBits: number = minBits;\r\n        while (this._bits[this._readIndex++]) {\r\n            result += 1 << numBits;\r\n            numBits++;\r\n        }\r\n        while (numBits > 0) {\r\n            numBits--;\r\n            if (this._bits[this._readIndex++]) {\r\n                result += 1 << numBits;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public readPartDuration(): number {\r\n        return this.readLongTail(1, 3);\r\n    }\r\n\r\n    public readLegacyPartDuration(): number {\r\n        return this.readLongTail(1, 2);\r\n    }\r\n\r\n    public readPinCount(): number {\r\n        return this.readLongTail(1, 0);\r\n    }\r\n\r\n    public readPitchInterval(): number {\r\n        if (this.read(1)) {\r\n            return -this.readLongTail(1, 3);\r\n        } else {\r\n            return this.readLongTail(1, 3);\r\n        }\r\n    }\r\n}\r\n\r\nclass BitFieldWriter {\r\n    private _index: number = 0;\r\n    private _bits: number[] = [];\r\n\r\n    public clear() {\r\n        this._index = 0;\r\n    }\r\n\r\n    public write(bitCount: number, value: number): void {\r\n        bitCount--;\r\n        while (bitCount >= 0) {\r\n            this._bits[this._index++] = (value >>> bitCount) & 1;\r\n            bitCount--;\r\n        }\r\n    }\r\n\r\n    public writeLongTail(minValue: number, minBits: number, value: number): void {\r\n        if (value < minValue) throw new Error(\"value out of bounds\");\r\n        value -= minValue;\r\n        let numBits: number = minBits;\r\n        while (value >= (1 << numBits)) {\r\n            this._bits[this._index++] = 1;\r\n            value -= 1 << numBits;\r\n            numBits++;\r\n        }\r\n        this._bits[this._index++] = 0;\r\n        while (numBits > 0) {\r\n            numBits--;\r\n            this._bits[this._index++] = (value >>> numBits) & 1;\r\n        }\r\n    }\r\n\r\n    public writePartDuration(value: number): void {\r\n        this.writeLongTail(1, 3, value);\r\n    }\r\n\r\n    public writePinCount(value: number): void {\r\n        this.writeLongTail(1, 0, value);\r\n    }\r\n\r\n    public writePitchInterval(value: number): void {\r\n        if (value < 0) {\r\n            this.write(1, 1); // sign\r\n            this.writeLongTail(1, 3, -value);\r\n        } else {\r\n            this.write(1, 0); // sign\r\n            this.writeLongTail(1, 3, value);\r\n        }\r\n    }\r\n\r\n    public concat(other: BitFieldWriter): void {\r\n        for (let i: number = 0; i < other._index; i++) {\r\n            this._bits[this._index++] = other._bits[i];\r\n        }\r\n    }\r\n\r\n    public encodeBase64(buffer: number[]): number[] {\r\n\r\n        for (let i: number = 0; i < this._index; i += 6) {\r\n            const value: number = (this._bits[i] << 5) | (this._bits[i + 1] << 4) | (this._bits[i + 2] << 3) | (this._bits[i + 3] << 2) | (this._bits[i + 4] << 1) | this._bits[i + 5];\r\n            buffer.push(base64IntToCharCode[value]);\r\n        }\r\n        return buffer;\r\n    }\r\n\r\n    public lengthBase64(): number {\r\n        return Math.ceil(this._index / 6);\r\n    }\r\n}\r\n\r\nexport interface NotePin {\r\n    interval: number;\r\n    time: number;\r\n    size: number;\r\n}\r\n\r\nexport function makeNotePin(interval: number, time: number, size: number): NotePin {\r\n    return { interval: interval, time: time, size: size };\r\n}\r\n\r\nexport class Note {\r\n    public pitches: number[];\r\n    public pins: NotePin[];\r\n    public start: number;\r\n    public end: number;\r\n    public continuesLastPattern: boolean;\r\n\r\n    public constructor(pitch: number, start: number, end: number, size: number, fadeout: boolean = false) {\r\n        this.pitches = [pitch];\r\n        this.pins = [makeNotePin(0, 0, size), makeNotePin(0, end - start, fadeout ? 0 : size)];\r\n        this.start = start;\r\n        this.end = end;\r\n        this.continuesLastPattern = false;\r\n    }\r\n\r\n    public pickMainInterval(): number {\r\n        let longestFlatIntervalDuration: number = 0;\r\n        let mainInterval: number = 0;\r\n        for (let pinIndex: number = 1; pinIndex < this.pins.length; pinIndex++) {\r\n            const pinA: NotePin = this.pins[pinIndex - 1];\r\n            const pinB: NotePin = this.pins[pinIndex];\r\n            if (pinA.interval == pinB.interval) {\r\n                const duration: number = pinB.time - pinA.time;\r\n                if (longestFlatIntervalDuration < duration) {\r\n                    longestFlatIntervalDuration = duration;\r\n                    mainInterval = pinA.interval;\r\n                }\r\n            }\r\n        }\r\n        if (longestFlatIntervalDuration == 0) {\r\n            let loudestSize: number = 0;\r\n            for (let pinIndex: number = 0; pinIndex < this.pins.length; pinIndex++) {\r\n                const pin: NotePin = this.pins[pinIndex];\r\n                if (loudestSize < pin.size) {\r\n                    loudestSize = pin.size;\r\n                    mainInterval = pin.interval;\r\n                }\r\n            }\r\n        }\r\n        return mainInterval;\r\n    }\r\n\r\n    public clone(): Note {\r\n        const newNote: Note = new Note(-1, this.start, this.end, 3);\r\n        newNote.pitches = this.pitches.concat();\r\n        newNote.pins = [];\r\n        for (const pin of this.pins) {\r\n            newNote.pins.push(makeNotePin(pin.interval, pin.time, pin.size));\r\n        }\r\n        newNote.continuesLastPattern = this.continuesLastPattern;\r\n        return newNote;\r\n    }\r\n\r\n    public getEndPinIndex(part: number): number {\r\n        let endPinIndex: number;\r\n        for (endPinIndex = 1; endPinIndex < this.pins.length - 1; endPinIndex++) {\r\n            if (this.pins[endPinIndex].time + this.start > part) break;\r\n        }\r\n        return endPinIndex;\r\n    }\r\n}\r\n\r\nexport class Pattern {\r\n    public notes: Note[] = [];\r\n    public readonly instruments: number[] = [0];\r\n\r\n    public cloneNotes(): Note[] {\r\n        const result: Note[] = [];\r\n        for (const note of this.notes) {\r\n            result.push(note.clone());\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public reset(): void {\r\n        this.notes.length = 0;\r\n        this.instruments[0] = 0;\r\n        this.instruments.length = 1;\r\n    }\r\n\r\n    public toJsonObject(song: Song, channel: Channel, isModChannel: boolean): any {\r\n        const noteArray: Object[] = [];\r\n        for (const note of this.notes) {\r\n            // Only one ins per pattern is enforced in mod channels.\r\n            let instrument: Instrument = channel.instruments[this.instruments[0]];\r\n            let mod: number = Math.max(0, Config.modCount - note.pitches[0] - 1);\r\n            let volumeCap: number = song.getVolumeCapForSetting(isModChannel, instrument.modulators[mod], instrument.modFilterTypes[mod]);\r\n            const pointArray: Object[] = [];\r\n            for (const pin of note.pins) {\r\n                let useVol: number = isModChannel ? Math.round(pin.size) : Math.round(pin.size * 100 / volumeCap);\r\n                pointArray.push({\r\n                    \"tick\": (pin.time + note.start) * Config.rhythms[song.rhythm].stepsPerBeat / Config.partsPerBeat,\r\n                    \"pitchBend\": pin.interval,\r\n                    \"volume\": useVol,\r\n                    \"forMod\": isModChannel,\r\n                });\r\n            }\r\n\r\n            const noteObject: any = {\r\n                \"pitches\": note.pitches,\r\n                \"points\": pointArray,\r\n            };\r\n            if (note.start == 0) {\r\n                noteObject[\"continuesLastPattern\"] = note.continuesLastPattern;\r\n            }\r\n            noteArray.push(noteObject);\r\n        }\r\n\r\n        const patternObject: any = { \"notes\": noteArray };\r\n        if (song.patternInstruments) {\r\n            patternObject[\"instruments\"] = this.instruments.map(i => i + 1);\r\n        }\r\n        return patternObject;\r\n    }\r\n\r\n    public fromJsonObject(patternObject: any, song: Song, channel: Channel, importedPartsPerBeat: number, isNoiseChannel: boolean, isModChannel: boolean): void {\r\n        if (song.patternInstruments) {\r\n            if (Array.isArray(patternObject[\"instruments\"])) {\r\n                const instruments: any[] = patternObject[\"instruments\"];\r\n                const instrumentCount: number = clamp(Config.instrumentCountMin, song.getMaxInstrumentsPerPatternForChannel(channel) + 1, instruments.length);\r\n                for (let j: number = 0; j < instrumentCount; j++) {\r\n                    this.instruments[j] = clamp(0, channel.instruments.length, (instruments[j] | 0) - 1);\r\n                }\r\n                this.instruments.length = instrumentCount;\r\n            } else {\r\n                this.instruments[0] = clamp(0, channel.instruments.length, (patternObject[\"instrument\"] | 0) - 1);\r\n                this.instruments.length = 1;\r\n            }\r\n        }\r\n\r\n        if (patternObject[\"notes\"] && patternObject[\"notes\"].length > 0) {\r\n            const maxNoteCount: number = Math.min(song.beatsPerBar * Config.partsPerBeat * (isModChannel ? Config.modCount : 1), patternObject[\"notes\"].length >>> 0);\r\n\r\n            // TODO: Consider supporting notes specified in any timing order, sorting them and truncating as necessary.\r\n            //let tickClock: number = 0;\r\n            for (let j: number = 0; j < patternObject[\"notes\"].length; j++) {\r\n                if (j >= maxNoteCount) break;\r\n\r\n                const noteObject = patternObject[\"notes\"][j];\r\n                if (!noteObject || !noteObject[\"pitches\"] || !(noteObject[\"pitches\"].length >= 1) || !noteObject[\"points\"] || !(noteObject[\"points\"].length >= 2)) {\r\n                    continue;\r\n                }\r\n\r\n                const note: Note = new Note(0, 0, 0, 0);\r\n                note.pitches = [];\r\n                note.pins = [];\r\n\r\n                for (let k: number = 0; k < noteObject[\"pitches\"].length; k++) {\r\n                    const pitch: number = noteObject[\"pitches\"][k] | 0;\r\n                    if (note.pitches.indexOf(pitch) != -1) continue;\r\n                    note.pitches.push(pitch);\r\n                    if (note.pitches.length >= Config.maxChordSize) break;\r\n                }\r\n                if (note.pitches.length < 1) continue;\r\n\r\n                //let noteClock: number = tickClock;\r\n                let startInterval: number = 0;\r\n                for (let k: number = 0; k < noteObject[\"points\"].length; k++) {\r\n                    const pointObject: any = noteObject[\"points\"][k];\r\n                    if (pointObject == undefined || pointObject[\"tick\"] == undefined) continue;\r\n                    const interval: number = (pointObject[\"pitchBend\"] == undefined) ? 0 : (pointObject[\"pitchBend\"] | 0);\r\n\r\n                    const time: number = Math.round((+pointObject[\"tick\"]) * Config.partsPerBeat / importedPartsPerBeat);\r\n\r\n                    let instrument: Instrument = channel.instruments[this.instruments[0]];\r\n                    let mod: number = Math.max(0, Config.modCount - note.pitches[0] - 1);\r\n\r\n                    // Only one instrument per pattern allowed in mod channels.\r\n                    let volumeCap: number = song.getVolumeCapForSetting(isModChannel, instrument.modulators[mod], instrument.modFilterTypes[mod]);\r\n\r\n                    // The strange volume formula used for notes is not needed for mods. Some rounding errors were possible.\r\n                    // A \"forMod\" signifier was added to new JSON export to detect when the higher precision export was used in a file.\r\n                    let size: number;\r\n                    if (pointObject[\"volume\"] == undefined) {\r\n                        size = volumeCap;\r\n                    } else if (pointObject[\"forMod\"] == undefined) {\r\n                        size = Math.max(0, Math.min(volumeCap, Math.round((pointObject[\"volume\"] | 0) * volumeCap / 100)));\r\n                    }\r\n                    else {\r\n                        size = ((pointObject[\"forMod\"] | 0) > 0) ? Math.round(pointObject[\"volume\"] | 0) : Math.max(0, Math.min(volumeCap, Math.round((pointObject[\"volume\"] | 0) * volumeCap / 100)));\r\n                    }\r\n\r\n                    if (time > song.beatsPerBar * Config.partsPerBeat) continue;\r\n                    if (note.pins.length == 0) {\r\n                        //if (time < noteClock) continue;\r\n                        note.start = time;\r\n                        startInterval = interval;\r\n                    } else {\r\n                        //if (time <= noteClock) continue;\r\n                    }\r\n                    //noteClock = time;\r\n\r\n                    note.pins.push(makeNotePin(interval - startInterval, time - note.start, size));\r\n                }\r\n                if (note.pins.length < 2) continue;\r\n\r\n                note.end = note.pins[note.pins.length - 1].time + note.start;\r\n\r\n                const maxPitch: number = isNoiseChannel ? Config.drumCount - 1 : Config.maxPitch;\r\n                let lowestPitch: number = maxPitch;\r\n                let highestPitch: number = 0;\r\n                for (let k: number = 0; k < note.pitches.length; k++) {\r\n                    note.pitches[k] += startInterval;\r\n                    if (note.pitches[k] < 0 || note.pitches[k] > maxPitch) {\r\n                        note.pitches.splice(k, 1);\r\n                        k--;\r\n                    }\r\n                    if (note.pitches[k] < lowestPitch) lowestPitch = note.pitches[k];\r\n                    if (note.pitches[k] > highestPitch) highestPitch = note.pitches[k];\r\n                }\r\n                if (note.pitches.length < 1) continue;\r\n\r\n                for (let k: number = 0; k < note.pins.length; k++) {\r\n                    const pin: NotePin = note.pins[k];\r\n                    if (pin.interval + lowestPitch < 0) pin.interval = -lowestPitch;\r\n                    if (pin.interval + highestPitch > maxPitch) pin.interval = maxPitch - highestPitch;\r\n                    if (k >= 2) {\r\n                        if (pin.interval == note.pins[k - 1].interval &&\r\n                            pin.interval == note.pins[k - 2].interval &&\r\n                            pin.size == note.pins[k - 1].size &&\r\n                            pin.size == note.pins[k - 2].size) {\r\n                            note.pins.splice(k - 1, 1);\r\n                            k--;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (note.start == 0) {\r\n                    note.continuesLastPattern = (noteObject[\"continuesLastPattern\"] === true);\r\n                } else {\r\n                    note.continuesLastPattern = false;\r\n                }\r\n\r\n                this.notes.push(note);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport class Operator {\r\n    public frequency: number = 0;\r\n    public amplitude: number = 0;\r\n    public waveform: number = 0;\r\n    public pulseWidth: number = 0.5;\r\n\r\n    constructor(index: number) {\r\n        this.reset(index);\r\n    }\r\n\r\n    public reset(index: number): void {\r\n        this.frequency = 0;\r\n        this.amplitude = (index <= 1) ? Config.operatorAmplitudeMax : 0;\r\n        this.waveform = 0;\r\n        this.pulseWidth = 5;\r\n    }\r\n\r\n    public copy(other: Operator): void {\r\n        this.frequency = other.frequency;\r\n        this.amplitude = other.amplitude;\r\n        this.waveform = other.waveform;\r\n        this.pulseWidth = other.pulseWidth;\r\n    }\r\n}\r\n\r\nexport class SpectrumWave {\r\n    public spectrum: number[] = [];\r\n    public hash: number = -1;\r\n\r\n    constructor(isNoiseChannel: boolean) {\r\n        this.reset(isNoiseChannel);\r\n    }\r\n\r\n    public reset(isNoiseChannel: boolean): void {\r\n        for (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n            if (isNoiseChannel) {\r\n                this.spectrum[i] = Math.round(Config.spectrumMax * (1 / Math.sqrt(1 + i / 3)));\r\n            } else {\r\n                const isHarmonic: boolean = i == 0 || i == 7 || i == 11 || i == 14 || i == 16 || i == 18 || i == 21 || i == 23 || i >= 25;\r\n                this.spectrum[i] = isHarmonic ? Math.max(0, Math.round(Config.spectrumMax * (1 - i / 30))) : 0;\r\n            }\r\n        }\r\n        this.markCustomWaveDirty();\r\n    }\r\n\r\n    public markCustomWaveDirty(): void {\r\n        const hashMult: number = Synth.fittingPowerOfTwo(Config.spectrumMax + 2) - 1;\r\n        let hash: number = 0;\r\n        for (const point of this.spectrum) hash = ((hash * hashMult) + point) >>> 0;\r\n        this.hash = hash;\r\n    }\r\n}\r\n\r\nclass SpectrumWaveState {\r\n    public wave: Float32Array | null = null;\r\n    private _hash: number = -1;\r\n\r\n    public getCustomWave(settings: SpectrumWave, lowestOctave: number): Float32Array {\r\n        if (this._hash == settings.hash) return this.wave!;\r\n        this._hash = settings.hash;\r\n\r\n        const waveLength: number = Config.spectrumNoiseLength;\r\n        if (this.wave == null || this.wave.length != waveLength + 1) {\r\n            this.wave = new Float32Array(waveLength + 1);\r\n        }\r\n        const wave: Float32Array = this.wave;\r\n\r\n        for (let i: number = 0; i < waveLength; i++) {\r\n            wave[i] = 0;\r\n        }\r\n\r\n        const highestOctave: number = 14;\r\n        const falloffRatio: number = 0.25;\r\n        // Nudge the 2/7 and 4/7 control points so that they form harmonic intervals.\r\n        const pitchTweak: number[] = [0, 1 / 7, Math.log2(5 / 4), 3 / 7, Math.log2(3 / 2), 5 / 7, 6 / 7];\r\n        function controlPointToOctave(point: number): number {\r\n            return lowestOctave + Math.floor(point / Config.spectrumControlPointsPerOctave) + pitchTweak[(point + Config.spectrumControlPointsPerOctave) % Config.spectrumControlPointsPerOctave];\r\n        }\r\n\r\n        let combinedAmplitude: number = 1;\r\n        for (let i: number = 0; i < Config.spectrumControlPoints + 1; i++) {\r\n            const value1: number = (i <= 0) ? 0 : settings.spectrum[i - 1];\r\n            const value2: number = (i >= Config.spectrumControlPoints) ? settings.spectrum[Config.spectrumControlPoints - 1] : settings.spectrum[i];\r\n            const octave1: number = controlPointToOctave(i - 1);\r\n            let octave2: number = controlPointToOctave(i);\r\n            if (i >= Config.spectrumControlPoints) octave2 = highestOctave + (octave2 - highestOctave) * falloffRatio;\r\n            if (value1 == 0 && value2 == 0) continue;\r\n\r\n            combinedAmplitude += 0.02 * drawNoiseSpectrum(wave, waveLength, octave1, octave2, value1 / Config.spectrumMax, value2 / Config.spectrumMax, -0.5);\r\n        }\r\n        if (settings.spectrum[Config.spectrumControlPoints - 1] > 0) {\r\n            combinedAmplitude += 0.02 * drawNoiseSpectrum(wave, waveLength, highestOctave + (controlPointToOctave(Config.spectrumControlPoints) - highestOctave) * falloffRatio, highestOctave, settings.spectrum[Config.spectrumControlPoints - 1] / Config.spectrumMax, 0, -0.5);\r\n        }\r\n\r\n        inverseRealFourierTransform(wave, waveLength);\r\n        scaleElementsByFactor(wave, 5.0 / (Math.sqrt(waveLength) * Math.pow(combinedAmplitude, 0.75)));\r\n\r\n        // Duplicate the first sample at the end for easier wrap-around interpolation.\r\n        wave[waveLength] = wave[0];\r\n\r\n        return wave;\r\n    }\r\n}\r\n\r\nexport class HarmonicsWave {\r\n    public harmonics: number[] = [];\r\n    public hash: number = -1;\r\n\r\n    constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        for (let i: number = 0; i < Config.harmonicsControlPoints; i++) {\r\n            this.harmonics[i] = 0;\r\n        }\r\n        this.harmonics[0] = Config.harmonicsMax;\r\n        this.harmonics[3] = Config.harmonicsMax;\r\n        this.harmonics[6] = Config.harmonicsMax;\r\n        this.markCustomWaveDirty();\r\n    }\r\n\r\n    public markCustomWaveDirty(): void {\r\n        const hashMult: number = Synth.fittingPowerOfTwo(Config.harmonicsMax + 2) - 1;\r\n        let hash: number = 0;\r\n        for (const point of this.harmonics) hash = ((hash * hashMult) + point) >>> 0;\r\n        this.hash = hash;\r\n    }\r\n}\r\n\r\nclass HarmonicsWaveState {\r\n    public wave: Float32Array | null = null;\r\n    private _hash: number = -1;\r\n    private _generatedForType: InstrumentType;\r\n\r\n    public getCustomWave(settings: HarmonicsWave, instrumentType: InstrumentType): Float32Array {\r\n        if (this._hash == settings.hash && this._generatedForType == instrumentType) return this.wave!;\r\n        this._hash = settings.hash;\r\n        this._generatedForType = instrumentType;\r\n\r\n        const harmonicsRendered: number = (instrumentType == InstrumentType.pickedString) ? Config.harmonicsRenderedForPickedString : Config.harmonicsRendered;\r\n\r\n        const waveLength: number = Config.harmonicsWavelength;\r\n        const retroWave: Float32Array = getDrumWave(0, null, null);\r\n\r\n        if (this.wave == null || this.wave.length != waveLength + 1) {\r\n            this.wave = new Float32Array(waveLength + 1);\r\n        }\r\n        const wave: Float32Array = this.wave;\r\n\r\n        for (let i: number = 0; i < waveLength; i++) {\r\n            wave[i] = 0;\r\n        }\r\n\r\n        const overallSlope: number = -0.25;\r\n        let combinedControlPointAmplitude: number = 1;\r\n\r\n        for (let harmonicIndex: number = 0; harmonicIndex < harmonicsRendered; harmonicIndex++) {\r\n            const harmonicFreq: number = harmonicIndex + 1;\r\n            let controlValue: number = harmonicIndex < Config.harmonicsControlPoints ? settings.harmonics[harmonicIndex] : settings.harmonics[Config.harmonicsControlPoints - 1];\r\n            if (harmonicIndex >= Config.harmonicsControlPoints) {\r\n                controlValue *= 1 - (harmonicIndex - Config.harmonicsControlPoints) / (harmonicsRendered - Config.harmonicsControlPoints);\r\n            }\r\n            const normalizedValue: number = controlValue / Config.harmonicsMax;\r\n            let amplitude: number = Math.pow(2, controlValue - Config.harmonicsMax + 1) * Math.sqrt(normalizedValue);\r\n            if (harmonicIndex < Config.harmonicsControlPoints) {\r\n                combinedControlPointAmplitude += amplitude;\r\n            }\r\n            amplitude *= Math.pow(harmonicFreq, overallSlope);\r\n\r\n            // Multiply all the sine wave amplitudes by 1 or -1 based on the LFSR\r\n            // retro wave (effectively random) to avoid egregiously tall spikes.\r\n            amplitude *= retroWave[harmonicIndex + 589];\r\n\r\n            wave[waveLength - harmonicFreq] = amplitude;\r\n        }\r\n\r\n        inverseRealFourierTransform(wave, waveLength);\r\n\r\n        // Limit the maximum wave amplitude.\r\n        const mult: number = 1 / Math.pow(combinedControlPointAmplitude, 0.7);\r\n        for (let i: number = 0; i < wave.length; i++) wave[i] *= mult;\r\n\r\n        performIntegralOld(wave);\r\n\r\n        // The first sample should be zero, and we'll duplicate it at the end for easier interpolation.\r\n        wave[waveLength] = wave[0];\r\n\r\n        return wave;\r\n    }\r\n}\r\n\r\nexport class FilterControlPoint {\r\n    public freq: number = 0;\r\n    public gain: number = Config.filterGainCenter;\r\n    public type: FilterType = FilterType.peak;\r\n\r\n    public set(freqSetting: number, gainSetting: number): void {\r\n        this.freq = freqSetting;\r\n        this.gain = gainSetting;\r\n    }\r\n\r\n    public getHz(): number {\r\n        return FilterControlPoint.getHzFromSettingValue(this.freq);\r\n    }\r\n\r\n    public static getHzFromSettingValue(value: number): number {\r\n        return Config.filterFreqReferenceHz * Math.pow(2.0, (value - Config.filterFreqReferenceSetting) * Config.filterFreqStep);\r\n    }\r\n    public static getSettingValueFromHz(hz: number): number {\r\n        return Math.log2(hz / Config.filterFreqReferenceHz) / Config.filterFreqStep + Config.filterFreqReferenceSetting;\r\n    }\r\n    public static getRoundedSettingValueFromHz(hz: number): number {\r\n        return Math.max(0, Math.min(Config.filterFreqRange - 1, Math.round(FilterControlPoint.getSettingValueFromHz(hz))));\r\n    }\r\n\r\n    public getLinearGain(peakMult: number = 1.0): number {\r\n        const power: number = (this.gain - Config.filterGainCenter) * Config.filterGainStep;\r\n        const neutral: number = (this.type == FilterType.peak) ? 0.0 : -0.5;\r\n        const interpolatedPower: number = neutral + (power - neutral) * peakMult;\r\n        return Math.pow(2.0, interpolatedPower);\r\n    }\r\n    public static getRoundedSettingValueFromLinearGain(linearGain: number): number {\r\n        return Math.max(0, Math.min(Config.filterGainRange - 1, Math.round(Math.log2(linearGain) / Config.filterGainStep + Config.filterGainCenter)));\r\n    }\r\n\r\n    public toCoefficients(filter: FilterCoefficients, sampleRate: number, freqMult: number = 1.0, peakMult: number = 1.0): void {\r\n        const cornerRadiansPerSample: number = 2.0 * Math.PI * Math.max(Config.filterFreqMinHz, Math.min(Config.filterFreqMaxHz, freqMult * this.getHz())) / sampleRate;\r\n        const linearGain: number = this.getLinearGain(peakMult);\r\n        switch (this.type) {\r\n            case FilterType.lowPass:\r\n                filter.lowPass2ndOrderButterworth(cornerRadiansPerSample, linearGain);\r\n                break;\r\n            case FilterType.highPass:\r\n                filter.highPass2ndOrderButterworth(cornerRadiansPerSample, linearGain);\r\n                break;\r\n            case FilterType.peak:\r\n                filter.peak2ndOrder(cornerRadiansPerSample, linearGain, 1.0);\r\n                break;\r\n            default:\r\n                throw new Error();\r\n        }\r\n    }\r\n\r\n    public getVolumeCompensationMult(): number {\r\n        const octave: number = (this.freq - Config.filterFreqReferenceSetting) * Config.filterFreqStep;\r\n        const gainPow: number = (this.gain - Config.filterGainCenter) * Config.filterGainStep;\r\n        switch (this.type) {\r\n            case FilterType.lowPass:\r\n                const freqRelativeTo8khz: number = Math.pow(2.0, octave) * Config.filterFreqReferenceHz / 8000.0;\r\n                // Reverse the frequency warping from importing legacy simplified filters to imitate how the legacy filter cutoff setting affected volume.\r\n                const warpedFreq: number = (Math.sqrt(1.0 + 4.0 * freqRelativeTo8khz) - 1.0) / 2.0;\r\n                const warpedOctave: number = Math.log2(warpedFreq);\r\n                return Math.pow(0.5, 0.2 * Math.max(0.0, gainPow + 1.0) + Math.min(0.0, Math.max(-3.0, 0.595 * warpedOctave + 0.35 * Math.min(0.0, gainPow + 1.0))));\r\n            case FilterType.highPass:\r\n                return Math.pow(0.5, 0.125 * Math.max(0.0, gainPow + 1.0) + Math.min(0.0, 0.3 * (-octave - Math.log2(Config.filterFreqReferenceHz / 125.0)) + 0.2 * Math.min(0.0, gainPow + 1.0)));\r\n            case FilterType.peak:\r\n                const distanceFromCenter: number = octave + Math.log2(Config.filterFreqReferenceHz / 2000.0);\r\n                const freqLoudness: number = Math.pow(1.0 / (1.0 + Math.pow(distanceFromCenter / 3.0, 2.0)), 2.0);\r\n                return Math.pow(0.5, 0.125 * Math.max(0.0, gainPow) + 0.1 * freqLoudness * Math.min(0.0, gainPow));\r\n            default:\r\n                throw new Error();\r\n        }\r\n    }\r\n}\r\n\r\nexport class FilterSettings {\r\n    public readonly controlPoints: FilterControlPoint[] = [];\r\n    public controlPointCount: number = 0;\r\n\r\n    constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    reset(): void {\r\n        this.controlPointCount = 0;\r\n    }\r\n\r\n    addPoint(type: FilterType, freqSetting: number, gainSetting: number): void {\r\n        let controlPoint: FilterControlPoint;\r\n        if (this.controlPoints.length <= this.controlPointCount) {\r\n            controlPoint = new FilterControlPoint();\r\n            this.controlPoints[this.controlPointCount] = controlPoint;\r\n        } else {\r\n            controlPoint = this.controlPoints[this.controlPointCount];\r\n        }\r\n        this.controlPointCount++;\r\n        controlPoint.type = type;\r\n        controlPoint.set(freqSetting, gainSetting);\r\n    }\r\n\r\n    public toJsonObject(): Object {\r\n        const filterArray: any[] = [];\r\n        for (let i: number = 0; i < this.controlPointCount; i++) {\r\n            const point: FilterControlPoint = this.controlPoints[i];\r\n            filterArray.push({\r\n                \"type\": Config.filterTypeNames[point.type],\r\n                \"cutoffHz\": Math.round(point.getHz() * 100) / 100,\r\n                \"linearGain\": Math.round(point.getLinearGain() * 10000) / 10000,\r\n            });\r\n        }\r\n        return filterArray;\r\n    }\r\n\r\n    public fromJsonObject(filterObject: any): void {\r\n        this.controlPoints.length = 0;\r\n        if (filterObject) {\r\n            for (const pointObject of filterObject) {\r\n                const point: FilterControlPoint = new FilterControlPoint();\r\n                point.type = Config.filterTypeNames.indexOf(pointObject[\"type\"]);\r\n                if (<any>point.type == -1) point.type = FilterType.peak;\r\n                if (pointObject[\"cutoffHz\"] != undefined) {\r\n                    point.freq = FilterControlPoint.getRoundedSettingValueFromHz(pointObject[\"cutoffHz\"]);\r\n                } else {\r\n                    point.freq = 0;\r\n                }\r\n                if (pointObject[\"linearGain\"] != undefined) {\r\n                    point.gain = FilterControlPoint.getRoundedSettingValueFromLinearGain(pointObject[\"linearGain\"]);\r\n                } else {\r\n                    point.gain = Config.filterGainCenter;\r\n                }\r\n                this.controlPoints.push(point);\r\n            }\r\n        }\r\n        this.controlPointCount = this.controlPoints.length;\r\n    }\r\n\r\n    // Returns true if all filter control points match in number and type (but not freq/gain)\r\n    public static filtersCanMorph(filterA: FilterSettings, filterB: FilterSettings): boolean {\r\n        if (filterA.controlPointCount != filterB.controlPointCount)\r\n            return false;\r\n        for (let i: number = 0; i < filterA.controlPointCount; i++) {\r\n            if (filterA.controlPoints[i].type != filterB.controlPoints[i].type)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Interpolate two FilterSettings, where pos=0 is filterA and pos=1 is filterB\r\n    public static lerpFilters(filterA: FilterSettings, filterB: FilterSettings, pos: number): FilterSettings {\r\n\r\n        let lerpedFilter: FilterSettings = new FilterSettings();\r\n\r\n        // One setting or another is null, return the other.\r\n        if (filterA == null) {\r\n            return filterA;\r\n        }\r\n        if (filterB == null) {\r\n            return filterB;\r\n        }\r\n\r\n        pos = Math.max(0, Math.min(1, pos));\r\n\r\n        // Filter control points match in number and type\r\n        if (this.filtersCanMorph(filterA, filterB)) {\r\n            for (let i: number = 0; i < filterA.controlPointCount; i++) {\r\n                lerpedFilter.controlPoints[i] = new FilterControlPoint();\r\n                lerpedFilter.controlPoints[i].type = filterA.controlPoints[i].type;\r\n                lerpedFilter.controlPoints[i].freq = filterA.controlPoints[i].freq + (filterB.controlPoints[i].freq - filterA.controlPoints[i].freq) * pos;\r\n                lerpedFilter.controlPoints[i].gain = filterA.controlPoints[i].gain + (filterB.controlPoints[i].gain - filterA.controlPoints[i].gain) * pos;\r\n            }\r\n\r\n            lerpedFilter.controlPointCount = filterA.controlPointCount;\r\n\r\n            return lerpedFilter;\r\n        }\r\n        else {\r\n            // Not allowing morph of unmatching filters for now. It's a hornet's nest of problems, and I had it implemented and mostly working and it didn't sound very interesting since the shape becomes \"mushy\" in between\r\n            return (pos >= 1) ? filterB : filterA;\r\n        }\r\n        /*\r\n        // Filter control points do not match. Take all filterA points and move them to neutral at pos=1 (gain 7 for normal points, slide to edge and gain 7 for lo/hipass),\r\n        // and do the opposite for filterB points. Return a filter with points for both.\r\n        else {\r\n            let lerpedFilter: FilterSettings = new FilterSettings();\r\n            // Filter A's morph points\r\n            for (let i: number = 0; i < filterA.controlPointCount; i++) {\r\n                lerpedFilter.controlPoints[i] = new FilterControlPoint();\r\n                lerpedFilter.controlPoints[i].type = filterA.controlPoints[i].type;\r\n                lerpedFilter.controlPoints[i].gain = filterA.controlPoints[i].gain + (Config.filterGainCenter - filterA.controlPoints[i].gain) * pos;\r\n\r\n                if (filterA.controlPoints[i].type == FilterType.peak) {\r\n                    lerpedFilter.controlPoints[i].freq = filterA.controlPoints[i].freq;\r\n                }\r\n                else if (filterA.controlPoints[i].type == FilterType.highPass) {\r\n                    lerpedFilter.controlPoints[i].freq = filterA.controlPoints[i].freq * (1 - pos);\r\n                }\r\n                else {\r\n                    lerpedFilter.controlPoints[i].freq = filterA.controlPoints[i].freq + ((Config.filterFreqRange - 1) - filterA.controlPoints[i].freq) * pos;\r\n                }\r\n            }\r\n            // Filter B's morph points\r\n            for (let i: number = 0, j: number = filterA.controlPointCount; i < filterB.controlPointCount; i++, j++) {\r\n                lerpedFilter.controlPoints[j] = new FilterControlPoint();\r\n                lerpedFilter.controlPoints[j].type = filterB.controlPoints[i].type;\r\n                lerpedFilter.controlPoints[j].gain = filterB.controlPoints[i].gain + (Config.filterGainCenter - filterB.controlPoints[i].gain) * (1 - pos);\r\n\r\n                if (filterB.controlPoints[i].type == FilterType.peak) {\r\n                    lerpedFilter.controlPoints[j].freq = filterB.controlPoints[i].freq;\r\n                }\r\n                else if (filterB.controlPoints[i].type == FilterType.highPass) {\r\n                    lerpedFilter.controlPoints[j].freq = filterB.controlPoints[i].freq * pos;\r\n                }\r\n                else {\r\n                    lerpedFilter.controlPoints[j].freq = filterB.controlPoints[i].freq + ((Config.filterFreqRange - 1) - filterB.controlPoints[i].freq) * (1 - pos);\r\n                }\r\n            }\r\n\r\n            lerpedFilter.controlPointCount = filterA.controlPointCount + filterB.controlPointCount;\r\n\r\n            return lerpedFilter;\r\n        }\r\n        */\r\n    }\r\n\r\n    public convertLegacySettings(legacyCutoffSetting: number, legacyResonanceSetting: number, legacyEnv: Envelope): void {\r\n        this.reset();\r\n\r\n        const legacyFilterCutoffMaxHz: number = 8000; // This was carefully calculated to correspond to no change in response when filtering at 48000 samples per second... when using the legacy simplified low-pass filter.\r\n        const legacyFilterMax: number = 0.95;\r\n        const legacyFilterMaxRadians: number = Math.asin(legacyFilterMax / 2.0) * 2.0;\r\n        const legacyFilterMaxResonance: number = 0.95;\r\n        const legacyFilterCutoffRange: number = 11;\r\n        const legacyFilterResonanceRange: number = 8;\r\n\r\n        const resonant: boolean = (legacyResonanceSetting > 1);\r\n        const firstOrder: boolean = (legacyResonanceSetting == 0);\r\n        const cutoffAtMax: boolean = (legacyCutoffSetting == legacyFilterCutoffRange - 1);\r\n        const envDecays: boolean = (legacyEnv.type == EnvelopeType.flare || legacyEnv.type == EnvelopeType.twang || legacyEnv.type == EnvelopeType.decay || legacyEnv.type == EnvelopeType.noteSize);\r\n\r\n        const standardSampleRate: number = 48000;\r\n        const legacyHz: number = legacyFilterCutoffMaxHz * Math.pow(2.0, (legacyCutoffSetting - (legacyFilterCutoffRange - 1)) * 0.5);\r\n        const legacyRadians: number = Math.min(legacyFilterMaxRadians, 2 * Math.PI * legacyHz / standardSampleRate);\r\n\r\n        if (legacyEnv.type == EnvelopeType.none && !resonant && cutoffAtMax) {\r\n            // The response is flat and there's no envelopes, so don't even bother adding any control points.\r\n        } else if (firstOrder) {\r\n            // In general, a 1st order lowpass can be approximated by a 2nd order lowpass\r\n            // with a cutoff ~4 octaves higher (*16) and a gain of 1/16.\r\n            // However, BeepBox's original lowpass filters behaved oddly as they\r\n            // approach the nyquist frequency, so I've devised this curved conversion\r\n            // to guess at a perceptually appropriate new cutoff frequency and gain.\r\n            const extraOctaves: number = 3.5;\r\n            const targetRadians: number = legacyRadians * Math.pow(2.0, extraOctaves);\r\n            const curvedRadians: number = targetRadians / (1.0 + targetRadians / Math.PI);\r\n            const curvedHz: number = standardSampleRate * curvedRadians / (2.0 * Math.PI)\r\n            const freqSetting: number = FilterControlPoint.getRoundedSettingValueFromHz(curvedHz);\r\n            const finalHz: number = FilterControlPoint.getHzFromSettingValue(freqSetting);\r\n            const finalRadians: number = 2.0 * Math.PI * finalHz / standardSampleRate;\r\n\r\n            const legacyFilter: FilterCoefficients = new FilterCoefficients();\r\n            legacyFilter.lowPass1stOrderSimplified(legacyRadians);\r\n            const response: FrequencyResponse = new FrequencyResponse();\r\n            response.analyze(legacyFilter, finalRadians);\r\n            const legacyFilterGainAtNewRadians: number = response.magnitude();\r\n\r\n            let logGain: number = Math.log2(legacyFilterGainAtNewRadians);\r\n            // Bias slightly toward 2^(-extraOctaves):\r\n            logGain = -extraOctaves + (logGain + extraOctaves) * 0.82;\r\n            // Decaying envelopes move the cutoff frequency back into an area where the best approximation of the first order slope requires a lower gain setting.\r\n            if (envDecays) logGain = Math.min(logGain, -1.0);\r\n            const convertedGain: number = Math.pow(2.0, logGain);\r\n            const gainSetting: number = FilterControlPoint.getRoundedSettingValueFromLinearGain(convertedGain);\r\n\r\n            this.addPoint(FilterType.lowPass, freqSetting, gainSetting);\r\n        } else {\r\n            const intendedGain: number = 0.5 / (1.0 - legacyFilterMaxResonance * Math.sqrt(Math.max(0.0, legacyResonanceSetting - 1.0) / (legacyFilterResonanceRange - 2.0)));\r\n            const invertedGain: number = 0.5 / intendedGain;\r\n            const maxRadians: number = 2.0 * Math.PI * legacyFilterCutoffMaxHz / standardSampleRate;\r\n            const freqRatio: number = legacyRadians / maxRadians;\r\n            const targetRadians: number = legacyRadians * (freqRatio * Math.pow(invertedGain, 0.9) + 1.0);\r\n            const curvedRadians: number = legacyRadians + (targetRadians - legacyRadians) * invertedGain;\r\n            let curvedHz: number;\r\n            if (envDecays) {\r\n                curvedHz = standardSampleRate * Math.min(curvedRadians, legacyRadians * Math.pow(2, 0.25)) / (2.0 * Math.PI);\r\n            } else {\r\n                curvedHz = standardSampleRate * curvedRadians / (2.0 * Math.PI);\r\n            }\r\n            const freqSetting: number = FilterControlPoint.getRoundedSettingValueFromHz(curvedHz);\r\n\r\n            let legacyFilterGain: number;\r\n            if (envDecays) {\r\n                legacyFilterGain = intendedGain;\r\n            } else {\r\n                const legacyFilter: FilterCoefficients = new FilterCoefficients();\r\n                legacyFilter.lowPass2ndOrderSimplified(legacyRadians, intendedGain);\r\n                const response: FrequencyResponse = new FrequencyResponse();\r\n                response.analyze(legacyFilter, curvedRadians);\r\n                legacyFilterGain = response.magnitude();\r\n            }\r\n            if (!resonant) legacyFilterGain = Math.min(legacyFilterGain, Math.sqrt(0.5));\r\n            const gainSetting: number = FilterControlPoint.getRoundedSettingValueFromLinearGain(legacyFilterGain);\r\n\r\n            this.addPoint(FilterType.lowPass, freqSetting, gainSetting);\r\n        }\r\n\r\n        // Added for JummBox - making a 0 point filter does not truncate control points!\r\n        this.controlPoints.length = this.controlPointCount;\r\n    }\r\n\r\n    // Similar to above, but purpose-fit for quick conversions in synth calls.\r\n    public convertLegacySettingsForSynth(legacyCutoffSetting: number, legacyResonanceSetting: number, allowFirstOrder: boolean = false): void {\r\n        this.reset();\r\n\r\n        const legacyFilterCutoffMaxHz: number = 8000; // This was carefully calculated to correspond to no change in response when filtering at 48000 samples per second... when using the legacy simplified low-pass filter.\r\n        const legacyFilterMax: number = 0.95;\r\n        const legacyFilterMaxRadians: number = Math.asin(legacyFilterMax / 2.0) * 2.0;\r\n        const legacyFilterMaxResonance: number = 0.95;\r\n        const legacyFilterCutoffRange: number = 11;\r\n        const legacyFilterResonanceRange: number = 8;\r\n\r\n        const firstOrder: boolean = (legacyResonanceSetting == 0 && allowFirstOrder);\r\n        const standardSampleRate: number = 48000;\r\n        const legacyHz: number = legacyFilterCutoffMaxHz * Math.pow(2.0, (legacyCutoffSetting - (legacyFilterCutoffRange - 1)) * 0.5);\r\n        const legacyRadians: number = Math.min(legacyFilterMaxRadians, 2 * Math.PI * legacyHz / standardSampleRate);\r\n\r\n        if (firstOrder) {\r\n            // In general, a 1st order lowpass can be approximated by a 2nd order lowpass\r\n            // with a cutoff ~4 octaves higher (*16) and a gain of 1/16.\r\n            // However, BeepBox's original lowpass filters behaved oddly as they\r\n            // approach the nyquist frequency, so I've devised this curved conversion\r\n            // to guess at a perceptually appropriate new cutoff frequency and gain.\r\n            const extraOctaves: number = 3.5;\r\n            const targetRadians: number = legacyRadians * Math.pow(2.0, extraOctaves);\r\n            const curvedRadians: number = targetRadians / (1.0 + targetRadians / Math.PI);\r\n            const curvedHz: number = standardSampleRate * curvedRadians / (2.0 * Math.PI)\r\n            const freqSetting: number = FilterControlPoint.getRoundedSettingValueFromHz(curvedHz);\r\n            const finalHz: number = FilterControlPoint.getHzFromSettingValue(freqSetting);\r\n            const finalRadians: number = 2.0 * Math.PI * finalHz / standardSampleRate;\r\n\r\n            const legacyFilter: FilterCoefficients = new FilterCoefficients();\r\n            legacyFilter.lowPass1stOrderSimplified(legacyRadians);\r\n            const response: FrequencyResponse = new FrequencyResponse();\r\n            response.analyze(legacyFilter, finalRadians);\r\n            const legacyFilterGainAtNewRadians: number = response.magnitude();\r\n\r\n            let logGain: number = Math.log2(legacyFilterGainAtNewRadians);\r\n            // Bias slightly toward 2^(-extraOctaves):\r\n            logGain = -extraOctaves + (logGain + extraOctaves) * 0.82;\r\n            const convertedGain: number = Math.pow(2.0, logGain);\r\n            const gainSetting: number = FilterControlPoint.getRoundedSettingValueFromLinearGain(convertedGain);\r\n\r\n            this.addPoint(FilterType.lowPass, freqSetting, gainSetting);\r\n        } else {\r\n            const intendedGain: number = 0.5 / (1.0 - legacyFilterMaxResonance * Math.sqrt(Math.max(0.0, legacyResonanceSetting - 1.0) / (legacyFilterResonanceRange - 2.0)));\r\n            const invertedGain: number = 0.5 / intendedGain;\r\n            const maxRadians: number = 2.0 * Math.PI * legacyFilterCutoffMaxHz / standardSampleRate;\r\n            const freqRatio: number = legacyRadians / maxRadians;\r\n            const targetRadians: number = legacyRadians * (freqRatio * Math.pow(invertedGain, 0.9) + 1.0);\r\n            const curvedRadians: number = legacyRadians + (targetRadians - legacyRadians) * invertedGain;\r\n            let curvedHz: number;\r\n\r\n            curvedHz = standardSampleRate * curvedRadians / (2.0 * Math.PI);\r\n            const freqSetting: number = FilterControlPoint.getSettingValueFromHz(curvedHz);\r\n\r\n            let legacyFilterGain: number;\r\n\r\n            const legacyFilter: FilterCoefficients = new FilterCoefficients();\r\n            legacyFilter.lowPass2ndOrderSimplified(legacyRadians, intendedGain);\r\n            const response: FrequencyResponse = new FrequencyResponse();\r\n            response.analyze(legacyFilter, curvedRadians);\r\n            legacyFilterGain = response.magnitude();\r\n            const gainSetting: number = FilterControlPoint.getRoundedSettingValueFromLinearGain(legacyFilterGain);\r\n\r\n            this.addPoint(FilterType.lowPass, freqSetting, gainSetting);\r\n        }\r\n\r\n    }\r\n}\r\n\r\nexport class EnvelopeSettings {\r\n    public target: number = 0;\r\n    public index: number = 0;\r\n    public envelope: number = 0;\r\n\r\n    constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    reset(): void {\r\n        this.target = 0;\r\n        this.index = 0;\r\n        this.envelope = 0;\r\n    }\r\n\r\n    public toJsonObject(): Object {\r\n        const envelopeObject: any = {\r\n            \"target\": Config.instrumentAutomationTargets[this.target].name,\r\n            \"envelope\": Config.envelopes[this.envelope].name,\r\n        };\r\n        if (Config.instrumentAutomationTargets[this.target].maxCount > 1) {\r\n            envelopeObject[\"index\"] = this.index;\r\n        }\r\n        return envelopeObject;\r\n    }\r\n\r\n    public fromJsonObject(envelopeObject: any): void {\r\n        this.reset();\r\n\r\n        let target: AutomationTarget = Config.instrumentAutomationTargets.dictionary[envelopeObject[\"target\"]];\r\n        if (target == null) target = Config.instrumentAutomationTargets.dictionary[\"noteVolume\"];\r\n        this.target = target.index;\r\n\r\n        let envelope: Envelope = Config.envelopes.dictionary[envelopeObject[\"envelope\"]];\r\n        if (envelope == null) envelope = Config.envelopes.dictionary[\"none\"];\r\n        this.envelope = envelope.index;\r\n\r\n        if (envelopeObject[\"index\"] != undefined) {\r\n            this.index = clamp(0, Config.instrumentAutomationTargets[this.target].maxCount, envelopeObject[\"index\"] | 0);\r\n        } else {\r\n            this.index = 0;\r\n        }\r\n    }\r\n}\r\n\r\n// Settings that were available to old versions of BeepBox but are no longer available in the\r\n// current version that need to be reinterpreted as a group to determine the best way to\r\n// represent them in the current version.\r\ninterface LegacySettings {\r\n    filterCutoff?: number;\r\n    filterResonance?: number;\r\n    filterEnvelope?: Envelope;\r\n    pulseEnvelope?: Envelope;\r\n    operatorEnvelopes?: Envelope[];\r\n    feedbackEnvelope?: Envelope;\r\n}\r\n\r\nexport class Instrument {\r\n    public type: InstrumentType = InstrumentType.chip;\r\n    public preset: number = 0;\r\n    public chipWave: number = 2;\r\n    public chipNoise: number = 1;\r\n    public eqFilter: FilterSettings = new FilterSettings();\r\n    public eqFilterType: boolean = false;\r\n    public eqFilterSimpleCut: number = Config.filterSimpleCutRange - 1;\r\n    public eqFilterSimplePeak: number = 0;\r\n    public noteFilter: FilterSettings = new FilterSettings();\r\n    public noteFilterType: boolean = false;\r\n    public noteFilterSimpleCut: number = Config.filterSimpleCutRange - 1;\r\n    public noteFilterSimplePeak: number = 0;\r\n    public eqSubFilters: (FilterSettings | null)[] = [];\r\n    public noteSubFilters: (FilterSettings | null)[] = [];\r\n    public tmpEqFilterStart: FilterSettings | null;\r\n    public tmpEqFilterEnd: FilterSettings | null;\r\n    public tmpNoteFilterStart: FilterSettings | null;\r\n    public tmpNoteFilterEnd: FilterSettings | null;\r\n    public envelopes: EnvelopeSettings[] = [];\r\n    public fadeIn: number = 0;\r\n    public fadeOut: number = Config.fadeOutNeutral;\r\n    public envelopeCount: number = 0;\r\n    public transition: number = Config.transitions.dictionary[\"normal\"].index;\r\n    public pitchShift: number = 0;\r\n    public detune: number = 0;\r\n    public vibrato: number = 0;\r\n    public interval: number = 0;\r\n    public vibratoDepth: number = 0;\r\n    public vibratoSpeed: number = 10;\r\n    public vibratoDelay: number = 0;\r\n    public vibratoType: number = 0;\r\n    public unison: number = 0;\r\n    public effects: number = 0;\r\n    public chord: number = 1;\r\n    public volume: number = 0;\r\n    public pan: number = Config.panCenter;\r\n    public panDelay: number = 10;\r\n    public arpeggioSpeed: number = 12;\r\n    public fastTwoNoteArp: boolean = false;\r\n    public legacyTieOver: boolean = false;\r\n    public clicklessTransition: boolean = false;\r\n    public aliases: boolean = false;\r\n    public pulseWidth: number = Config.pulseWidthRange;\r\n    public stringSustain: number = 10;\r\n    public distortion: number = 0;\r\n    public bitcrusherFreq: number = 0;\r\n    public bitcrusherQuantization: number = 0;\r\n    public chorus: number = 0;\r\n    public reverb: number = 0;\r\n    public echoSustain: number = 0;\r\n    public echoDelay: number = 0;\r\n    public algorithm: number = 0;\r\n    public feedbackType: number = 0;\r\n    public feedbackAmplitude: number = 0;\r\n    public LFOtime: number = 0;\r\n    public nextLFOtime: number = 0;\r\n    public arpTime: number = 0;\r\n    public customChipWave: Float32Array = new Float32Array(64);\r\n    public customChipWaveIntegral: Float32Array = new Float32Array(65); // One extra element for wrap-around in chipSynth.\r\n    public readonly operators: Operator[] = [];\r\n    public readonly spectrumWave: SpectrumWave;\r\n    public readonly harmonicsWave: HarmonicsWave = new HarmonicsWave();\r\n    public readonly drumsetEnvelopes: number[] = [];\r\n    public readonly drumsetSpectrumWaves: SpectrumWave[] = [];\r\n    public modChannels: number[] = [];\r\n    public modInstruments: number[] = [];\r\n    public modulators: number[] = [];\r\n    public modFilterTypes: number[] = [];\r\n    public invalidModulators: boolean[] = [];\r\n\r\n    public invertWave: boolean = false;\r\n\r\n    public upperNoteLimit: number = Config.maxPitch;\r\n    public lowerNoteLimit: number = 0;\r\n\r\n    constructor(isNoiseChannel: boolean, isModChannel: boolean) {\r\n\r\n        if (isModChannel) {\r\n            for (let mod: number = 0; mod < Config.modCount; mod++) {\r\n                this.modChannels.push(0);\r\n                this.modInstruments.push(0);\r\n                this.modulators.push(Config.modulators.dictionary[\"none\"].index);\r\n            }\r\n        }\r\n\r\n        this.spectrumWave = new SpectrumWave(isNoiseChannel);\r\n        for (let i: number = 0; i < Config.operatorCount; i++) {\r\n            this.operators[i] = new Operator(i);\r\n        }\r\n        for (let i: number = 0; i < Config.drumCount; i++) {\r\n            this.drumsetEnvelopes[i] = Config.envelopes.dictionary[\"twang 2\"].index;\r\n            this.drumsetSpectrumWaves[i] = new SpectrumWave(true);\r\n        }\r\n\r\n        for (let i = 0; i < 64; i++) {\r\n            this.customChipWave[i] = 24 - Math.floor(i * (48 / 64));\r\n        }\r\n\r\n        let sum: number = 0.0;\r\n        for (let i: number = 0; i < this.customChipWave.length; i++) {\r\n            sum += this.customChipWave[i];\r\n        }\r\n        const average: number = sum / this.customChipWave.length;\r\n\r\n        // Perform the integral on the wave. The chipSynth will perform the derivative to get the original wave back but with antialiasing.\r\n        let cumulative: number = 0;\r\n        let wavePrev: number = 0;\r\n        for (let i: number = 0; i < this.customChipWave.length; i++) {\r\n            cumulative += wavePrev;\r\n            wavePrev = this.customChipWave[i] - average;\r\n            this.customChipWaveIntegral[i] = cumulative;\r\n        }\r\n\r\n        // 65th, last sample is for anti-aliasing\r\n        this.customChipWaveIntegral[64] = 0.0;\r\n\r\n    }\r\n\r\n    public setTypeAndReset(type: InstrumentType, isNoiseChannel: boolean, isModChannel: boolean): void {\r\n        // Mod channels are forced to one type.\r\n        if (isModChannel) type = InstrumentType.mod;\r\n        this.type = type;\r\n        this.preset = type;\r\n        this.volume = 0;\r\n        this.effects = (1 << EffectType.panning); // Panning enabled by default in JB.\r\n        this.chorus = Config.chorusRange - 1;\r\n        this.reverb = 0;\r\n        this.echoSustain = Math.floor((Config.echoSustainRange - 1) * 0.5);\r\n        this.echoDelay = Math.floor((Config.echoDelayRange - 1) * 0.5);\r\n        this.eqFilter.reset();\r\n        this.eqFilterType = false;\r\n        this.eqFilterSimpleCut = Config.filterSimpleCutRange - 1;\r\n        this.eqFilterSimplePeak = 0;\r\n        for (let i: number = 0; i < Config.filterMorphCount; i++) {\r\n            this.eqSubFilters[i] = null;\r\n            this.noteSubFilters[i] = null;\r\n        }\r\n        this.noteFilter.reset();\r\n        this.noteFilterType = false;\r\n        this.noteFilterSimpleCut = Config.filterSimpleCutRange - 1;\r\n        this.noteFilterSimplePeak = 0;\r\n        this.distortion = Math.floor((Config.distortionRange - 1) * 0.75);\r\n        this.bitcrusherFreq = Math.floor((Config.bitcrusherFreqRange - 1) * 0.5)\r\n        this.bitcrusherQuantization = Math.floor((Config.bitcrusherQuantizationRange - 1) * 0.5);\r\n        this.pan = Config.panCenter;\r\n        this.panDelay = 10;\r\n        this.pitchShift = Config.pitchShiftCenter;\r\n        this.detune = Config.detuneCenter;\r\n        this.vibrato = 0;\r\n        this.unison = 0;\r\n        this.stringSustain = 10;\r\n        this.clicklessTransition = false;\r\n        this.arpeggioSpeed = 12;\r\n        this.legacyTieOver = false;\r\n        this.aliases = false;\r\n        this.fadeIn = 0;\r\n        this.fadeOut = Config.fadeOutNeutral;\r\n        this.transition = Config.transitions.dictionary[\"normal\"].index;\r\n        this.envelopeCount = 0;\r\n\r\n        this.upperNoteLimit = Config.maxPitch;\r\n        this.lowerNoteLimit = 0;\r\n\r\n        this.invertWave = false;\r\n        switch (type) {\r\n            case InstrumentType.chip:\r\n                this.chipWave = 2;\r\n                // TODO: enable the chord effect?\r\n                this.chord = Config.chords.dictionary[\"arpeggio\"].index;\r\n                break;\r\n            case InstrumentType.customChipWave:\r\n                this.chipWave = 2;\r\n                this.chord = Config.chords.dictionary[\"arpeggio\"].index;\r\n                for (let i: number = 0; i < 64; i++) {\r\n                    this.customChipWave[i] = 24 - (Math.floor(i * (48 / 64)));\r\n                }\r\n\r\n                let sum: number = 0.0;\r\n                for (let i: number = 0; i < this.customChipWave.length; i++) {\r\n                    sum += this.customChipWave[i];\r\n                }\r\n                const average: number = sum / this.customChipWave.length;\r\n\r\n                // Perform the integral on the wave. The chipSynth will perform the derivative to get the original wave back but with antialiasing.\r\n                let cumulative: number = 0;\r\n                let wavePrev: number = 0;\r\n                for (let i: number = 0; i < this.customChipWave.length; i++) {\r\n                    cumulative += wavePrev;\r\n                    wavePrev = this.customChipWave[i] - average;\r\n                    this.customChipWaveIntegral[i] = cumulative;\r\n                }\r\n\r\n                this.customChipWaveIntegral[64] = 0.0;\r\n                break;\r\n            case InstrumentType.fm:\r\n                this.chord = Config.chords.dictionary[\"custom interval\"].index;\r\n                this.algorithm = 0;\r\n                this.feedbackType = 0;\r\n                this.feedbackAmplitude = 0;\r\n                for (let i: number = 0; i < this.operators.length; i++) {\r\n                    this.operators[i].reset(i);\r\n                }\r\n                break;\r\n            case InstrumentType.noise:\r\n                this.chipNoise = 1;\r\n                this.chord = Config.chords.dictionary[\"arpeggio\"].index;\r\n                break;\r\n            case InstrumentType.spectrum:\r\n                this.chord = Config.chords.dictionary[\"simultaneous\"].index;\r\n                this.spectrumWave.reset(isNoiseChannel);\r\n                break;\r\n            case InstrumentType.drumset:\r\n                this.chord = Config.chords.dictionary[\"simultaneous\"].index;\r\n                for (let i: number = 0; i < Config.drumCount; i++) {\r\n                    this.drumsetEnvelopes[i] = Config.envelopes.dictionary[\"twang 2\"].index;\r\n                    if (this.drumsetSpectrumWaves[i] == undefined) {\r\n                        this.drumsetSpectrumWaves[i] = new SpectrumWave(true);\r\n                    }\r\n                    this.drumsetSpectrumWaves[i].reset(isNoiseChannel);\r\n                }\r\n                break;\r\n            case InstrumentType.harmonics:\r\n                this.chord = Config.chords.dictionary[\"simultaneous\"].index;\r\n                this.harmonicsWave.reset();\r\n                break;\r\n            case InstrumentType.pwm:\r\n                this.chord = Config.chords.dictionary[\"arpeggio\"].index;\r\n                this.pulseWidth = Config.pulseWidthRange;\r\n                break;\r\n            case InstrumentType.pickedString:\r\n                this.chord = Config.chords.dictionary[\"strum\"].index;\r\n                this.harmonicsWave.reset();\r\n                break;\r\n            case InstrumentType.mod:\r\n                this.transition = 0;\r\n                this.vibrato = 0;\r\n                this.interval = 0;\r\n                this.effects = 0;\r\n                this.chord = 0;\r\n                this.modChannels = [];\r\n                this.modInstruments = [];\r\n                this.modulators = [];\r\n                for (let mod: number = 0; mod < Config.modCount; mod++) {\r\n                    this.modChannels.push(-2);\r\n                    this.modInstruments.push(0);\r\n                    this.modulators.push(Config.modulators.dictionary[\"none\"].index);\r\n                    this.invalidModulators[mod] = false;\r\n                    this.modFilterTypes[mod] = 0;\r\n                }\r\n                break;\r\n            default:\r\n                throw new Error(\"Unrecognized instrument type: \" + type);\r\n        }\r\n        // Chip/noise instruments had arpeggio and FM had custom interval but neither\r\n        // explicitly saved the chorus setting beforeSeven so enable it here. The effects\r\n        // will otherwise get overridden when reading SongTagCode.startInstrument.\r\n        if (this.chord != Config.chords.dictionary[\"simultaneous\"].index) {\r\n            // Enable chord if it was used.\r\n            this.effects = (this.effects | (1 << EffectType.chord));\r\n        }\r\n    }\r\n\r\n    // (only) difference for JummBox: Returns whether or not the note filter was chosen for filter conversion.\r\n    public convertLegacySettings(legacySettings: LegacySettings, forceSimpleFilter: boolean): void {\r\n        let legacyCutoffSetting: number | undefined = legacySettings.filterCutoff;\r\n        let legacyResonanceSetting: number | undefined = legacySettings.filterResonance;\r\n        let legacyFilterEnv: Envelope | undefined = legacySettings.filterEnvelope;\r\n        let legacyPulseEnv: Envelope | undefined = legacySettings.pulseEnvelope;\r\n        let legacyOperatorEnvelopes: Envelope[] | undefined = legacySettings.operatorEnvelopes;\r\n        let legacyFeedbackEnv: Envelope | undefined = legacySettings.feedbackEnvelope;\r\n\r\n        // legacy defaults:\r\n        if (legacyCutoffSetting == undefined) legacyCutoffSetting = (this.type == InstrumentType.chip) ? 6 : 10;\r\n        if (legacyResonanceSetting == undefined) legacyResonanceSetting = 0;\r\n        if (legacyFilterEnv == undefined) legacyFilterEnv = Config.envelopes.dictionary[\"none\"];\r\n        if (legacyPulseEnv == undefined) legacyPulseEnv = Config.envelopes.dictionary[(this.type == InstrumentType.pwm) ? \"twang 2\" : \"none\"];\r\n        if (legacyOperatorEnvelopes == undefined) legacyOperatorEnvelopes = [Config.envelopes.dictionary[(this.type == InstrumentType.fm) ? \"note size\" : \"none\"], Config.envelopes.dictionary[\"none\"], Config.envelopes.dictionary[\"none\"], Config.envelopes.dictionary[\"none\"]];\r\n        if (legacyFeedbackEnv == undefined) legacyFeedbackEnv = Config.envelopes.dictionary[\"none\"];\r\n\r\n        // The \"punch\" envelope is special: it goes *above* the chosen cutoff. But if the cutoff was already at the max, it couldn't go any higher... except in the current version of BeepBox I raised the max cutoff so it *can* but then it sounds different, so to preserve the original sound let's just remove the punch envelope.\r\n        const legacyFilterCutoffRange: number = 11;\r\n        const cutoffAtMax: boolean = (legacyCutoffSetting == legacyFilterCutoffRange - 1);\r\n        if (cutoffAtMax && legacyFilterEnv.type == EnvelopeType.punch) legacyFilterEnv = Config.envelopes.dictionary[\"none\"];\r\n\r\n        const carrierCount: number = Config.algorithms[this.algorithm].carrierCount;\r\n        let noCarriersControlledByNoteSize: boolean = true;\r\n        let allCarriersControlledByNoteSize: boolean = true;\r\n        let noteSizeControlsSomethingElse: boolean = (legacyFilterEnv.type == EnvelopeType.noteSize) || (legacyPulseEnv.type == EnvelopeType.noteSize);\r\n        if (this.type == InstrumentType.fm) {\r\n            noteSizeControlsSomethingElse = noteSizeControlsSomethingElse || (legacyFeedbackEnv.type == EnvelopeType.noteSize);\r\n            for (let i: number = 0; i < legacyOperatorEnvelopes.length; i++) {\r\n                if (i < carrierCount) {\r\n                    if (legacyOperatorEnvelopes[i].type != EnvelopeType.noteSize) {\r\n                        allCarriersControlledByNoteSize = false;\r\n                    } else {\r\n                        noCarriersControlledByNoteSize = false;\r\n                    }\r\n                } else {\r\n                    noteSizeControlsSomethingElse = noteSizeControlsSomethingElse || (legacyOperatorEnvelopes[i].type == EnvelopeType.noteSize);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.envelopeCount = 0;\r\n\r\n        if (this.type == InstrumentType.fm) {\r\n            if (allCarriersControlledByNoteSize && noteSizeControlsSomethingElse) {\r\n                this.addEnvelope(Config.instrumentAutomationTargets.dictionary[\"noteVolume\"].index, 0, Config.envelopes.dictionary[\"note size\"].index);\r\n            } else if (noCarriersControlledByNoteSize && !noteSizeControlsSomethingElse) {\r\n                this.addEnvelope(Config.instrumentAutomationTargets.dictionary[\"none\"].index, 0, Config.envelopes.dictionary[\"note size\"].index);\r\n            }\r\n        }\r\n\r\n        if (legacyFilterEnv.type == EnvelopeType.none) {\r\n            this.noteFilter.reset();\r\n            this.noteFilterType = false;\r\n            this.eqFilter.convertLegacySettings(legacyCutoffSetting, legacyResonanceSetting, legacyFilterEnv);\r\n            this.effects &= ~(1 << EffectType.noteFilter);\r\n            if (forceSimpleFilter || this.eqFilterType) {\r\n                this.eqFilterType = true;\r\n                this.eqFilterSimpleCut = legacyCutoffSetting;\r\n                this.eqFilterSimplePeak = legacyResonanceSetting;\r\n            }\r\n        } else {\r\n            this.eqFilter.reset();\r\n\r\n            this.eqFilterType = false;\r\n            this.noteFilterType = false;\r\n            this.noteFilter.convertLegacySettings(legacyCutoffSetting, legacyResonanceSetting, legacyFilterEnv);\r\n            this.effects |= 1 << EffectType.noteFilter;\r\n            this.addEnvelope(Config.instrumentAutomationTargets.dictionary[\"noteFilterAllFreqs\"].index, 0, legacyFilterEnv.index);\r\n            if (forceSimpleFilter || this.noteFilterType) {\r\n                this.noteFilterType = true;\r\n                this.noteFilterSimpleCut = legacyCutoffSetting;\r\n                this.noteFilterSimplePeak = legacyResonanceSetting;\r\n            }\r\n        }\r\n\r\n        if (legacyPulseEnv.type != EnvelopeType.none) {\r\n            this.addEnvelope(Config.instrumentAutomationTargets.dictionary[\"pulseWidth\"].index, 0, legacyPulseEnv.index);\r\n        }\r\n\r\n        for (let i: number = 0; i < legacyOperatorEnvelopes.length; i++) {\r\n            if (i < carrierCount && allCarriersControlledByNoteSize) continue;\r\n            if (legacyOperatorEnvelopes[i].type != EnvelopeType.none) {\r\n                this.addEnvelope(Config.instrumentAutomationTargets.dictionary[\"operatorAmplitude\"].index, i, legacyOperatorEnvelopes[i].index);\r\n            }\r\n        }\r\n\r\n        if (legacyFeedbackEnv.type != EnvelopeType.none) {\r\n            this.addEnvelope(Config.instrumentAutomationTargets.dictionary[\"feedbackAmplitude\"].index, 0, legacyFeedbackEnv.index);\r\n        }\r\n    }\r\n\r\n    public toJsonObject(): Object {\r\n        const instrumentObject: any = {\r\n            \"type\": Config.instrumentTypeNames[this.type],\r\n            \"volume\": this.volume,\r\n            \"eqFilter\": this.eqFilter.toJsonObject(),\r\n            \"eqFilterType\": this.eqFilterType,\r\n            \"eqSimpleCut\": this.eqFilterSimpleCut,\r\n            \"eqSimplePeak\": this.eqFilterSimplePeak\r\n        };\r\n\r\n        if (this.preset != this.type) {\r\n            instrumentObject[\"preset\"] = this.preset;\r\n        }\r\n\r\n        for (let i: number = 0; i < Config.filterMorphCount; i++) {\r\n            if (this.eqSubFilters[i] != null)\r\n                instrumentObject[\"eqSubFilters\" + i] = this.eqSubFilters[i]!.toJsonObject();\r\n        }\r\n\r\n        const effects: string[] = [];\r\n        for (const effect of Config.effectOrder) {\r\n            if (this.effects & (1 << effect)) {\r\n                effects.push(Config.effectNames[effect]);\r\n            }\r\n        }\r\n        instrumentObject[\"effects\"] = effects;\r\n\r\n\r\n        if (effectsIncludeTransition(this.effects)) {\r\n            instrumentObject[\"transition\"] = Config.transitions[this.transition].name;\r\n            instrumentObject[\"clicklessTransition\"] = this.clicklessTransition;\r\n        }\r\n        if (effectsIncludeChord(this.effects)) {\r\n            instrumentObject[\"chord\"] = this.getChord().name;\r\n            instrumentObject[\"fastTwoNoteArp\"] = this.fastTwoNoteArp;\r\n            instrumentObject[\"arpeggioSpeed\"] = this.arpeggioSpeed;\r\n        }\r\n        if (effectsIncludePitchShift(this.effects)) {\r\n            instrumentObject[\"pitchShiftSemitones\"] = this.pitchShift;\r\n        }\r\n        if (effectsIncludeDetune(this.effects)) {\r\n            instrumentObject[\"detuneCents\"] = Synth.detuneToCents(this.detune);\r\n        }\r\n        if (effectsIncludeVibrato(this.effects)) {\r\n            if (this.vibrato == -1) {\r\n                this.vibrato = 5;\r\n            }\r\n            if (this.vibrato != 5) {\r\n                instrumentObject[\"vibrato\"] = Config.vibratos[this.vibrato].name;\r\n            } else {\r\n                instrumentObject[\"vibrato\"] = \"custom\";\r\n            }\r\n            instrumentObject[\"vibratoDepth\"] = this.vibratoDepth;\r\n            instrumentObject[\"vibratoDelay\"] = this.vibratoDelay;\r\n            instrumentObject[\"vibratoSpeed\"] = this.vibratoSpeed;\r\n            instrumentObject[\"vibratoType\"] = this.vibratoType;\r\n        }\r\n        if (effectsIncludeNoteFilter(this.effects)) {\r\n            instrumentObject[\"noteFilterType\"] = this.noteFilterType;\r\n            instrumentObject[\"noteSimpleCut\"] = this.noteFilterSimpleCut;\r\n            instrumentObject[\"noteSimplePeak\"] = this.noteFilterSimplePeak;\r\n            instrumentObject[\"noteFilter\"] = this.noteFilter.toJsonObject();\r\n\r\n            for (let i: number = 0; i < Config.filterMorphCount; i++) {\r\n                if (this.noteSubFilters[i] != null)\r\n                    instrumentObject[\"noteSubFilters\" + i] = this.noteSubFilters[i]!.toJsonObject();\r\n            }\r\n        }\r\n        if (effectsIncludeDistortion(this.effects)) {\r\n            instrumentObject[\"distortion\"] = Math.round(100 * this.distortion / (Config.distortionRange - 1));\r\n            instrumentObject[\"aliases\"] = this.aliases;\r\n        }\r\n        if (effectsIncludeBitcrusher(this.effects)) {\r\n            instrumentObject[\"bitcrusherOctave\"] = (Config.bitcrusherFreqRange - 1 - this.bitcrusherFreq) * Config.bitcrusherOctaveStep;\r\n            instrumentObject[\"bitcrusherQuantization\"] = Math.round(100 * this.bitcrusherQuantization / (Config.bitcrusherQuantizationRange - 1));\r\n        }\r\n        if (effectsIncludePanning(this.effects)) {\r\n            instrumentObject[\"pan\"] = Math.round(100 * (this.pan - Config.panCenter) / Config.panCenter);\r\n            instrumentObject[\"panDelay\"] = this.panDelay;\r\n        }\r\n        if (effectsIncludeChorus(this.effects)) {\r\n            instrumentObject[\"chorus\"] = Math.round(100 * this.chorus / (Config.chorusRange - 1));\r\n        }\r\n        if (effectsIncludeEcho(this.effects)) {\r\n            instrumentObject[\"echoSustain\"] = Math.round(100 * this.echoSustain / (Config.echoSustainRange - 1));\r\n            instrumentObject[\"echoDelayBeats\"] = Math.round(1000 * (this.echoDelay + 1) * Config.echoDelayStepTicks / (Config.ticksPerPart * Config.partsPerBeat)) / 1000;\r\n        }\r\n        if (effectsIncludeReverb(this.effects)) {\r\n            instrumentObject[\"reverb\"] = Math.round(100 * this.reverb / (Config.reverbRange - 1));\r\n        }\r\n        if (effectsIncludeNoteRange(this.effects)) {\r\n            instrumentObject[\"upperNoteLimit\"] = this.upperNoteLimit;\r\n            instrumentObject[\"lowerNoteLimit\"] = this.lowerNoteLimit;\r\n        }\r\n        if (effectsIncludeInvertWave(this.effects)) {\r\n            instrumentObject[\"invertWave\"] = this.invertWave;\r\n        }\r\n\r\n        if (this.type != InstrumentType.drumset) {\r\n            instrumentObject[\"fadeInSeconds\"] = Math.round(10000 * Synth.fadeInSettingToSeconds(this.fadeIn)) / 10000;\r\n            instrumentObject[\"fadeOutTicks\"] = Synth.fadeOutSettingToTicks(this.fadeOut);\r\n        }\r\n\r\n        if (this.type == InstrumentType.harmonics || this.type == InstrumentType.pickedString) {\r\n            instrumentObject[\"harmonics\"] = [];\r\n            for (let i: number = 0; i < Config.harmonicsControlPoints; i++) {\r\n                instrumentObject[\"harmonics\"][i] = Math.round(100 * this.harmonicsWave.harmonics[i] / Config.harmonicsMax);\r\n            }\r\n        }\r\n\r\n        if (this.type == InstrumentType.noise) {\r\n            instrumentObject[\"wave\"] = Config.chipNoises[this.chipNoise].name;\r\n        } else if (this.type == InstrumentType.spectrum) {\r\n            instrumentObject[\"spectrum\"] = [];\r\n            for (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n                instrumentObject[\"spectrum\"][i] = Math.round(100 * this.spectrumWave.spectrum[i] / Config.spectrumMax);\r\n            }\r\n        } else if (this.type == InstrumentType.drumset) {\r\n            instrumentObject[\"drums\"] = [];\r\n            for (let j: number = 0; j < Config.drumCount; j++) {\r\n                const spectrum: number[] = [];\r\n                for (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n                    spectrum[i] = Math.round(100 * this.drumsetSpectrumWaves[j].spectrum[i] / Config.spectrumMax);\r\n                }\r\n                instrumentObject[\"drums\"][j] = {\r\n                    \"filterEnvelope\": this.getDrumsetEnvelope(j).name,\r\n                    \"spectrum\": spectrum,\r\n                };\r\n            }\r\n        } else if (this.type == InstrumentType.chip) {\r\n            instrumentObject[\"wave\"] = Config.chipWaves[this.chipWave].name;\r\n            instrumentObject[\"unison\"] = Config.unisons[this.unison].name;\r\n        } else if (this.type == InstrumentType.pwm) {\r\n            instrumentObject[\"pulseWidth\"] = this.pulseWidth;\r\n        } else if (this.type == InstrumentType.pickedString) {\r\n            instrumentObject[\"unison\"] = Config.unisons[this.unison].name;\r\n            instrumentObject[\"stringSustain\"] = Math.round(100 * this.stringSustain / (Config.stringSustainRange - 1));\r\n        } else if (this.type == InstrumentType.harmonics) {\r\n            instrumentObject[\"unison\"] = Config.unisons[this.unison].name;\r\n        } else if (this.type == InstrumentType.fm) {\r\n            const operatorArray: Object[] = [];\r\n            for (const operator of this.operators) {\r\n                operatorArray.push({\r\n                    \"frequency\": Config.operatorFrequencies[operator.frequency].name,\r\n                    \"amplitude\": operator.amplitude,\r\n                    \"waveform\": Config.operatorWaves[operator.waveform].name,\r\n                    \"pulseWidth\": operator.pulseWidth,\r\n                });\r\n            }\r\n            instrumentObject[\"algorithm\"] = Config.algorithms[this.algorithm].name;\r\n            instrumentObject[\"feedbackType\"] = Config.feedbacks[this.feedbackType].name;\r\n            instrumentObject[\"feedbackAmplitude\"] = this.feedbackAmplitude;\r\n            instrumentObject[\"operators\"] = operatorArray;\r\n        } else if (this.type == InstrumentType.customChipWave) {\r\n            instrumentObject[\"wave\"] = Config.chipWaves[this.chipWave].name;\r\n            instrumentObject[\"unison\"] = Config.unisons[this.unison].name;\r\n            instrumentObject[\"customChipWave\"] = new Float64Array(64);\r\n            instrumentObject[\"customChipWaveIntegral\"] = new Float64Array(65);\r\n            for (let i: number = 0; i < this.customChipWave.length; i++) {\r\n                instrumentObject[\"customChipWave\"][i] = this.customChipWave[i];\r\n                // Meh, waste of space and can be inaccurate. It will be recalc'ed when instrument loads.\r\n                //instrumentObject[\"customChipWaveIntegral\"][i] = this.customChipWaveIntegral[i];\r\n            }\r\n        } else if (this.type == InstrumentType.mod) {\r\n            instrumentObject[\"modChannels\"] = [];\r\n            instrumentObject[\"modInstruments\"] = [];\r\n            instrumentObject[\"modSettings\"] = [];\r\n            instrumentObject[\"modStatuses\"] = [];\r\n            for (let mod: number = 0; mod < Config.modCount; mod++) {\r\n                instrumentObject[\"modChannels\"][mod] = this.modChannels[mod];\r\n                instrumentObject[\"modInstruments\"][mod] = this.modInstruments[mod];\r\n                instrumentObject[\"modSettings\"][mod] = this.modulators[mod];\r\n            }\r\n        } else {\r\n            throw new Error(\"Unrecognized instrument type\");\r\n        }\r\n\r\n        const envelopes: any[] = [];\r\n        for (let i = 0; i < this.envelopeCount; i++) {\r\n            envelopes.push(this.envelopes[i].toJsonObject());\r\n        }\r\n        instrumentObject[\"envelopes\"] = envelopes;\r\n\r\n        return instrumentObject;\r\n    }\r\n\r\n\r\n    public fromJsonObject(instrumentObject: any, isNoiseChannel: boolean, isModChannel: boolean, useSlowerRhythm: boolean, useFastTwoNoteArp: boolean, legacyGlobalReverb: number = 0): void {\r\n        if (instrumentObject == undefined) instrumentObject = {};\r\n\r\n        let type: InstrumentType = Config.instrumentTypeNames.indexOf(instrumentObject[\"type\"]);\r\n        if (<any>type == -1) type = isModChannel ? InstrumentType.mod : (isNoiseChannel ? InstrumentType.noise : InstrumentType.chip);\r\n        this.setTypeAndReset(type, isNoiseChannel, isModChannel);\r\n\r\n        if (instrumentObject[\"preset\"] != undefined) {\r\n            this.preset = instrumentObject[\"preset\"] >>> 0;\r\n        }\r\n\r\n        if (instrumentObject[\"volume\"] != undefined) {\r\n            this.volume = clamp(-Config.volumeRange / 2, (Config.volumeRange / 2) + 1, instrumentObject[\"volume\"] | 0);\r\n        } else {\r\n            this.volume = 0;\r\n        }\r\n\r\n        if (Array.isArray(instrumentObject[\"effects\"])) {\r\n            let effects: number = 0;\r\n            for (let i: number = 0; i < instrumentObject[\"effects\"].length; i++) {\r\n                effects = effects | (1 << Config.effectNames.indexOf(instrumentObject[\"effects\"][i]));\r\n            }\r\n            this.effects = (effects & ((1 << EffectType.length) - 1));\r\n        } else {\r\n            // The index of these names is reinterpreted as a bitfield, which relies on reverb and chorus being the first effects!\r\n            const legacyEffectsNames: string[] = [\"none\", \"reverb\", \"chorus\", \"chorus & reverb\"];\r\n            this.effects = legacyEffectsNames.indexOf(instrumentObject[\"effects\"]);\r\n            if (this.effects == -1) this.effects = (this.type == InstrumentType.noise) ? 0 : 1;\r\n        }\r\n\r\n        this.transition = Config.transitions.dictionary[\"normal\"].index; // default value.\r\n        const transitionProperty: any = instrumentObject[\"transition\"] || instrumentObject[\"envelope\"]; // the transition property used to be called envelope, so check that too.\r\n        if (transitionProperty != undefined) {\r\n            let transition: Transition | undefined = Config.transitions.dictionary[transitionProperty];\r\n            if (instrumentObject[\"fadeInSeconds\"] == undefined || instrumentObject[\"fadeOutTicks\"] == undefined) {\r\n                const legacySettings = (<any>{\r\n                    \"binary\": { transition: \"interrupt\", fadeInSeconds: 0.0, fadeOutTicks: -1 },\r\n                    \"seamless\": { transition: \"interrupt\", fadeInSeconds: 0.0, fadeOutTicks: -1 },\r\n                    \"sudden\": { transition: \"normal\", fadeInSeconds: 0.0, fadeOutTicks: -3 },\r\n                    \"hard\": { transition: \"normal\", fadeInSeconds: 0.0, fadeOutTicks: -3 },\r\n                    \"smooth\": { transition: \"normal\", fadeInSeconds: 0.025, fadeOutTicks: -3 },\r\n                    \"soft\": { transition: \"normal\", fadeInSeconds: 0.025, fadeOutTicks: -3 },\r\n                    // Note that the old slide transition has the same name as a new slide transition that is different.\r\n                    // Only apply legacy settings if the instrument JSON was created before, based on the presence\r\n                    // of the fade in/out fields.\r\n                    \"slide\": { transition: \"slide in pattern\", fadeInSeconds: 0.025, fadeOutTicks: -3 },\r\n                    \"cross fade\": { transition: \"normal\", fadeInSeconds: 0.04, fadeOutTicks: 6 },\r\n                    \"hard fade\": { transition: \"normal\", fadeInSeconds: 0.0, fadeOutTicks: 48 },\r\n                    \"medium fade\": { transition: \"normal\", fadeInSeconds: 0.0125, fadeOutTicks: 72 },\r\n                    \"soft fade\": { transition: \"normal\", fadeInSeconds: 0.06, fadeOutTicks: 96 },\r\n                })[transitionProperty];\r\n                if (legacySettings != undefined) {\r\n                    transition = Config.transitions.dictionary[legacySettings.transition];\r\n                    // These may be overridden below.\r\n                    this.fadeIn = Synth.secondsToFadeInSetting(legacySettings.fadeInSeconds);\r\n                    this.fadeOut = Synth.ticksToFadeOutSetting(legacySettings.fadeOutTicks);\r\n                }\r\n            }\r\n            if (transition != undefined) this.transition = transition.index;\r\n\r\n            if (this.transition != Config.transitions.dictionary[\"normal\"].index) {\r\n                // Enable transition if it was used.\r\n                this.effects = (this.effects | (1 << EffectType.transition));\r\n            }\r\n        }\r\n\r\n        // Overrides legacy settings in transition above.\r\n        if (instrumentObject[\"fadeInSeconds\"] != undefined) {\r\n            this.fadeIn = Synth.secondsToFadeInSetting(+instrumentObject[\"fadeInSeconds\"]);\r\n        }\r\n        if (instrumentObject[\"fadeOutTicks\"] != undefined) {\r\n            this.fadeOut = Synth.ticksToFadeOutSetting(+instrumentObject[\"fadeOutTicks\"]);\r\n        }\r\n\r\n        {\r\n            // Note that the chord setting may be overridden by instrumentObject[\"chorus\"] below.\r\n            const chordProperty: any = instrumentObject[\"chord\"];\r\n            const legacyChordNames: Dictionary<string> = { \"harmony\": \"simultaneous\" };\r\n            const chord: Chord | undefined = Config.chords.dictionary[legacyChordNames[chordProperty]] || Config.chords.dictionary[chordProperty];\r\n            if (chord != undefined) {\r\n                this.chord = chord.index;\r\n            } else {\r\n                // Different instruments have different default chord types based on historical behaviour.\r\n                if (this.type == InstrumentType.noise) {\r\n                    this.chord = Config.chords.dictionary[\"arpeggio\"].index;\r\n                } else if (this.type == InstrumentType.pickedString) {\r\n                    this.chord = Config.chords.dictionary[\"strum\"].index;\r\n                } else if (this.type == InstrumentType.chip) {\r\n                    this.chord = Config.chords.dictionary[\"arpeggio\"].index;\r\n                } else if (this.type == InstrumentType.fm) {\r\n                    this.chord = Config.chords.dictionary[\"custom interval\"].index;\r\n                } else {\r\n                    this.chord = Config.chords.dictionary[\"simultaneous\"].index;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.unison = Config.unisons.dictionary[\"none\"].index; // default value.\r\n        const unisonProperty: any = instrumentObject[\"unison\"] || instrumentObject[\"interval\"] || instrumentObject[\"chorus\"]; // The unison property has gone by various names in the past.\r\n        if (unisonProperty != undefined) {\r\n            const legacyChorusNames: Dictionary<string> = { \"union\": \"none\", \"fifths\": \"fifth\", \"octaves\": \"octave\" };\r\n            const unison: Unison | undefined = Config.unisons.dictionary[legacyChorusNames[unisonProperty]] || Config.unisons.dictionary[unisonProperty];\r\n            if (unison != undefined) this.unison = unison.index;\r\n        }\r\n        if (instrumentObject[\"chorus\"] == \"custom harmony\") {\r\n            // The original chorus setting had an option that now maps to two different settings. Override those if necessary.\r\n            this.unison = Config.unisons.dictionary[\"hum\"].index;\r\n            this.chord = Config.chords.dictionary[\"custom interval\"].index;\r\n        }\r\n        if (this.chord != Config.chords.dictionary[\"simultaneous\"].index && !Array.isArray(instrumentObject[\"effects\"])) {\r\n            // Enable chord if it was used.\r\n            this.effects = (this.effects | (1 << EffectType.chord));\r\n        }\r\n\r\n        if (instrumentObject[\"pitchShiftSemitones\"] != undefined) {\r\n            this.pitchShift = clamp(0, Config.pitchShiftRange, Math.round(+instrumentObject[\"pitchShiftSemitones\"]));\r\n        }\r\n        if (instrumentObject[\"detuneCents\"] != undefined) {\r\n            this.detune = clamp(Config.detuneMin, Config.detuneMax + 1, Math.round(Synth.centsToDetune(+instrumentObject[\"detuneCents\"])));\r\n        }\r\n\r\n        this.vibrato = Config.vibratos.dictionary[\"none\"].index; // default value.\r\n        const vibratoProperty: any = instrumentObject[\"vibrato\"] || instrumentObject[\"effect\"]; // The vibrato property was previously called \"effect\", not to be confused with the current \"effects\".\r\n        if (vibratoProperty != undefined) {\r\n\r\n            const legacyVibratoNames: Dictionary<string> = { \"vibrato light\": \"light\", \"vibrato delayed\": \"delayed\", \"vibrato heavy\": \"heavy\" };\r\n            const vibrato: Vibrato | undefined = Config.vibratos.dictionary[legacyVibratoNames[unisonProperty]] || Config.vibratos.dictionary[vibratoProperty];\r\n            if (vibrato != undefined)\r\n                this.vibrato = vibrato.index;\r\n            else if (vibratoProperty == \"custom\")\r\n                this.vibrato = Config.vibratos.length; // custom\r\n\r\n            if (this.vibrato == Config.vibratos.length) {\r\n                this.vibratoDepth = instrumentObject[\"vibratoDepth\"];\r\n                this.vibratoSpeed = instrumentObject[\"vibratoSpeed\"];\r\n                this.vibratoDelay = instrumentObject[\"vibratoDelay\"];\r\n                this.vibratoType = instrumentObject[\"vibratoType\"];\r\n            }\r\n            else { // Set defaults for the vibrato profile\r\n                this.vibratoDepth = Config.vibratos[this.vibrato].amplitude;\r\n                this.vibratoDelay = Config.vibratos[this.vibrato].delayTicks / 2;\r\n                this.vibratoSpeed = 10; // default;\r\n                this.vibratoType = Config.vibratos[this.vibrato].type;\r\n            }\r\n\r\n            // Old songs may have a vibrato effect without explicitly enabling it.\r\n            if (vibrato != Config.vibratos.dictionary[\"none\"]) {\r\n                this.effects = (this.effects | (1 << EffectType.vibrato));\r\n            }\r\n        }\r\n\r\n        if (instrumentObject[\"pan\"] != undefined) {\r\n            this.pan = clamp(0, Config.panMax + 1, Math.round(Config.panCenter + (instrumentObject[\"pan\"] | 0) * Config.panCenter / 100));\r\n\r\n            // Old songs may have a panning effect without explicitly enabling it.\r\n            if (this.pan != Config.panCenter) {\r\n                this.effects = (this.effects | (1 << EffectType.panning));\r\n            }\r\n        } else {\r\n            this.pan = Config.panCenter;\r\n            // Still enabling pan effect, to make it a default\r\n            this.effects = (this.effects | (1 << EffectType.panning));\r\n        }\r\n\r\n        if (instrumentObject[\"panDelay\"] != undefined) {\r\n            this.panDelay = (instrumentObject[\"panDelay\"] | 0);\r\n        } else {\r\n            this.panDelay = 10;\r\n        }\r\n\r\n        if (instrumentObject[\"detune\"] != undefined) {\r\n            this.detune = clamp(Config.detuneMin, Config.detuneMax + 1, (instrumentObject[\"detune\"] | 0));\r\n        }\r\n        else if (instrumentObject[\"detuneCents\"] == undefined) {\r\n            this.detune = Config.detuneCenter;\r\n        }\r\n\r\n        if (instrumentObject[\"distortion\"] != undefined) {\r\n            this.distortion = clamp(0, Config.distortionRange, Math.round((Config.distortionRange - 1) * (instrumentObject[\"distortion\"] | 0) / 100));\r\n        }\r\n\r\n        if (instrumentObject[\"bitcrusherOctave\"] != undefined) {\r\n            this.bitcrusherFreq = Config.bitcrusherFreqRange - 1 - (+instrumentObject[\"bitcrusherOctave\"]) / Config.bitcrusherOctaveStep;\r\n        }\r\n        if (instrumentObject[\"bitcrusherQuantization\"] != undefined) {\r\n            this.bitcrusherQuantization = clamp(0, Config.bitcrusherQuantizationRange, Math.round((Config.bitcrusherQuantizationRange - 1) * (instrumentObject[\"bitcrusherQuantization\"] | 0) / 100));\r\n        }\r\n\r\n        if (instrumentObject[\"echoSustain\"] != undefined) {\r\n            this.echoSustain = clamp(0, Config.echoSustainRange, Math.round((Config.echoSustainRange - 1) * (instrumentObject[\"echoSustain\"] | 0) / 100));\r\n        }\r\n        if (instrumentObject[\"echoDelayBeats\"] != undefined) {\r\n            this.echoDelay = clamp(0, Config.echoDelayRange, Math.round((+instrumentObject[\"echoDelayBeats\"]) * (Config.ticksPerPart * Config.partsPerBeat) / Config.echoDelayStepTicks - 1.0));\r\n        }\r\n\r\n        if (!isNaN(instrumentObject[\"chorus\"])) {\r\n            this.chorus = clamp(0, Config.chorusRange, Math.round((Config.chorusRange - 1) * (instrumentObject[\"chorus\"] | 0) / 100));\r\n        }\r\n\r\n        if (instrumentObject[\"reverb\"] != undefined) {\r\n            this.reverb = clamp(0, Config.reverbRange, Math.round((Config.reverbRange - 1) * (instrumentObject[\"reverb\"] | 0) / 100));\r\n        } else {\r\n            this.reverb = legacyGlobalReverb;\r\n        }\r\n\r\n        if (instrumentObject[\"upperNoteLimit\"] != undefined) {\r\n            this.upperNoteLimit = instrumentObject[\"upperNoteLimit\"]\r\n        }\r\n        if (instrumentObject[\"lowerNoteLimit\"] != undefined) {\r\n            this.lowerNoteLimit = instrumentObject[\"lowerNoteLimit\"]\r\n        }\r\n\r\n        if (instrumentObject[\"invertWave\"] != undefined) {\r\n            this.invertWave = instrumentObject[\"invertWave\"];\r\n        } else {\r\n            this.invertWave = false;\r\n        }\r\n\r\n        if (instrumentObject[\"pulseWidth\"] != undefined) {\r\n            this.pulseWidth = clamp(1, Config.pulseWidthRange + 1, Math.round(instrumentObject[\"pulseWidth\"]));\r\n        } else {\r\n            this.pulseWidth = Config.pulseWidthRange;\r\n        }\r\n\r\n        if (instrumentObject[\"harmonics\"] != undefined) {\r\n            for (let i: number = 0; i < Config.harmonicsControlPoints; i++) {\r\n                this.harmonicsWave.harmonics[i] = Math.max(0, Math.min(Config.harmonicsMax, Math.round(Config.harmonicsMax * (+instrumentObject[\"harmonics\"][i]) / 100)));\r\n            }\r\n            this.harmonicsWave.markCustomWaveDirty();\r\n        } else {\r\n            this.harmonicsWave.reset();\r\n        }\r\n\r\n        if (instrumentObject[\"spectrum\"] != undefined) {\r\n            for (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n                this.spectrumWave.spectrum[i] = Math.max(0, Math.min(Config.spectrumMax, Math.round(Config.spectrumMax * (+instrumentObject[\"spectrum\"][i]) / 100)));\r\n            }\r\n        } else {\r\n            this.spectrumWave.reset(isNoiseChannel);\r\n        }\r\n\r\n        if (instrumentObject[\"stringSustain\"] != undefined) {\r\n            this.stringSustain = clamp(0, Config.stringSustainRange, Math.round((Config.stringSustainRange - 1) * (instrumentObject[\"stringSustain\"] | 0) / 100));\r\n        } else {\r\n            this.stringSustain = 10;\r\n        }\r\n\r\n        if (this.type == InstrumentType.noise) {\r\n            this.chipNoise = Config.chipNoises.findIndex(wave => wave.name == instrumentObject[\"wave\"]);\r\n            if (this.chipNoise == -1) this.chipNoise = 1;\r\n        }\r\n\r\n        const legacyEnvelopeNames: Dictionary<string> = { \"custom\": \"note size\", \"steady\": \"none\", \"pluck 1\": \"twang 1\", \"pluck 2\": \"twang 2\", \"pluck 3\": \"twang 3\" };\r\n        const getEnvelope = (name: any): Envelope | undefined => (legacyEnvelopeNames[name] != undefined) ? Config.envelopes.dictionary[legacyEnvelopeNames[name]] : Config.envelopes.dictionary[name];\r\n\r\n        if (this.type == InstrumentType.drumset) {\r\n            if (instrumentObject[\"drums\"] != undefined) {\r\n                for (let j: number = 0; j < Config.drumCount; j++) {\r\n                    const drum: any = instrumentObject[\"drums\"][j];\r\n                    if (drum == undefined) continue;\r\n\r\n                    this.drumsetEnvelopes[j] = Config.envelopes.dictionary[\"twang 2\"].index; // default value.\r\n                    if (drum[\"filterEnvelope\"] != undefined) {\r\n                        const envelope: Envelope | undefined = getEnvelope(drum[\"filterEnvelope\"]);\r\n                        if (envelope != undefined) this.drumsetEnvelopes[j] = envelope.index;\r\n                    }\r\n                    if (drum[\"spectrum\"] != undefined) {\r\n                        for (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n                            this.drumsetSpectrumWaves[j].spectrum[i] = Math.max(0, Math.min(Config.spectrumMax, Math.round(Config.spectrumMax * (+drum[\"spectrum\"][i]) / 100)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.type == InstrumentType.chip) {\r\n            const legacyWaveNames: Dictionary<number> = { \"triangle\": 1, \"square\": 2, \"pulse wide\": 3, \"pulse narrow\": 4, \"sawtooth\": 5, \"double saw\": 6, \"double pulse\": 7, \"spiky\": 8, \"plateau\": 0 };\r\n            this.chipWave = legacyWaveNames[instrumentObject[\"wave\"]] != undefined ? legacyWaveNames[instrumentObject[\"wave\"]] : Config.chipWaves.findIndex(wave => wave.name == instrumentObject[\"wave\"]);\r\n            if (this.chipWave == -1) this.chipWave = 1;\r\n        }\r\n\r\n        if (this.type == InstrumentType.fm) {\r\n            this.algorithm = Config.algorithms.findIndex(algorithm => algorithm.name == instrumentObject[\"algorithm\"]);\r\n            if (this.algorithm == -1) this.algorithm = 0;\r\n            this.feedbackType = Config.feedbacks.findIndex(feedback => feedback.name == instrumentObject[\"feedbackType\"]);\r\n            if (this.feedbackType == -1) this.feedbackType = 0;\r\n            if (instrumentObject[\"feedbackAmplitude\"] != undefined) {\r\n                this.feedbackAmplitude = clamp(0, Config.operatorAmplitudeMax + 1, instrumentObject[\"feedbackAmplitude\"] | 0);\r\n            } else {\r\n                this.feedbackAmplitude = 0;\r\n            }\r\n\r\n            for (let j: number = 0; j < Config.operatorCount; j++) {\r\n                const operator: Operator = this.operators[j];\r\n                let operatorObject: any = undefined;\r\n                if (instrumentObject[\"operators\"] != undefined) operatorObject = instrumentObject[\"operators\"][j];\r\n                if (operatorObject == undefined) operatorObject = {};\r\n\r\n                operator.frequency = Config.operatorFrequencies.findIndex(freq => freq.name == operatorObject[\"frequency\"]);\r\n                if (operator.frequency == -1) operator.frequency = 0;\r\n                if (operatorObject[\"amplitude\"] != undefined) {\r\n                    operator.amplitude = clamp(0, Config.operatorAmplitudeMax + 1, operatorObject[\"amplitude\"] | 0);\r\n                } else {\r\n                    operator.amplitude = 0;\r\n                }\r\n                if (operatorObject[\"waveform\"] != undefined) {\r\n                    operator.waveform = Config.operatorWaves.findIndex(wave => wave.name == operatorObject[\"waveform\"]);\r\n                    if (operator.waveform == -1) {\r\n                        // GoldBox compatibility\r\n                        if (operatorObject[\"waveform\"] == \"square\") {\r\n                            operator.waveform = Config.operatorWaves.dictionary[\"pulse width\"].index;\r\n                            operator.pulseWidth = 5;\r\n                        } else {\r\n                            operator.waveform = 0;\r\n                        }\r\n\r\n                    }\r\n                } else {\r\n                    operator.waveform = 0;\r\n                }\r\n                if (operatorObject[\"pulseWidth\"] != undefined) {\r\n                    operator.pulseWidth = operatorObject[\"pulseWidth\"] | 0;\r\n                } else {\r\n                    operator.pulseWidth = 5;\r\n                }\r\n            }\r\n        }\r\n        else if (this.type == InstrumentType.customChipWave) {\r\n            if (instrumentObject[\"customChipWave\"]) {\r\n\r\n                for (let i: number = 0; i < 64; i++) {\r\n                    this.customChipWave[i] = instrumentObject[\"customChipWave\"][i];\r\n                }\r\n\r\n\r\n                let sum: number = 0.0;\r\n                for (let i: number = 0; i < this.customChipWave.length; i++) {\r\n                    sum += this.customChipWave[i];\r\n                }\r\n                const average: number = sum / this.customChipWave.length;\r\n\r\n                // Perform the integral on the wave. The chipSynth will perform the derivative to get the original wave back but with antialiasing.\r\n                let cumulative: number = 0;\r\n                let wavePrev: number = 0;\r\n                for (let i: number = 0; i < this.customChipWave.length; i++) {\r\n                    cumulative += wavePrev;\r\n                    wavePrev = this.customChipWave[i] - average;\r\n                    this.customChipWaveIntegral[i] = cumulative;\r\n                }\r\n\r\n                // 65th, last sample is for anti-aliasing\r\n                this.customChipWaveIntegral[64] = 0.0;\r\n            }\r\n        } else if (this.type == InstrumentType.mod) {\r\n            if (instrumentObject[\"modChannels\"] != undefined) {\r\n                for (let mod: number = 0; mod < Config.modCount; mod++) {\r\n                    this.modChannels[mod] = instrumentObject[\"modChannels\"][mod];\r\n                    this.modInstruments[mod] = instrumentObject[\"modInstruments\"][mod];\r\n                    this.modulators[mod] = instrumentObject[\"modSettings\"][mod];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.type != InstrumentType.mod) {\r\n            // Arpeggio speed\r\n            if (this.chord == Config.chords.dictionary[\"arpeggio\"].index && instrumentObject[\"arpeggioSpeed\"] != undefined) {\r\n                this.arpeggioSpeed = instrumentObject[\"arpeggioSpeed\"];\r\n            }\r\n            else {\r\n                this.arpeggioSpeed = (useSlowerRhythm) ? 9 : 12; // Decide whether to import arps as x3/4 speed\r\n            }\r\n\r\n            if (instrumentObject[\"fastTwoNoteArp\"] != undefined) {\r\n                this.fastTwoNoteArp = instrumentObject[\"fastTwoNoteArp\"];\r\n            }\r\n            else {\r\n                this.fastTwoNoteArp = useFastTwoNoteArp;\r\n            }\r\n\r\n            if (instrumentObject[\"clicklessTransition\"] != undefined) {\r\n                this.clicklessTransition = instrumentObject[\"clicklessTransition\"];\r\n            }\r\n            else {\r\n                this.clicklessTransition = false;\r\n            }\r\n\r\n            if (instrumentObject[\"aliases\"] != undefined) {\r\n                this.aliases = instrumentObject[\"aliases\"];\r\n            }\r\n            else {\r\n                this.aliases = false;\r\n            }\r\n\r\n            if (instrumentObject[\"noteFilterType\"] != undefined) {\r\n                this.noteFilterType = instrumentObject[\"noteFilterType\"];\r\n            }\r\n            if (instrumentObject[\"noteSimpleCut\"] != undefined) {\r\n                this.noteFilterSimpleCut = instrumentObject[\"noteSimpleCut\"];\r\n            }\r\n            if (instrumentObject[\"noteSimplePeak\"] != undefined) {\r\n                this.noteFilterSimplePeak = instrumentObject[\"noteSimplePeak\"];\r\n            }\r\n            if (instrumentObject[\"noteFilter\"] != undefined) {\r\n                this.noteFilter.fromJsonObject(instrumentObject[\"noteFilter\"]);\r\n            } else {\r\n                this.noteFilter.reset();\r\n            }\r\n            for (let i: number = 0; i < Config.filterMorphCount; i++) {\r\n                if (Array.isArray(instrumentObject[\"noteSubFilters\" + i])) {\r\n                    this.noteSubFilters[i] = new FilterSettings();\r\n                    this.noteSubFilters[i]!.fromJsonObject(instrumentObject[\"noteSubFilters\" + i]);\r\n                }\r\n            }\r\n            if (instrumentObject[\"eqFilterType\"] != undefined) {\r\n                this.eqFilterType = instrumentObject[\"eqFilterType\"];\r\n            }\r\n            if (instrumentObject[\"eqSimpleCut\"] != undefined) {\r\n                this.eqFilterSimpleCut = instrumentObject[\"eqSimpleCut\"];\r\n            }\r\n            if (instrumentObject[\"eqSimplePeak\"] != undefined) {\r\n                this.eqFilterSimplePeak = instrumentObject[\"eqSimplePeak\"];\r\n            }\r\n            if (Array.isArray(instrumentObject[\"eqFilter\"])) {\r\n                this.eqFilter.fromJsonObject(instrumentObject[\"eqFilter\"]);\r\n            } else {\r\n                this.eqFilter.reset();\r\n\r\n                const legacySettings: LegacySettings = {};\r\n\r\n                // Try converting from legacy filter settings.\r\n                const filterCutoffMaxHz: number = 8000;\r\n                const filterCutoffRange: number = 11;\r\n                const filterResonanceRange: number = 8;\r\n                if (instrumentObject[\"filterCutoffHz\"] != undefined) {\r\n                    legacySettings.filterCutoff = clamp(0, filterCutoffRange, Math.round((filterCutoffRange - 1) + 2.0 * Math.log((instrumentObject[\"filterCutoffHz\"] | 0) / filterCutoffMaxHz) / Math.LN2));\r\n                } else {\r\n                    legacySettings.filterCutoff = (this.type == InstrumentType.chip) ? 6 : 10;\r\n                }\r\n                if (instrumentObject[\"filterResonance\"] != undefined) {\r\n                    legacySettings.filterResonance = clamp(0, filterResonanceRange, Math.round((filterResonanceRange - 1) * (instrumentObject[\"filterResonance\"] | 0) / 100));\r\n                } else {\r\n                    legacySettings.filterResonance = 0;\r\n                }\r\n\r\n                legacySettings.filterEnvelope = getEnvelope(instrumentObject[\"filterEnvelope\"]);\r\n                legacySettings.pulseEnvelope = getEnvelope(instrumentObject[\"pulseEnvelope\"]);\r\n                legacySettings.feedbackEnvelope = getEnvelope(instrumentObject[\"feedbackEnvelope\"]);\r\n                if (Array.isArray(instrumentObject[\"operators\"])) {\r\n                    legacySettings.operatorEnvelopes = [];\r\n                    for (let j: number = 0; j < Config.operatorCount; j++) {\r\n                        let envelope: Envelope | undefined;\r\n                        if (instrumentObject[\"operators\"][j] != undefined) {\r\n                            envelope = getEnvelope(instrumentObject[\"operators\"][j][\"envelope\"]);\r\n                        }\r\n                        legacySettings.operatorEnvelopes[j] = (envelope != undefined) ? envelope : Config.envelopes.dictionary[\"none\"];\r\n                    }\r\n                }\r\n\r\n                // Try converting from even older legacy filter settings.\r\n                if (instrumentObject[\"filter\"] != undefined) {\r\n                    const legacyToCutoff: number[] = [10, 6, 3, 0, 8, 5, 2];\r\n                    const legacyToEnvelope: string[] = [\"none\", \"none\", \"none\", \"none\", \"decay 1\", \"decay 2\", \"decay 3\"];\r\n                    const filterNames: string[] = [\"none\", \"bright\", \"medium\", \"soft\", \"decay bright\", \"decay medium\", \"decay soft\"];\r\n                    const oldFilterNames: Dictionary<number> = { \"sustain sharp\": 1, \"sustain medium\": 2, \"sustain soft\": 3, \"decay sharp\": 4 };\r\n                    let legacyFilter: number = oldFilterNames[instrumentObject[\"filter\"]] != undefined ? oldFilterNames[instrumentObject[\"filter\"]] : filterNames.indexOf(instrumentObject[\"filter\"]);\r\n                    if (legacyFilter == -1) legacyFilter = 0;\r\n                    legacySettings.filterCutoff = legacyToCutoff[legacyFilter];\r\n                    legacySettings.filterEnvelope = getEnvelope(legacyToEnvelope[legacyFilter]);\r\n                    legacySettings.filterResonance = 0;\r\n                }\r\n\r\n                this.convertLegacySettings(legacySettings, true);\r\n            }\r\n\r\n            for (let i: number = 0; i < Config.filterMorphCount; i++) {\r\n                if (Array.isArray(instrumentObject[\"eqSubFilters\" + i])) {\r\n                    this.eqSubFilters[i] = new FilterSettings();\r\n                    this.eqSubFilters[i]!.fromJsonObject(instrumentObject[\"eqSubFilters\" + i]);\r\n                }\r\n            }\r\n\r\n            if (Array.isArray(instrumentObject[\"envelopes\"])) {\r\n                const envelopeArray: any[] = instrumentObject[\"envelopes\"];\r\n                for (let i = 0; i < envelopeArray.length; i++) {\r\n                    if (this.envelopeCount >= Config.maxEnvelopeCount) break;\r\n                    const tempEnvelope: EnvelopeSettings = new EnvelopeSettings();\r\n                    tempEnvelope.fromJsonObject(envelopeArray[i]);\r\n                    this.addEnvelope(tempEnvelope.target, tempEnvelope.index, tempEnvelope.envelope);\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    public static frequencyFromPitch(pitch: number): number {\r\n        return 440.0 * Math.pow(2.0, (pitch - 69.0) / 12.0);\r\n    }\r\n\r\n    public addEnvelope(target: number, index: number, envelope: number): void {\r\n        let makeEmpty: boolean = false;\r\n        if (!this.supportsEnvelopeTarget(target, index)) makeEmpty = true;\r\n        if (this.envelopeCount >= Config.maxEnvelopeCount) throw new Error();\r\n        while (this.envelopes.length <= this.envelopeCount) this.envelopes[this.envelopes.length] = new EnvelopeSettings();\r\n        const envelopeSettings: EnvelopeSettings = this.envelopes[this.envelopeCount];\r\n        envelopeSettings.target = makeEmpty ? Config.instrumentAutomationTargets.dictionary[\"none\"].index : target;\r\n        envelopeSettings.index = makeEmpty ? 0 : index;\r\n        envelopeSettings.envelope = envelope;\r\n        this.envelopeCount++;\r\n    }\r\n\r\n    public supportsEnvelopeTarget(target: number, index: number): boolean {\r\n        const automationTarget: AutomationTarget = Config.instrumentAutomationTargets[target];\r\n        if (index >= automationTarget.maxCount) {\r\n            return false;\r\n        }\r\n        if (automationTarget.compatibleInstruments != null && automationTarget.compatibleInstruments.indexOf(this.type) == -1) {\r\n            return false;\r\n        }\r\n        if (automationTarget.effect != null && (this.effects & (1 << automationTarget.effect)) == 0) {\r\n            return false;\r\n        }\r\n        if (automationTarget.isFilter) {\r\n            //if (automationTarget.perNote) {\r\n            let useControlPointCount: number = this.noteFilter.controlPointCount;\r\n            if (this.noteFilterType)\r\n                useControlPointCount = 1;\r\n            if (index >= useControlPointCount) return false;\r\n            //} else {\r\n            //\tif (index >= this.eqFilter.controlPointCount)   return false;\r\n            //}\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public clearInvalidEnvelopeTargets(): void {\r\n        for (let envelopeIndex: number = 0; envelopeIndex < this.envelopeCount; envelopeIndex++) {\r\n            const target: number = this.envelopes[envelopeIndex].target;\r\n            const index: number = this.envelopes[envelopeIndex].index;\r\n            if (!this.supportsEnvelopeTarget(target, index)) {\r\n                this.envelopes[envelopeIndex].target = Config.instrumentAutomationTargets.dictionary[\"none\"].index;\r\n                this.envelopes[envelopeIndex].index = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    public getTransition(): Transition {\r\n        return effectsIncludeTransition(this.effects) ? Config.transitions[this.transition] :\r\n            (this.type == InstrumentType.mod ? Config.transitions.dictionary[\"interrupt\"] : Config.transitions.dictionary[\"normal\"]);\r\n    }\r\n\r\n    public getFadeInSeconds(): number {\r\n        return (this.type == InstrumentType.drumset) ? 0.0 : Synth.fadeInSettingToSeconds(this.fadeIn);\r\n    }\r\n\r\n    public getFadeOutTicks(): number {\r\n        return (this.type == InstrumentType.drumset) ? Config.drumsetFadeOutTicks : Synth.fadeOutSettingToTicks(this.fadeOut)\r\n    }\r\n\r\n    public getChord(): Chord {\r\n        return effectsIncludeChord(this.effects) ? Config.chords[this.chord] : Config.chords.dictionary[\"simultaneous\"];\r\n    }\r\n\r\n    public getDrumsetEnvelope(pitch: number): Envelope {\r\n        if (this.type != InstrumentType.drumset) throw new Error(\"Can't getDrumsetEnvelope() for non-drumset.\");\r\n        return Config.envelopes[this.drumsetEnvelopes[pitch]];\r\n    }\r\n}\r\n\r\nexport class Channel {\r\n    public octave: number = 0;\r\n    public readonly instruments: Instrument[] = [];\r\n    public readonly patterns: Pattern[] = [];\r\n    public readonly bars: number[] = [];\r\n    public muted: boolean = false;\r\n    public name: string = \"\";\r\n}\r\n\r\nexport class Song {\r\n    private static readonly _format: string = \"BeepBox\";\r\n    private static readonly _oldestBeepboxVersion: number = 2;\r\n    private static readonly _latestBeepboxVersion: number = 9;\r\n    private static readonly _oldestJummBoxVersion: number = 1;\r\n    private static readonly _latestJummBoxVersion: number = 5;\r\n    // One-character variant detection at the start of URL to distinguish variants such as JummBox.\r\n    private static readonly _variant = 0x6A; //\"j\" ~ jummbox\r\n\r\n    public title: string;\r\n    public scale: number;\r\n    public key: number;\r\n    public tempo: number;\r\n    public reverb: number;\r\n    public beatsPerBar: number;\r\n    public barCount: number;\r\n    public patternsPerChannel: number;\r\n    public rhythm: number;\r\n    public layeredInstruments: boolean;\r\n    public patternInstruments: boolean;\r\n    public loopStart: number;\r\n    public loopLength: number;\r\n    public pitchChannelCount: number;\r\n    public noiseChannelCount: number;\r\n    public modChannelCount: number;\r\n    public readonly channels: Channel[] = [];\r\n    public limitDecay: number = 4.0;\r\n    public limitRise: number = 4000.0;\r\n    public compressionThreshold: number = 1.0;\r\n    public limitThreshold: number = 1.0;\r\n    public compressionRatio: number = 1.0;\r\n    public limitRatio: number = 1.0;\r\n    public masterGain: number = 1.0;\r\n    public inVolumeCap: number = 0.0;\r\n    public outVolumeCap: number = 0.0;\r\n\r\n    constructor(string?: string) {\r\n        if (string != undefined) {\r\n            this.fromBase64String(string);\r\n        } else {\r\n            this.initToDefault(true);\r\n        }\r\n    }\r\n\r\n    // Returns the ideal new note volume when dragging (max volume for a normal note, a \"neutral\" value for mod notes based on how they work)\r\n    public getNewNoteVolume = (isMod: boolean, modChannel?: number, modInstrument?: number, modCount?: number): number => {\r\n        if (!isMod || modChannel == undefined || modInstrument == undefined || modCount == undefined)\r\n            return 6;\r\n        else {\r\n            // Sigh, the way pitches count up and the visual ordering in the UI are flipped.\r\n            modCount = Config.modCount - modCount - 1;\r\n\r\n            let vol: number | undefined = Config.modulators[this.channels[modChannel].instruments[modInstrument].modulators[modCount]].newNoteVol;\r\n\r\n            // For tempo, actually use user defined tempo\r\n            let tempoIndex: number = Config.modulators.dictionary[\"tempo\"].index;\r\n            if (this.channels[modChannel].instruments[modInstrument].modulators[modCount] == tempoIndex) {\r\n                vol = this.tempo - Config.modulators[tempoIndex].convertRealFactor;\r\n            }\r\n\r\n            if (vol != undefined)\r\n                return vol;\r\n            else\r\n                return 6;\r\n        }\r\n    }\r\n\r\n\r\n    public getVolumeCap = (isMod: boolean, modChannel?: number, modInstrument?: number, modCount?: number): number => {\r\n        if (!isMod || modChannel == undefined || modInstrument == undefined || modCount == undefined)\r\n            return 6;\r\n        else {\r\n            // Sigh, the way pitches count up and the visual ordering in the UI are flipped.\r\n            modCount = Config.modCount - modCount - 1;\r\n\r\n            let instrument: Instrument = this.channels[modChannel].instruments[modInstrument];\r\n            let modulator = Config.modulators[instrument.modulators[modCount]];\r\n            let cap: number | undefined = modulator.maxRawVol;\r\n\r\n            if (cap != undefined) {\r\n                // For filters, cap is dependent on which filter setting is targeted\r\n                if (modulator.name == \"eq filter\" || modulator.name == \"note filter\") {\r\n                    // type 0: number of filter morphs\r\n                    // type 1/odd: number of filter x positions\r\n                    // type 2/even: number of filter y positions\r\n                    cap = Config.filterMorphCount - 1;\r\n                    if (instrument.modFilterTypes[modCount] > 0 && instrument.modFilterTypes[modCount] % 2) {\r\n                        cap = Config.filterFreqRange;\r\n                    } else if (instrument.modFilterTypes[modCount] > 0) {\r\n                        cap = Config.filterGainRange;\r\n                    }\r\n                }\r\n                return cap;\r\n            }\r\n            else\r\n                return 6;\r\n        }\r\n    }\r\n\r\n    public getVolumeCapForSetting = (isMod: boolean, modSetting: number, filterType?: number): number => {\r\n        if (!isMod)\r\n            return Config.noteSizeMax;\r\n        else {\r\n            let cap: number | undefined = Config.modulators[modSetting].maxRawVol;\r\n            if (cap != undefined) {\r\n\r\n                // For filters, cap is dependent on which filter setting is targeted\r\n                if (filterType != undefined && (Config.modulators[modSetting].name == \"eq filter\" || Config.modulators[modSetting].name == \"note filter\")) {\r\n                    // type 0: number of filter morphs\r\n                    // type 1/odd: number of filter x positions\r\n                    // type 2/even: number of filter y positions\r\n                    cap = Config.filterMorphCount - 1;\r\n                    if (filterType > 0 && filterType % 2) {\r\n                        cap = Config.filterFreqRange;\r\n                    } else if (filterType > 0) {\r\n                        cap = Config.filterGainRange;\r\n                    }\r\n                }\r\n\r\n                return cap;\r\n            }\r\n            else\r\n                return Config.noteSizeMax;\r\n        }\r\n    }\r\n\r\n    public getChannelCount(): number {\r\n        return this.pitchChannelCount + this.noiseChannelCount + this.modChannelCount;\r\n    }\r\n\r\n    public getMaxInstrumentsPerChannel(): number {\r\n        return Math.max(\r\n            this.layeredInstruments ? Config.layeredInstrumentCountMax : Config.instrumentCountMin,\r\n            this.patternInstruments ? Config.patternInstrumentCountMax : Config.instrumentCountMin);\r\n    }\r\n\r\n    public getMaxInstrumentsPerPattern(channelIndex: number): number {\r\n        return this.getMaxInstrumentsPerPatternForChannel(this.channels[channelIndex]);\r\n    }\r\n\r\n    public getMaxInstrumentsPerPatternForChannel(channel: Channel): number {\r\n        return this.layeredInstruments\r\n            ? Math.min(Config.layeredInstrumentCountMax, channel.instruments.length)\r\n            : 1;\r\n    }\r\n\r\n    public getChannelIsNoise(channelIndex: number): boolean {\r\n        return (channelIndex >= this.pitchChannelCount && channelIndex < this.pitchChannelCount + this.noiseChannelCount);\r\n    }\r\n\r\n    public getChannelIsMod(channelIndex: number): boolean {\r\n        return (channelIndex >= this.pitchChannelCount + this.noiseChannelCount);\r\n    }\r\n\r\n    public initToDefault(andResetChannels: boolean = true): void {\r\n        this.scale = 0;\r\n        this.key = 0;\r\n        this.loopStart = 0;\r\n        this.loopLength = 4;\r\n        this.tempo = 150;\r\n        this.reverb = 0;\r\n        this.beatsPerBar = 8;\r\n        this.barCount = 16;\r\n        this.patternsPerChannel = 8;\r\n        this.rhythm = 1;\r\n        this.layeredInstruments = false;\r\n        this.patternInstruments = false;\r\n\r\n        this.title = \"Unnamed\";\r\n        document.title = EditorConfig.versionDisplayName;\r\n\r\n        if (andResetChannels) {\r\n            this.pitchChannelCount = 3;\r\n            this.noiseChannelCount = 1;\r\n            this.modChannelCount = 0;\r\n            for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n                const isNoiseChannel: boolean = channelIndex >= this.pitchChannelCount && channelIndex < this.pitchChannelCount + this.noiseChannelCount;\r\n                const isModChannel: boolean = channelIndex >= this.pitchChannelCount + this.noiseChannelCount;\r\n                if (this.channels.length <= channelIndex) {\r\n                    this.channels[channelIndex] = new Channel();\r\n                }\r\n                const channel: Channel = this.channels[channelIndex];\r\n                channel.octave = Math.max(3 - channelIndex, 0); // [3, 2, 1, 0]; Descending octaves with drums at zero in last channel.\r\n\r\n                for (let pattern: number = 0; pattern < this.patternsPerChannel; pattern++) {\r\n                    if (channel.patterns.length <= pattern) {\r\n                        channel.patterns[pattern] = new Pattern();\r\n                    } else {\r\n                        channel.patterns[pattern].reset();\r\n                    }\r\n                }\r\n                channel.patterns.length = this.patternsPerChannel;\r\n\r\n                for (let instrument: number = 0; instrument < Config.instrumentCountMin; instrument++) {\r\n                    if (channel.instruments.length <= instrument) {\r\n                        channel.instruments[instrument] = new Instrument(isNoiseChannel, isModChannel);\r\n                    }\r\n                    channel.instruments[instrument].setTypeAndReset(isModChannel ? InstrumentType.mod : (isNoiseChannel ? InstrumentType.noise : InstrumentType.chip), isNoiseChannel, isModChannel);\r\n                }\r\n                channel.instruments.length = Config.instrumentCountMin;\r\n\r\n                for (let bar: number = 0; bar < this.barCount; bar++) {\r\n                    channel.bars[bar] = bar < 4 ? 1 : 0;\r\n                }\r\n                channel.bars.length = this.barCount;\r\n            }\r\n            this.channels.length = this.getChannelCount();\r\n        }\r\n    }\r\n\r\n    public toBase64String(): string {\r\n        let bits: BitFieldWriter;\r\n        let buffer: number[] = [];\r\n\r\n        buffer.push(Song._variant);\r\n        buffer.push(base64IntToCharCode[Song._latestJummBoxVersion]);\r\n\r\n        // Length of the song name string\r\n        buffer.push(SongTagCode.songTitle);\r\n        var encodedSongTitle: string = encodeURIComponent(this.title);\r\n        buffer.push(base64IntToCharCode[encodedSongTitle.length >> 6], base64IntToCharCode[encodedSongTitle.length & 0x3f]);\r\n\r\n        // Actual encoded string follows\r\n        for (let i: number = 0; i < encodedSongTitle.length; i++) {\r\n            buffer.push(encodedSongTitle.charCodeAt(i));\r\n        }\r\n\r\n        buffer.push(SongTagCode.channelCount, base64IntToCharCode[this.pitchChannelCount], base64IntToCharCode[this.noiseChannelCount], base64IntToCharCode[this.modChannelCount]);\r\n        buffer.push(SongTagCode.scale, base64IntToCharCode[this.scale]);\r\n        buffer.push(SongTagCode.key, base64IntToCharCode[this.key]);\r\n        buffer.push(SongTagCode.loopStart, base64IntToCharCode[this.loopStart >> 6], base64IntToCharCode[this.loopStart & 0x3f]);\r\n        buffer.push(SongTagCode.loopEnd, base64IntToCharCode[(this.loopLength - 1) >> 6], base64IntToCharCode[(this.loopLength - 1) & 0x3f]);\r\n        buffer.push(SongTagCode.tempo, base64IntToCharCode[this.tempo >> 6], base64IntToCharCode[this.tempo & 0x3F]);\r\n        buffer.push(SongTagCode.beatCount, base64IntToCharCode[this.beatsPerBar - 1]);\r\n        buffer.push(SongTagCode.barCount, base64IntToCharCode[(this.barCount - 1) >> 6], base64IntToCharCode[(this.barCount - 1) & 0x3f]);\r\n        buffer.push(SongTagCode.patternCount, base64IntToCharCode[(this.patternsPerChannel - 1) >> 6], base64IntToCharCode[(this.patternsPerChannel - 1) & 0x3f]);\r\n        buffer.push(SongTagCode.rhythm, base64IntToCharCode[this.rhythm]);\r\n\r\n        // Push limiter settings, but only if they aren't the default!\r\n        buffer.push(SongTagCode.limiterSettings);\r\n        if (this.compressionRatio != 1.0 || this.limitRatio != 1.0 || this.limitRise != 4000.0 || this.limitDecay != 4.0 || this.limitThreshold != 1.0 || this.compressionThreshold != 1.0 || this.masterGain != 1.0) {\r\n            buffer.push(base64IntToCharCode[Math.round(this.compressionRatio < 1 ? this.compressionRatio * 10 : 10 + (this.compressionRatio - 1) * 60)]); // 0 ~ 1.15 uneven, mapped to 0 ~ 20\r\n            buffer.push(base64IntToCharCode[Math.round(this.limitRatio < 1 ? this.limitRatio * 10 : 9 + this.limitRatio)]); // 0 ~ 10 uneven, mapped to 0 ~ 20\r\n            buffer.push(base64IntToCharCode[this.limitDecay]); // directly 1 ~ 30\r\n            buffer.push(base64IntToCharCode[Math.round((this.limitRise - 2000.0) / 250.0)]); // 2000 ~ 10000 by 250, mapped to 0 ~ 32\r\n            buffer.push(base64IntToCharCode[Math.round(this.compressionThreshold * 20)]); // 0 ~ 1.1 by 0.05, mapped to 0 ~ 22\r\n            buffer.push(base64IntToCharCode[Math.round(this.limitThreshold * 20)]); // 0 ~ 2 by 0.05, mapped to 0 ~ 40\r\n            buffer.push(base64IntToCharCode[Math.round(this.masterGain * 50) >> 6], base64IntToCharCode[Math.round(this.masterGain * 50) & 0x3f]); // 0 ~ 5 by 0.02, mapped to 0 ~ 250\r\n        }\r\n        else {\r\n            buffer.push(base64IntToCharCode[0x3f]); // Not using limiter\r\n        }\r\n\r\n        buffer.push(SongTagCode.channelNames);\r\n        for (let channel: number = 0; channel < this.getChannelCount(); channel++) {\r\n            // Length of the channel name string\r\n            var encodedChannelName: string = encodeURIComponent(this.channels[channel].name);\r\n            buffer.push(base64IntToCharCode[encodedChannelName.length >> 6], base64IntToCharCode[encodedChannelName.length & 0x3f]);\r\n\r\n            // Actual encoded string follows\r\n            for (let i: number = 0; i < encodedChannelName.length; i++) {\r\n                buffer.push(encodedChannelName.charCodeAt(i));\r\n            }\r\n        }\r\n\r\n        buffer.push(SongTagCode.instrumentCount, base64IntToCharCode[(<any>this.layeredInstruments << 1) | <any>this.patternInstruments]);\r\n        if (this.layeredInstruments || this.patternInstruments) {\r\n            for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n                buffer.push(base64IntToCharCode[this.channels[channelIndex].instruments.length - Config.instrumentCountMin]);\r\n            }\r\n        }\r\n\r\n        buffer.push(SongTagCode.channelOctave);\r\n        for (let channelIndex: number = 0; channelIndex < this.pitchChannelCount; channelIndex++) {\r\n            buffer.push(base64IntToCharCode[this.channels[channelIndex].octave]);\r\n        }\r\n\r\n        for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n            for (let i: number = 0; i < this.channels[channelIndex].instruments.length; i++) {\r\n                const instrument: Instrument = this.channels[channelIndex].instruments[i];\r\n                buffer.push(SongTagCode.startInstrument, base64IntToCharCode[instrument.type]);\r\n                buffer.push(SongTagCode.volume, base64IntToCharCode[(instrument.volume + Config.volumeRange / 2) >> 6], base64IntToCharCode[(instrument.volume + Config.volumeRange / 2) & 0x3f]);\r\n                buffer.push(SongTagCode.preset, base64IntToCharCode[instrument.preset >> 6], base64IntToCharCode[instrument.preset & 63]);\r\n\r\n                buffer.push(SongTagCode.eqFilter);\r\n                buffer.push(base64IntToCharCode[+instrument.eqFilterType]);\r\n                if (instrument.eqFilterType) {\r\n                    buffer.push(base64IntToCharCode[instrument.eqFilterSimpleCut]);\r\n                    buffer.push(base64IntToCharCode[instrument.eqFilterSimplePeak]);\r\n                }\r\n                else {\r\n                    if (instrument.eqFilter == null) {\r\n                        // Push null filter settings\r\n                        buffer.push(base64IntToCharCode[0]);\r\n                        console.log(\"Null EQ filter settings detected in toBase64String for channelIndex \" + channelIndex + \", instrumentIndex \" + i);\r\n                    } else {\r\n                        buffer.push(base64IntToCharCode[instrument.eqFilter.controlPointCount]);\r\n                        for (let j: number = 0; j < instrument.eqFilter.controlPointCount; j++) {\r\n                            const point: FilterControlPoint = instrument.eqFilter.controlPoints[j];\r\n                            buffer.push(base64IntToCharCode[point.type], base64IntToCharCode[Math.round(point.freq)], base64IntToCharCode[Math.round(point.gain)]);\r\n                        }\r\n                    }\r\n\r\n                    // Push subfilters as well. Skip Index 0, is a copy of the base filter.\r\n                    let usingSubFilterBitfield: number = 0;\r\n                    for (let j: number = 0; j < Config.filterMorphCount - 1; j++) {\r\n                        usingSubFilterBitfield |= (+(instrument.eqSubFilters[j + 1] != null) << j);\r\n                    }\r\n                    // Put subfilter usage into 2 chars (12 bits)\r\n                    buffer.push(base64IntToCharCode[usingSubFilterBitfield >> 6], base64IntToCharCode[usingSubFilterBitfield & 63]);\r\n                    // Put subfilter info in for all used subfilters\r\n                    for (let j: number = 0; j < Config.filterMorphCount - 1; j++) {\r\n                        if (usingSubFilterBitfield & (1 << j)) {\r\n                            buffer.push(base64IntToCharCode[instrument.eqSubFilters[j + 1]!.controlPointCount]);\r\n                            for (let k: number = 0; k < instrument.eqSubFilters[j + 1]!.controlPointCount; k++) {\r\n                                const point: FilterControlPoint = instrument.eqSubFilters[j + 1]!.controlPoints[k];\r\n                                buffer.push(base64IntToCharCode[point.type], base64IntToCharCode[Math.round(point.freq)], base64IntToCharCode[Math.round(point.gain)]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // The list of enabled effects is represented as a 12-bit bitfield using two six-bit characters.\r\n                buffer.push(\r\n                    SongTagCode.effects,\r\n                    base64IntToCharCode[(instrument.effects >>> (6 * 5)) & 63],\r\n                    base64IntToCharCode[(instrument.effects >>> (6 * 4)) & 63],\r\n                    base64IntToCharCode[(instrument.effects >>> (6 * 3)) & 63],\r\n                    base64IntToCharCode[(instrument.effects >>> (6 * 2)) & 63],\r\n                    base64IntToCharCode[(instrument.effects >>> (6 * 1)) & 63],\r\n                    base64IntToCharCode[(instrument.effects >>> (6 * 0)) & 63]\r\n                );\r\n                if (effectsIncludeNoteFilter(instrument.effects)) {\r\n                    buffer.push(base64IntToCharCode[+instrument.noteFilterType]);\r\n                    if (instrument.noteFilterType) {\r\n                        buffer.push(base64IntToCharCode[instrument.noteFilterSimpleCut]);\r\n                        buffer.push(base64IntToCharCode[instrument.noteFilterSimplePeak]);\r\n                    }\r\n                    else {\r\n                        if (instrument.noteFilter == null) {\r\n                            // Push null filter settings\r\n                            buffer.push(base64IntToCharCode[0]);\r\n                            console.log(\"Null note filter settings detected in toBase64String for channelIndex \" + channelIndex + \", instrumentIndex \" + i);\r\n                        }\r\n                        else {\r\n                            buffer.push(base64IntToCharCode[instrument.noteFilter.controlPointCount]);\r\n                            for (let j: number = 0; j < instrument.noteFilter.controlPointCount; j++) {\r\n                                const point: FilterControlPoint = instrument.noteFilter.controlPoints[j];\r\n                                buffer.push(base64IntToCharCode[point.type], base64IntToCharCode[Math.round(point.freq)], base64IntToCharCode[Math.round(point.gain)]);\r\n                            }\r\n                        }\r\n\r\n                        // Push subfilters as well. Skip Index 0, is a copy of the base filter.\r\n                        let usingSubFilterBitfield: number = 0;\r\n                        for (let j: number = 0; j < Config.filterMorphCount - 1; j++) {\r\n                            usingSubFilterBitfield |= (+(instrument.noteSubFilters[j + 1] != null) << j);\r\n                        }\r\n                        // Put subfilter usage into 2 chars (12 bits)\r\n                        buffer.push(base64IntToCharCode[usingSubFilterBitfield >> 6], base64IntToCharCode[usingSubFilterBitfield & 63]);\r\n                        // Put subfilter info in for all used subfilters\r\n                        for (let j: number = 0; j < Config.filterMorphCount - 1; j++) {\r\n                            if (usingSubFilterBitfield & (1 << j)) {\r\n                                buffer.push(base64IntToCharCode[instrument.noteSubFilters[j + 1]!.controlPointCount]);\r\n                                for (let k: number = 0; k < instrument.noteSubFilters[j + 1]!.controlPointCount; k++) {\r\n                                    const point: FilterControlPoint = instrument.noteSubFilters[j + 1]!.controlPoints[k];\r\n                                    buffer.push(base64IntToCharCode[point.type], base64IntToCharCode[Math.round(point.freq)], base64IntToCharCode[Math.round(point.gain)]);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (effectsIncludeTransition(instrument.effects)) {\r\n                    buffer.push(base64IntToCharCode[instrument.transition]);\r\n                }\r\n                if (effectsIncludeChord(instrument.effects)) {\r\n                    buffer.push(base64IntToCharCode[instrument.chord]);\r\n                    // Custom arpeggio speed... only if the instrument arpeggiates.\r\n                    if (instrument.chord == Config.chords.dictionary[\"arpeggio\"].index) {\r\n                        buffer.push(base64IntToCharCode[instrument.arpeggioSpeed]);\r\n                        buffer.push(base64IntToCharCode[+instrument.fastTwoNoteArp]); // Two note arp setting piggybacks on this\r\n                    }\r\n                }\r\n                if (effectsIncludePitchShift(instrument.effects)) {\r\n                    buffer.push(base64IntToCharCode[instrument.pitchShift]);\r\n                }\r\n                if (effectsIncludeDetune(instrument.effects)) {\r\n                    buffer.push(base64IntToCharCode[(instrument.detune - Config.detuneMin) >> 6], base64IntToCharCode[(instrument.detune - Config.detuneMin) & 0x3F]);\r\n                }\r\n                if (effectsIncludeVibrato(instrument.effects)) {\r\n                    buffer.push(base64IntToCharCode[instrument.vibrato]);\r\n                    // Custom vibrato settings\r\n                    if (instrument.vibrato == Config.vibratos.length) {\r\n                        buffer.push(base64IntToCharCode[Math.round(instrument.vibratoDepth * 25)]);\r\n                        buffer.push(base64IntToCharCode[instrument.vibratoSpeed]);\r\n                        buffer.push(base64IntToCharCode[Math.round(instrument.vibratoDelay)]);\r\n                        buffer.push(base64IntToCharCode[instrument.vibratoType]);\r\n                    }\r\n                }\r\n                if (effectsIncludeDistortion(instrument.effects)) {\r\n                    buffer.push(base64IntToCharCode[instrument.distortion]);\r\n                    // Aliasing is tied into distortion for now\r\n                    buffer.push(base64IntToCharCode[+instrument.aliases]);\r\n                }\r\n                if (effectsIncludeBitcrusher(instrument.effects)) {\r\n                    buffer.push(base64IntToCharCode[instrument.bitcrusherFreq], base64IntToCharCode[instrument.bitcrusherQuantization]);\r\n                }\r\n                if (effectsIncludePanning(instrument.effects)) {\r\n                    buffer.push(base64IntToCharCode[instrument.pan >> 6], base64IntToCharCode[instrument.pan & 0x3f]);\r\n                    buffer.push(base64IntToCharCode[instrument.panDelay]);\r\n                }\r\n                if (effectsIncludeChorus(instrument.effects)) {\r\n                    buffer.push(base64IntToCharCode[instrument.chorus]);\r\n                }\r\n                if (effectsIncludeEcho(instrument.effects)) {\r\n                    buffer.push(base64IntToCharCode[instrument.echoSustain], base64IntToCharCode[instrument.echoDelay]);\r\n                }\r\n                if (effectsIncludeReverb(instrument.effects)) {\r\n                    buffer.push(base64IntToCharCode[instrument.reverb]);\r\n                }\r\n\r\n                if (effectsIncludeNoteRange(instrument.effects)) {\r\n                    buffer.push(base64IntToCharCode[instrument.upperNoteLimit >> 6], base64IntToCharCode[instrument.upperNoteLimit & 0x3f]);\r\n                    buffer.push(base64IntToCharCode[instrument.lowerNoteLimit >> 6], base64IntToCharCode[instrument.lowerNoteLimit & 0x3f]);\r\n                }\r\n\r\n                if (effectsIncludeInvertWave(instrument.effects)) {\r\n                    buffer.push(base64IntToCharCode[+instrument.invertWave]);\r\n                }\r\n\r\n                if (instrument.type != InstrumentType.drumset) {\r\n                    buffer.push(SongTagCode.fadeInOut, base64IntToCharCode[instrument.fadeIn], base64IntToCharCode[instrument.fadeOut]);\r\n                    // Transition info follows transition song tag\r\n                    buffer.push(base64IntToCharCode[+instrument.clicklessTransition]);\r\n                }\r\n\r\n                if (instrument.type == InstrumentType.harmonics || instrument.type == InstrumentType.pickedString) {\r\n                    buffer.push(SongTagCode.harmonics);\r\n                    const harmonicsBits: BitFieldWriter = new BitFieldWriter();\r\n                    for (let i: number = 0; i < Config.harmonicsControlPoints; i++) {\r\n                        harmonicsBits.write(Config.harmonicsControlPointBits, instrument.harmonicsWave.harmonics[i]);\r\n                    }\r\n                    harmonicsBits.encodeBase64(buffer);\r\n                }\r\n\r\n                if (instrument.type == InstrumentType.chip) {\r\n                    buffer.push(SongTagCode.wave, base64IntToCharCode[instrument.chipWave]);\r\n                    buffer.push(SongTagCode.unison, base64IntToCharCode[instrument.unison]);\r\n                } else if (instrument.type == InstrumentType.fm) {\r\n                    buffer.push(SongTagCode.algorithm, base64IntToCharCode[instrument.algorithm]);\r\n                    buffer.push(SongTagCode.feedbackType, base64IntToCharCode[instrument.feedbackType]);\r\n                    buffer.push(SongTagCode.feedbackAmplitude, base64IntToCharCode[instrument.feedbackAmplitude]);\r\n\r\n                    buffer.push(SongTagCode.operatorFrequencies);\r\n                    for (let o: number = 0; o < Config.operatorCount; o++) {\r\n                        buffer.push(base64IntToCharCode[instrument.operators[o].frequency]);\r\n                    }\r\n                    buffer.push(SongTagCode.operatorAmplitudes);\r\n                    for (let o: number = 0; o < Config.operatorCount; o++) {\r\n                        buffer.push(base64IntToCharCode[instrument.operators[o].amplitude]);\r\n                    }\r\n\r\n                    buffer.push(SongTagCode.operatorWaves);\r\n                    for (let o: number = 0; o < Config.operatorCount; o++) {\r\n                        buffer.push(base64IntToCharCode[instrument.operators[o].waveform]);\r\n                        // Push pulse width if that type is used\r\n                        if (instrument.operators[o].waveform == 3) {\r\n                            buffer.push(base64IntToCharCode[instrument.operators[o].pulseWidth]);\r\n                        }\r\n                    }\r\n                } else if (instrument.type == InstrumentType.customChipWave) {\r\n                    buffer.push(SongTagCode.wave, base64IntToCharCode[instrument.chipWave]);\r\n                    buffer.push(SongTagCode.unison, base64IntToCharCode[instrument.unison]);\r\n                    buffer.push(SongTagCode.customChipWave);\r\n                    // Push custom wave values\r\n                    for (let j: number = 0; j < 64; j++) {\r\n                        buffer.push(base64IntToCharCode[(instrument.customChipWave[j] + 24) as number]);\r\n                    }\r\n                } else if (instrument.type == InstrumentType.noise) {\r\n                    buffer.push(SongTagCode.wave, base64IntToCharCode[instrument.chipNoise]);\r\n                } else if (instrument.type == InstrumentType.spectrum) {\r\n                    buffer.push(SongTagCode.spectrum);\r\n                    const spectrumBits: BitFieldWriter = new BitFieldWriter();\r\n                    for (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n                        spectrumBits.write(Config.spectrumControlPointBits, instrument.spectrumWave.spectrum[i]);\r\n                    }\r\n                    spectrumBits.encodeBase64(buffer);\r\n                } else if (instrument.type == InstrumentType.drumset) {\r\n                    buffer.push(SongTagCode.drumsetEnvelopes);\r\n                    for (let j: number = 0; j < Config.drumCount; j++) {\r\n                        buffer.push(base64IntToCharCode[instrument.drumsetEnvelopes[j]]);\r\n                    }\r\n\r\n                    buffer.push(SongTagCode.spectrum);\r\n                    const spectrumBits: BitFieldWriter = new BitFieldWriter();\r\n                    for (let j: number = 0; j < Config.drumCount; j++) {\r\n                        for (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n                            spectrumBits.write(Config.spectrumControlPointBits, instrument.drumsetSpectrumWaves[j].spectrum[i]);\r\n                        }\r\n                    }\r\n                    spectrumBits.encodeBase64(buffer);\r\n                } else if (instrument.type == InstrumentType.harmonics) {\r\n                    buffer.push(SongTagCode.unison, base64IntToCharCode[instrument.unison]);\r\n                } else if (instrument.type == InstrumentType.pwm) {\r\n                    buffer.push(SongTagCode.pulseWidth, base64IntToCharCode[instrument.pulseWidth]);\r\n                } else if (instrument.type == InstrumentType.pickedString) {\r\n                    buffer.push(SongTagCode.unison, base64IntToCharCode[instrument.unison]);\r\n                    buffer.push(SongTagCode.stringSustain, base64IntToCharCode[instrument.stringSustain]);\r\n                } else if (instrument.type == InstrumentType.mod) {\r\n                    // Handled down below. Could be moved, but meh.\r\n                } else {\r\n                    throw new Error(\"Unknown instrument type.\");\r\n                }\r\n\r\n                buffer.push(SongTagCode.envelopes, base64IntToCharCode[instrument.envelopeCount]);\r\n                for (let envelopeIndex: number = 0; envelopeIndex < instrument.envelopeCount; envelopeIndex++) {\r\n                    buffer.push(base64IntToCharCode[instrument.envelopes[envelopeIndex].target]);\r\n                    if (Config.instrumentAutomationTargets[instrument.envelopes[envelopeIndex].target].maxCount > 1) {\r\n                        buffer.push(base64IntToCharCode[instrument.envelopes[envelopeIndex].index]);\r\n                    }\r\n                    buffer.push(base64IntToCharCode[instrument.envelopes[envelopeIndex].envelope]);\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n\r\n        buffer.push(SongTagCode.bars);\r\n        bits = new BitFieldWriter();\r\n        let neededBits: number = 0;\r\n        while ((1 << neededBits) < this.patternsPerChannel + 1) neededBits++;\r\n        for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) for (let i: number = 0; i < this.barCount; i++) {\r\n            bits.write(neededBits, this.channels[channelIndex].bars[i]);\r\n        }\r\n        bits.encodeBase64(buffer);\r\n\r\n        buffer.push(SongTagCode.patterns);\r\n        bits = new BitFieldWriter();\r\n        const shapeBits: BitFieldWriter = new BitFieldWriter();\r\n        const bitsPerNoteSize: number = Song.getNeededBits(Config.noteSizeMax);\r\n        for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n            const channel: Channel = this.channels[channelIndex];\r\n            const maxInstrumentsPerPattern: number = this.getMaxInstrumentsPerPattern(channelIndex);\r\n            const isNoiseChannel: boolean = this.getChannelIsNoise(channelIndex);\r\n            const isModChannel: boolean = this.getChannelIsMod(channelIndex);\r\n            const neededInstrumentCountBits: number = Song.getNeededBits(maxInstrumentsPerPattern - Config.instrumentCountMin);\r\n            const neededInstrumentIndexBits: number = Song.getNeededBits(channel.instruments.length - 1);\r\n\r\n            // Some info about modulator settings immediately follows in mod channels.\r\n            if (isModChannel) {\r\n                const neededModInstrumentIndexBits: number = Song.getNeededBits(this.getMaxInstrumentsPerChannel() + 2);\r\n                for (let instrumentIndex: number = 0; instrumentIndex < channel.instruments.length; instrumentIndex++) {\r\n\r\n                    let instrument: Instrument = this.channels[channelIndex].instruments[instrumentIndex];\r\n\r\n                    for (let mod: number = 0; mod < Config.modCount; mod++) {\r\n                        const modChannel: number = instrument.modChannels[mod];\r\n                        const modInstrument: number = instrument.modInstruments[mod];\r\n                        const modSetting: number = instrument.modulators[mod];\r\n                        const modFilter: number = instrument.modFilterTypes[mod];\r\n\r\n                        // Still using legacy \"mod status\" format, but doing it manually as it's only used in the URL now.\r\n                        // 0 - For pitch/noise\r\n                        // 1 - (used to be For noise, not needed)\r\n                        // 2 - For song\r\n                        // 3 - None\r\n\r\n                        let status: number = Config.modulators[modSetting].forSong ? 2 : 0;\r\n                        if (modSetting == Config.modulators.dictionary[\"none\"].index)\r\n                            status = 3;\r\n\r\n                        bits.write(2, status);\r\n\r\n                        // Channel/Instrument is only used if the status isn't \"song\" or \"none\".\r\n                        if (status == 0 || status == 1) {\r\n                            bits.write(8, modChannel);\r\n                            bits.write(neededModInstrumentIndexBits, modInstrument);\r\n                        }\r\n\r\n                        // Only used if setting isn't \"none\".\r\n                        if (status != 3) {\r\n                            bits.write(6, modSetting);\r\n                        }\r\n\r\n                        // Write mod filter info, only if this is a filter mod\r\n                        if (Config.modulators[instrument.modulators[mod]].name == \"eq filter\" || Config.modulators[instrument.modulators[mod]].name == \"note filter\") {\r\n                            bits.write(6, modFilter);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            const octaveOffset: number = (isNoiseChannel || isModChannel) ? 0 : channel.octave * Config.pitchesPerOctave;\r\n            let lastPitch: number = (isNoiseChannel ? 4 : octaveOffset);\r\n            const recentPitches: number[] = isModChannel ? [0, 1, 2, 3, 4, 5] : (isNoiseChannel ? [4, 6, 7, 2, 3, 8, 0, 10] : [0, 7, 12, 19, 24, -5, -12]);\r\n            const recentShapes: string[] = [];\r\n            for (let i: number = 0; i < recentPitches.length; i++) {\r\n                recentPitches[i] += octaveOffset;\r\n            }\r\n            for (const pattern of channel.patterns) {\r\n                if (this.patternInstruments) {\r\n                    const instrumentCount: number = validateRange(Config.instrumentCountMin, maxInstrumentsPerPattern, pattern.instruments.length);\r\n                    bits.write(neededInstrumentCountBits, instrumentCount - Config.instrumentCountMin);\r\n                    for (let i: number = 0; i < instrumentCount; i++) {\r\n                        bits.write(neededInstrumentIndexBits, pattern.instruments[i]);\r\n                    }\r\n                }\r\n\r\n                if (pattern.notes.length > 0) {\r\n                    bits.write(1, 1);\r\n\r\n                    let curPart: number = 0;\r\n                    for (const note of pattern.notes) {\r\n\r\n                        // For mod channels, a negative offset may be necessary.\r\n                        if (note.start < curPart && isModChannel) {\r\n                            bits.write(2, 0); // rest, then...\r\n                            bits.write(1, 1); // negative offset\r\n                            bits.writePartDuration(curPart - note.start);\r\n                        }\r\n\r\n                        if (note.start > curPart) {\r\n                            bits.write(2, 0); // rest\r\n                            if (isModChannel) bits.write(1, 0); // positive offset, only needed for mod channels\r\n                            bits.writePartDuration(note.start - curPart);\r\n                        }\r\n\r\n                        shapeBits.clear();\r\n\r\n                        // Old format was:\r\n                        // 0: 1 pitch, 10: 2 pitches, 110: 3 pitches, 111: 4 pitches\r\n                        // New format is:\r\n                        //      0: 1 pitch\r\n                        // 1[XXX]: 3 bits of binary signifying 2+ pitches\r\n                        if (note.pitches.length == 1) {\r\n                            shapeBits.write(1, 0);\r\n                        } else {\r\n                            shapeBits.write(1, 1);\r\n                            shapeBits.write(3, note.pitches.length - 2);\r\n                        }\r\n\r\n                        shapeBits.writePinCount(note.pins.length - 1);\r\n\r\n                        if (!isModChannel) {\r\n                            shapeBits.write(bitsPerNoteSize, note.pins[0].size); // volume\r\n                        }\r\n                        else {\r\n                            shapeBits.write(9, note.pins[0].size); // Modulator value. 9 bits for now = 512 max mod value?\r\n                        }\r\n\r\n                        let shapePart: number = 0;\r\n                        let startPitch: number = note.pitches[0];\r\n                        let currentPitch: number = startPitch;\r\n                        const pitchBends: number[] = [];\r\n                        for (let i: number = 1; i < note.pins.length; i++) {\r\n                            const pin: NotePin = note.pins[i];\r\n                            const nextPitch: number = startPitch + pin.interval;\r\n                            if (currentPitch != nextPitch) {\r\n                                shapeBits.write(1, 1);\r\n                                pitchBends.push(nextPitch);\r\n                                currentPitch = nextPitch;\r\n                            } else {\r\n                                shapeBits.write(1, 0);\r\n                            }\r\n                            shapeBits.writePartDuration(pin.time - shapePart);\r\n                            shapePart = pin.time;\r\n                            if (!isModChannel) {\r\n                                shapeBits.write(bitsPerNoteSize, pin.size);\r\n                            } else {\r\n                                shapeBits.write(9, pin.size);\r\n                            }\r\n                        }\r\n\r\n                        const shapeString: string = String.fromCharCode.apply(null, shapeBits.encodeBase64([]));\r\n                        const shapeIndex: number = recentShapes.indexOf(shapeString);\r\n                        if (shapeIndex == -1) {\r\n                            bits.write(2, 1); // new shape\r\n                            bits.concat(shapeBits);\r\n                        } else {\r\n                            bits.write(1, 1); // old shape\r\n                            bits.writeLongTail(0, 0, shapeIndex);\r\n                            recentShapes.splice(shapeIndex, 1);\r\n                        }\r\n                        recentShapes.unshift(shapeString);\r\n                        if (recentShapes.length > 10) recentShapes.pop();\r\n\r\n                        const allPitches: number[] = note.pitches.concat(pitchBends);\r\n                        for (let i: number = 0; i < allPitches.length; i++) {\r\n                            const pitch: number = allPitches[i];\r\n                            const pitchIndex: number = recentPitches.indexOf(pitch);\r\n                            if (pitchIndex == -1) {\r\n                                let interval: number = 0;\r\n                                let pitchIter: number = lastPitch;\r\n                                if (pitchIter < pitch) {\r\n                                    while (pitchIter != pitch) {\r\n                                        pitchIter++;\r\n                                        if (recentPitches.indexOf(pitchIter) == -1) interval++;\r\n                                    }\r\n                                } else {\r\n                                    while (pitchIter != pitch) {\r\n                                        pitchIter--;\r\n                                        if (recentPitches.indexOf(pitchIter) == -1) interval--;\r\n                                    }\r\n                                }\r\n                                bits.write(1, 0);\r\n                                bits.writePitchInterval(interval);\r\n                            } else {\r\n                                bits.write(1, 1);\r\n                                bits.write(4, pitchIndex);\r\n                                recentPitches.splice(pitchIndex, 1);\r\n                            }\r\n                            recentPitches.unshift(pitch);\r\n                            if (recentPitches.length > 16) recentPitches.pop();\r\n\r\n                            if (i == note.pitches.length - 1) {\r\n                                lastPitch = note.pitches[0];\r\n                            } else {\r\n                                lastPitch = pitch;\r\n                            }\r\n                        }\r\n\r\n                        if (note.start == 0) {\r\n                            bits.write(1, note.continuesLastPattern ? 1 : 0);\r\n                        }\r\n\r\n                        curPart = note.end;\r\n                    }\r\n\r\n                    if (curPart < this.beatsPerBar * Config.partsPerBeat + (+isModChannel)) {\r\n                        bits.write(2, 0); // rest\r\n                        if (isModChannel) bits.write(1, 0); // positive offset\r\n                        bits.writePartDuration(this.beatsPerBar * Config.partsPerBeat + (+isModChannel) - curPart);\r\n                    }\r\n                } else {\r\n                    bits.write(1, 0);\r\n                }\r\n            }\r\n        }\r\n        let stringLength: number = bits.lengthBase64();\r\n        let digits: number[] = [];\r\n        while (stringLength > 0) {\r\n            digits.unshift(base64IntToCharCode[stringLength & 0x3f]);\r\n            stringLength = stringLength >> 6;\r\n        }\r\n        buffer.push(base64IntToCharCode[digits.length]);\r\n        Array.prototype.push.apply(buffer, digits); // append digits to buffer.\r\n        bits.encodeBase64(buffer);\r\n\r\n        const maxApplyArgs: number = 64000;\r\n        if (buffer.length < maxApplyArgs) {\r\n            // Note: Function.apply may break for long argument lists.\r\n            return String.fromCharCode.apply(null, buffer);\r\n        } else {\r\n            let result: string = \"\";\r\n            for (let i: number = 0; i < buffer.length; i += maxApplyArgs) {\r\n                result += String.fromCharCode.apply(null, buffer.slice(i, i + maxApplyArgs));\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n\r\n    private static _envelopeFromLegacyIndex(legacyIndex: number): Envelope {\r\n        // I swapped the order of \"custom\"/\"steady\", now \"none\"/\"note size\".\r\n        if (legacyIndex == 0) legacyIndex = 1; else if (legacyIndex == 1) legacyIndex = 0;\r\n        return Config.envelopes[clamp(0, Config.envelopes.length, legacyIndex)];\r\n    }\r\n\r\n    public fromBase64String(compressed: string): void {\r\n        if (compressed == null || compressed == \"\") {\r\n            this.initToDefault(true);\r\n            return;\r\n        }\r\n        let charIndex: number = 0;\r\n        // skip whitespace.\r\n        while (compressed.charCodeAt(charIndex) <= CharCode.SPACE) charIndex++;\r\n        // skip hash mark.\r\n        if (compressed.charCodeAt(charIndex) == CharCode.HASH) charIndex++;\r\n        // if it starts with curly brace, treat it as JSON.\r\n        if (compressed.charCodeAt(charIndex) == CharCode.LEFT_CURLY_BRACE) {\r\n            this.fromJsonObject(JSON.parse(charIndex == 0 ? compressed : compressed.substring(charIndex)));\r\n            return;\r\n        }\r\n\r\n        const variantTest: number = compressed.charCodeAt(charIndex);\r\n        let fromBeepBox: boolean;\r\n        let fromJummBox: boolean;\r\n\r\n        // Detect variant here. If version doesn't match known variant, assume it is a vanilla string which does not report variant.\r\n        if (variantTest == 0x6A) { //\"j\"\r\n            fromBeepBox = false;\r\n            fromJummBox = true;\r\n            charIndex++;\r\n        } else {\r\n            fromBeepBox = true;\r\n            fromJummBox = false;\r\n        }\r\n\r\n        const version: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n        if (fromBeepBox && (version == -1 || version > Song._latestBeepboxVersion || version < Song._oldestBeepboxVersion)) return;\r\n        if (fromJummBox && (version == -1 || version > Song._latestJummBoxVersion || version < Song._oldestJummBoxVersion)) return;\r\n        const beforeTwo: boolean = version < 2;\r\n        const beforeThree: boolean = version < 3;\r\n        const beforeFour: boolean = version < 4;\r\n        const beforeFive: boolean = version < 5;\r\n        const beforeSix: boolean = version < 6;\r\n        const beforeSeven: boolean = version < 7;\r\n        const beforeEight: boolean = version < 8;\r\n        const beforeNine: boolean = version < 9;\r\n        this.initToDefault((fromBeepBox && beforeNine) || (fromJummBox && beforeFive));\r\n        const forceSimpleFilter: boolean = (fromBeepBox && beforeNine || fromJummBox && beforeFive);\r\n\r\n        if (beforeThree && fromBeepBox) {\r\n            // Originally, the only instrument transition was \"instant\" and the only drum wave was \"retro\".\r\n            for (const channel of this.channels) {\r\n                channel.instruments[0].transition = Config.transitions.dictionary[\"interrupt\"].index;\r\n                channel.instruments[0].effects |= 1 << EffectType.transition;\r\n            }\r\n            this.channels[3].instruments[0].chipNoise = 0;\r\n        }\r\n\r\n        let legacySettingsCache: LegacySettings[][] | null = null;\r\n        if ((fromBeepBox && beforeNine) || (fromJummBox && beforeFive)) {\r\n            // Unfortunately, old versions of BeepBox had a variety of different ways of saving\r\n            // filter-and-envelope-related parameters in the URL, and none of them directly\r\n            // correspond to the new way of saving these parameters. We can approximate the old\r\n            // settings by collecting all the old settings for an instrument and passing them to\r\n            // convertLegacySettings(), so I use this data structure to collect the settings\r\n            // for each instrument if necessary.\r\n            legacySettingsCache = [];\r\n            for (let i: number = legacySettingsCache.length; i < this.getChannelCount(); i++) {\r\n                legacySettingsCache[i] = [];\r\n                for (let j: number = 0; j < Config.instrumentCountMin; j++) legacySettingsCache[i][j] = {};\r\n            }\r\n        }\r\n\r\n        let legacyGlobalReverb: number = 0; // beforeNine reverb was song-global, record that reverb here and adapt it to instruments as needed.\r\n\r\n        let instrumentChannelIterator: number = 0;\r\n        let instrumentIndexIterator: number = -1;\r\n        let command: number;\r\n        let useSlowerArpSpeed: boolean = false;\r\n        let useFastTwoNoteArp: boolean = false;\r\n        while (charIndex < compressed.length) switch (command = compressed.charCodeAt(charIndex++)) {\r\n            case SongTagCode.songTitle: {\r\n                // Length of song name string\r\n                var songNameLength = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                this.title = decodeURIComponent(compressed.substring(charIndex, charIndex + songNameLength));\r\n                document.title = this.title + \" - \" + EditorConfig.versionDisplayName;\r\n\r\n                charIndex += songNameLength;\r\n            } break;\r\n            case SongTagCode.channelCount: {\r\n                this.pitchChannelCount = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                this.noiseChannelCount = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                if (fromBeepBox || beforeTwo) {\r\n                    // No mod channel support before jummbox v2\r\n                    this.modChannelCount = 0;\r\n                } else {\r\n                    this.modChannelCount = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                }\r\n                this.pitchChannelCount = validateRange(Config.pitchChannelCountMin, Config.pitchChannelCountMax, this.pitchChannelCount);\r\n                this.noiseChannelCount = validateRange(Config.noiseChannelCountMin, Config.noiseChannelCountMax, this.noiseChannelCount);\r\n                this.modChannelCount = validateRange(Config.modChannelCountMin, Config.modChannelCountMax, this.modChannelCount);\r\n\r\n                for (let channelIndex = this.channels.length; channelIndex < this.getChannelCount(); channelIndex++) {\r\n                    this.channels[channelIndex] = new Channel();\r\n                }\r\n                this.channels.length = this.getChannelCount();\r\n                if ((fromBeepBox && beforeNine) || (fromJummBox && beforeFive)) {\r\n                    for (let i: number = legacySettingsCache!.length; i < this.getChannelCount(); i++) {\r\n                        legacySettingsCache![i] = [];\r\n                        for (let j: number = 0; j < Config.instrumentCountMin; j++) legacySettingsCache![i][j] = {};\r\n                    }\r\n                }\r\n            } break;\r\n            case SongTagCode.scale: {\r\n                this.scale = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                // All the scales were jumbled around by Jummbox. Just convert to free.\r\n                if (fromBeepBox) this.scale = 0;\r\n            } break;\r\n            case SongTagCode.key: {\r\n                if (beforeSeven && fromBeepBox) {\r\n                    this.key = clamp(0, Config.keys.length, 11 - base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                } else {\r\n                    this.key = clamp(0, Config.keys.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                }\r\n            } break;\r\n            case SongTagCode.loopStart: {\r\n                if (beforeFive && fromBeepBox) {\r\n                    this.loopStart = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                } else {\r\n                    this.loopStart = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                }\r\n            } break;\r\n            case SongTagCode.loopEnd: {\r\n                if (beforeFive && fromBeepBox) {\r\n                    this.loopLength = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                } else {\r\n                    this.loopLength = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;\r\n                }\r\n            } break;\r\n            case SongTagCode.tempo: {\r\n                if (beforeFour && fromBeepBox) {\r\n                    this.tempo = [95, 120, 151, 190][base64CharCodeToInt[compressed.charCodeAt(charIndex++)]];\r\n                } else if (beforeSeven && fromBeepBox) {\r\n                    this.tempo = [88, 95, 103, 111, 120, 130, 140, 151, 163, 176, 190, 206, 222, 240, 259][base64CharCodeToInt[compressed.charCodeAt(charIndex++)]];\r\n                } else {\r\n                    this.tempo = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                }\r\n                this.tempo = clamp(Config.tempoMin, Config.tempoMax + 1, this.tempo);\r\n            } break;\r\n            case SongTagCode.reverb: {\r\n                if (beforeNine && fromBeepBox) {\r\n                    legacyGlobalReverb = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 12;\r\n                    legacyGlobalReverb = clamp(0, Config.reverbRange, legacyGlobalReverb);\r\n                } else if (beforeFive && fromJummBox) {\r\n                    legacyGlobalReverb = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                    legacyGlobalReverb = clamp(0, Config.reverbRange, legacyGlobalReverb);\r\n                } else {\r\n                    // Do nothing, BeepBox v9+ do not support song-wide reverb - JummBox still does via modulator.\r\n                }\r\n            } break;\r\n            case SongTagCode.beatCount: {\r\n                if (beforeThree && fromBeepBox) {\r\n                    this.beatsPerBar = [6, 7, 8, 9, 10][base64CharCodeToInt[compressed.charCodeAt(charIndex++)]];\r\n                } else {\r\n                    this.beatsPerBar = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;\r\n                }\r\n                this.beatsPerBar = Math.max(Config.beatsPerBarMin, Math.min(Config.beatsPerBarMax, this.beatsPerBar));\r\n            } break;\r\n            case SongTagCode.barCount: {\r\n                const barCount: number = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;\r\n                this.barCount = validateRange(Config.barCountMin, Config.barCountMax, barCount);\r\n                for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n                    for (let bar = this.channels[channelIndex].bars.length; bar < this.barCount; bar++) {\r\n                        this.channels[channelIndex].bars[bar] = (bar < 4) ? 1 : 0;\r\n                    }\r\n                    this.channels[channelIndex].bars.length = this.barCount;\r\n                }\r\n            } break;\r\n            case SongTagCode.patternCount: {\r\n                let patternsPerChannel: number;\r\n                if (beforeEight && fromBeepBox) {\r\n                    patternsPerChannel = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;\r\n                } else {\r\n                    patternsPerChannel = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1;\r\n                }\r\n                this.patternsPerChannel = validateRange(1, Config.barCountMax, patternsPerChannel);\r\n                const channelCount: number = this.getChannelCount();\r\n                for (let channelIndex: number = 0; channelIndex < channelCount; channelIndex++) {\r\n                    const patterns: Pattern[] = this.channels[channelIndex].patterns;\r\n                    for (let pattern = patterns.length; pattern < this.patternsPerChannel; pattern++) {\r\n                        patterns[pattern] = new Pattern();\r\n                    }\r\n                    patterns.length = this.patternsPerChannel;\r\n                }\r\n            } break;\r\n            case SongTagCode.instrumentCount: {\r\n                if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {\r\n                    const instrumentsPerChannel: number = validateRange(Config.instrumentCountMin, Config.patternInstrumentCountMax, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + Config.instrumentCountMin);\r\n                    this.layeredInstruments = false;\r\n                    this.patternInstruments = (instrumentsPerChannel > 1);\r\n\r\n                    for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n                        const isNoiseChannel: boolean = channelIndex >= this.pitchChannelCount && channelIndex < this.pitchChannelCount + this.noiseChannelCount;\r\n                        const isModChannel: boolean = channelIndex >= this.pitchChannelCount + this.noiseChannelCount;\r\n\r\n                        for (let instrumentIndex: number = this.channels[channelIndex].instruments.length; instrumentIndex < instrumentsPerChannel; instrumentIndex++) {\r\n                            this.channels[channelIndex].instruments[instrumentIndex] = new Instrument(isNoiseChannel, isModChannel);\r\n                        }\r\n                        this.channels[channelIndex].instruments.length = instrumentsPerChannel;\r\n                        if (beforeSix && fromBeepBox) {\r\n                            for (let instrumentIndex: number = 0; instrumentIndex < instrumentsPerChannel; instrumentIndex++) {\r\n                                this.channels[channelIndex].instruments[instrumentIndex].setTypeAndReset(isNoiseChannel ? InstrumentType.noise : InstrumentType.chip, isNoiseChannel, isModChannel);\r\n                            }\r\n                        }\r\n\r\n                        for (let j: number = legacySettingsCache![channelIndex].length; j < instrumentsPerChannel; j++) {\r\n                            legacySettingsCache![channelIndex][j] = {};\r\n                        }\r\n                    }\r\n                } else {\r\n                    const instrumentsFlagBits: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                    this.layeredInstruments = (instrumentsFlagBits & (1 << 1)) != 0;\r\n                    this.patternInstruments = (instrumentsFlagBits & (1 << 0)) != 0;\r\n                    for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n                        let instrumentCount: number = 1;\r\n                        if (this.layeredInstruments || this.patternInstruments) {\r\n                            instrumentCount = validateRange(Config.instrumentCountMin, this.getMaxInstrumentsPerChannel(), base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + Config.instrumentCountMin);\r\n                        }\r\n                        const channel: Channel = this.channels[channelIndex];\r\n                        const isNoiseChannel: boolean = this.getChannelIsNoise(channelIndex);\r\n                        const isModChannel: boolean = this.getChannelIsMod(channelIndex);\r\n                        for (let i: number = channel.instruments.length; i < instrumentCount; i++) {\r\n                            channel.instruments[i] = new Instrument(isNoiseChannel, isModChannel);\r\n                        }\r\n                        channel.instruments.length = instrumentCount;\r\n                    }\r\n                }\r\n            } break;\r\n            case SongTagCode.rhythm: {\r\n                this.rhythm = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                // Port all arpeggio speeds over to match what they were, before arpeggio speed was decoupled from rhythm.\r\n                if (fromJummBox && beforeThree || fromBeepBox) {\r\n                    // These are all the rhythms that had 4 ticks/arpeggio instead of 3.\r\n                    if (this.rhythm == Config.rhythms.dictionary[\"÷3 (triplets)\"].index || this.rhythm == Config.rhythms.dictionary[\"÷6\"].index) {\r\n                        useSlowerArpSpeed = true;\r\n                    }\r\n                    // Use faster two note arp on these rhythms\r\n                    if (this.rhythm >= Config.rhythms.dictionary[\"÷6\"].index) {\r\n                        useFastTwoNoteArp = true;\r\n                    }\r\n                }\r\n            } break;\r\n            case SongTagCode.channelOctave: {\r\n                if (beforeThree && fromBeepBox) {\r\n                    const channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                    this.channels[channelIndex].octave = clamp(0, Config.pitchOctaves, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1);\r\n                    if (channelIndex >= this.pitchChannelCount) this.channels[channelIndex].octave = 0;\r\n                } else if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {\r\n                    for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n                        this.channels[channelIndex].octave = clamp(0, Config.pitchOctaves, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1);\r\n                        if (channelIndex >= this.pitchChannelCount) this.channels[channelIndex].octave = 0;\r\n                    }\r\n                } else {\r\n                    for (let channelIndex: number = 0; channelIndex < this.pitchChannelCount; channelIndex++) {\r\n                        this.channels[channelIndex].octave = clamp(0, Config.pitchOctaves, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    }\r\n                    for (let channelIndex: number = this.pitchChannelCount; channelIndex < this.getChannelCount(); channelIndex++) {\r\n                        this.channels[channelIndex].octave = 0;\r\n                    }\r\n                }\r\n            } break;\r\n            case SongTagCode.startInstrument: {\r\n                instrumentIndexIterator++;\r\n                if (instrumentIndexIterator >= this.channels[instrumentChannelIterator].instruments.length) {\r\n                    instrumentChannelIterator++;\r\n                    instrumentIndexIterator = 0;\r\n                }\r\n                validateRange(0, this.channels.length - 1, instrumentChannelIterator);\r\n                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                // JB before v5 had custom chip in the place where pickedString is now, and mod one sooner as well. New index is +1 for both.\r\n                let instrumentType: number = validateRange(0, InstrumentType.length - 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                if (fromJummBox && beforeFive) {\r\n                    if (instrumentType == InstrumentType.pickedString) {\r\n                        instrumentType = InstrumentType.customChipWave;\r\n                    }\r\n                    else if (instrumentType == InstrumentType.customChipWave) {\r\n                        instrumentType = InstrumentType.mod;\r\n                    }\r\n                }\r\n                instrument.setTypeAndReset(instrumentType, instrumentChannelIterator >= this.pitchChannelCount && instrumentChannelIterator < this.pitchChannelCount + this.noiseChannelCount, instrumentChannelIterator >= this.pitchChannelCount + this.noiseChannelCount);\r\n\r\n                // Anti-aliasing was added in BeepBox 3.0 (v6->v7) and JummBox 1.3 (v1->v2 roughly but some leakage possible)\r\n                if (((beforeSeven && fromBeepBox) || (beforeTwo && fromJummBox)) && (instrumentType == InstrumentType.chip || instrumentType == InstrumentType.customChipWave || instrumentType == InstrumentType.pwm)) {\r\n                    instrument.aliases = true;\r\n                    instrument.distortion = 0;\r\n                    instrument.effects |= 1 << EffectType.distortion;\r\n                }\r\n                if (useSlowerArpSpeed) {\r\n                    instrument.arpeggioSpeed = 9; // x3/4 speed. This used to be tied to rhythm, but now it is decoupled to each instrument's arp speed slider. This flag gets set when importing older songs to keep things consistent.\r\n                }\r\n                if (useFastTwoNoteArp) {\r\n                    instrument.fastTwoNoteArp = true;\r\n                }\r\n\r\n                if (beforeSeven && fromBeepBox) {\r\n                    instrument.effects = 0;\r\n                    // Chip/noise instruments had arpeggio and FM had custom interval but neither\r\n                    // explicitly saved the chorus setting beforeSeven so enable it here.\r\n                    if (instrument.chord != Config.chords.dictionary[\"simultaneous\"].index) {\r\n                        // Enable chord if it was used.\r\n                        instrument.effects |= 1 << EffectType.chord;\r\n                    }\r\n                }\r\n            } break;\r\n            case SongTagCode.preset: {\r\n                const presetValue: number = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].preset = presetValue;\r\n                // Picked string was inserted before custom chip in JB v5, so bump up preset index.\r\n                if (fromJummBox && beforeFive) {\r\n                    if (this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].preset == InstrumentType.pickedString) {\r\n                        this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].preset = InstrumentType.customChipWave;\r\n                    }\r\n                }\r\n            } break;\r\n            case SongTagCode.wave: {\r\n                if (beforeThree && fromBeepBox) {\r\n                    const legacyWaves: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 0];\r\n                    const channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                    const instrument: Instrument = this.channels[channelIndex].instruments[0];\r\n                    instrument.chipWave = clamp(0, Config.chipWaves.length, legacyWaves[base64CharCodeToInt[compressed.charCodeAt(charIndex++)]] | 0);\r\n\r\n                    // Version 2 didn't save any settings for settings for filters, or envelopes,\r\n                    // just waves, so initialize them here I guess.\r\n                    instrument.convertLegacySettings(legacySettingsCache![channelIndex][0], forceSimpleFilter);\r\n\r\n                } else if (beforeSix && fromBeepBox) {\r\n                    const legacyWaves: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 0];\r\n                    for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n                        for (const instrument of this.channels[channelIndex].instruments) {\r\n                            if (channelIndex >= this.pitchChannelCount) {\r\n                                instrument.chipNoise = clamp(0, Config.chipNoises.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                            } else {\r\n                                instrument.chipWave = clamp(0, Config.chipWaves.length, legacyWaves[base64CharCodeToInt[compressed.charCodeAt(charIndex++)]] | 0);\r\n                            }\r\n                        }\r\n                    }\r\n                } else if (beforeSeven && fromBeepBox) {\r\n                    const legacyWaves: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 0];\r\n                    if (instrumentChannelIterator >= this.pitchChannelCount) {\r\n                        this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chipNoise = clamp(0, Config.chipNoises.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    } else {\r\n                        this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chipWave = clamp(0, Config.chipWaves.length, legacyWaves[base64CharCodeToInt[compressed.charCodeAt(charIndex++)]] | 0);\r\n                    }\r\n                } else {\r\n                    if (this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].type == InstrumentType.noise) {\r\n                        this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chipNoise = clamp(0, Config.chipNoises.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    } else {\r\n                        this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chipWave = clamp(0, Config.chipWaves.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    }\r\n                }\r\n            } break;\r\n            case SongTagCode.eqFilter: {\r\n                if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {\r\n                    if (beforeSeven && fromBeepBox) {\r\n                        const legacyToCutoff: number[] = [10, 6, 3, 0, 8, 5, 2];\r\n                        const legacyToEnvelope: string[] = [\"none\", \"none\", \"none\", \"none\", \"decay 1\", \"decay 2\", \"decay 3\"];\r\n\r\n                        if (beforeThree && fromBeepBox) {\r\n                            const channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                            const instrument: Instrument = this.channels[channelIndex].instruments[0];\r\n                            const legacySettings: LegacySettings = legacySettingsCache![channelIndex][0];\r\n                            const legacyFilter: number = [1, 3, 4, 5][clamp(0, legacyToCutoff.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];\r\n                            legacySettings.filterCutoff = legacyToCutoff[legacyFilter];\r\n                            legacySettings.filterResonance = 0;\r\n                            legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyToEnvelope[legacyFilter]];\r\n                            instrument.convertLegacySettings(legacySettings, forceSimpleFilter);\r\n                        } else if (beforeSix && fromBeepBox) {\r\n                            for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n                                for (let i: number = 0; i < this.channels[channelIndex].instruments.length; i++) {\r\n                                    const instrument: Instrument = this.channels[channelIndex].instruments[i];\r\n                                    const legacySettings: LegacySettings = legacySettingsCache![channelIndex][i];\r\n                                    const legacyFilter: number = clamp(0, legacyToCutoff.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] + 1);\r\n                                    if (channelIndex < this.pitchChannelCount) {\r\n                                        legacySettings.filterCutoff = legacyToCutoff[legacyFilter];\r\n                                        legacySettings.filterResonance = 0;\r\n                                        legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyToEnvelope[legacyFilter]];\r\n                                    } else {\r\n                                        legacySettings.filterCutoff = 10;\r\n                                        legacySettings.filterResonance = 0;\r\n                                        legacySettings.filterEnvelope = Config.envelopes.dictionary[\"none\"];\r\n                                    }\r\n                                    instrument.convertLegacySettings(legacySettings, forceSimpleFilter);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            const legacyFilter: number = clamp(0, legacyToCutoff.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                            const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                            const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n                            legacySettings.filterCutoff = legacyToCutoff[legacyFilter];\r\n                            legacySettings.filterResonance = 0;\r\n                            legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyToEnvelope[legacyFilter]];\r\n                            instrument.convertLegacySettings(legacySettings, forceSimpleFilter);\r\n                        }\r\n                    } else {\r\n                        const filterCutoffRange: number = 11;\r\n                        const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                        const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n                        legacySettings.filterCutoff = clamp(0, filterCutoffRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        instrument.convertLegacySettings(legacySettings, forceSimpleFilter);\r\n                    }\r\n                } else {\r\n                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                    let typeCheck: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\r\n                    if (fromBeepBox || typeCheck == 0) {\r\n                        instrument.eqFilterType = false;\r\n                        if (fromJummBox)\r\n                            typeCheck = base64CharCodeToInt[compressed.charCodeAt(charIndex++)]; // Skip to next to get control point count\r\n                        const originalControlPointCount: number = typeCheck;\r\n                        instrument.eqFilter.controlPointCount = clamp(0, Config.filterMaxPoints + 1, originalControlPointCount);\r\n                        for (let i: number = instrument.eqFilter.controlPoints.length; i < instrument.eqFilter.controlPointCount; i++) {\r\n                            instrument.eqFilter.controlPoints[i] = new FilterControlPoint();\r\n                        }\r\n                        for (let i: number = 0; i < instrument.eqFilter.controlPointCount; i++) {\r\n                            const point: FilterControlPoint = instrument.eqFilter.controlPoints[i];\r\n                            point.type = clamp(0, FilterType.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                            point.freq = clamp(0, Config.filterFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                            point.gain = clamp(0, Config.filterGainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        }\r\n                        for (let i: number = instrument.eqFilter.controlPointCount; i < originalControlPointCount; i++) {\r\n                            charIndex += 3;\r\n                        }\r\n\r\n                        // Get subfilters as well. Skip Index 0, is a copy of the base filter.\r\n                        instrument.eqSubFilters[0] = instrument.eqFilter;\r\n                        if (fromJummBox && !beforeFive) {\r\n                            let usingSubFilterBitfield: number = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                            for (let j: number = 0; j < Config.filterMorphCount - 1; j++) {\r\n                                if (usingSubFilterBitfield & (1 << j)) {\r\n                                    // Number of control points\r\n                                    const originalSubfilterControlPointCount: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                                    if (instrument.eqSubFilters[j + 1] == null)\r\n                                        instrument.eqSubFilters[j + 1] = new FilterSettings();\r\n                                    instrument.eqSubFilters[j + 1]!.controlPointCount = clamp(0, Config.filterMaxPoints + 1, originalSubfilterControlPointCount);\r\n                                    for (let i: number = instrument.eqSubFilters[j + 1]!.controlPoints.length; i < instrument.eqSubFilters[j + 1]!.controlPointCount; i++) {\r\n                                        instrument.eqSubFilters[j + 1]!.controlPoints[i] = new FilterControlPoint();\r\n                                    }\r\n                                    for (let i: number = 0; i < instrument.eqSubFilters[j + 1]!.controlPointCount; i++) {\r\n                                        const point: FilterControlPoint = instrument.eqSubFilters[j + 1]!.controlPoints[i];\r\n                                        point.type = clamp(0, FilterType.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                                        point.freq = clamp(0, Config.filterFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                                        point.gain = clamp(0, Config.filterGainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                                    }\r\n                                    for (let i: number = instrument.eqSubFilters[j + 1]!.controlPointCount; i < originalSubfilterControlPointCount; i++) {\r\n                                        charIndex += 3;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        instrument.eqFilterType = true;\r\n                        instrument.eqFilterSimpleCut = clamp(0, Config.filterSimpleCutRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        instrument.eqFilterSimplePeak = clamp(0, Config.filterSimplePeakRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    }\r\n                }\r\n            } break;\r\n            case SongTagCode.filterResonance: {\r\n                if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {\r\n                    const filterResonanceRange: number = 8;\r\n                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                    const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n                    legacySettings.filterResonance = clamp(0, filterResonanceRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    instrument.convertLegacySettings(legacySettings, forceSimpleFilter);\r\n\r\n                } else {\r\n                    // Do nothing? This song tag code is deprecated for now.\r\n                }\r\n            } break;\r\n            case SongTagCode.drumsetEnvelopes: {\r\n                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {\r\n                    if (instrument.type == InstrumentType.drumset) {\r\n                        for (let i: number = 0; i < Config.drumCount; i++) {\r\n                            instrument.drumsetEnvelopes[i] = Song._envelopeFromLegacyIndex(base64CharCodeToInt[compressed.charCodeAt(charIndex++)]).index;\r\n                        }\r\n                    } else {\r\n                        // This used to be used for general filter envelopes.\r\n                        // The presence of an envelope affects how convertLegacySettings\r\n                        // decides the closest possible approximation, so update it.\r\n                        const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n                        legacySettings.filterEnvelope = Song._envelopeFromLegacyIndex(base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        instrument.convertLegacySettings(legacySettings, forceSimpleFilter);\r\n                    }\r\n                } else {\r\n                    // This tag is now only used for drumset filter envelopes.\r\n                    for (let i: number = 0; i < Config.drumCount; i++) {\r\n                        instrument.drumsetEnvelopes[i] = clamp(0, Config.envelopes.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    }\r\n                }\r\n            } break;\r\n            case SongTagCode.pulseWidth: {\r\n                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                instrument.pulseWidth = clamp(0, Config.pulseWidthRange + (+(fromJummBox)), base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                if (fromBeepBox) {\r\n                    // BeepBox formula\r\n                    instrument.pulseWidth = Math.round(Math.pow(0.5, (7 - instrument.pulseWidth) * Config.pulseWidthStepPower) * Config.pulseWidthRange);\r\n\r\n                }\r\n\r\n                if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {\r\n                    const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n                    legacySettings.pulseEnvelope = Song._envelopeFromLegacyIndex(base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    instrument.convertLegacySettings(legacySettings, forceSimpleFilter);\r\n                }\r\n            } break;\r\n            case SongTagCode.stringSustain: {\r\n                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                instrument.stringSustain = clamp(0, Config.stringSustainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n            } break;\r\n            case SongTagCode.fadeInOut: {\r\n                if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {\r\n                    // this tag was used for a combination of transition and fade in/out.\r\n                    const legacySettings = [\r\n                        { transition: \"interrupt\", fadeInSeconds: 0.0, fadeOutTicks: -1 },\r\n                        { transition: \"normal\", fadeInSeconds: 0.0, fadeOutTicks: -3 },\r\n                        { transition: \"normal\", fadeInSeconds: 0.025, fadeOutTicks: -3 },\r\n                        { transition: \"slide in pattern\", fadeInSeconds: 0.025, fadeOutTicks: -3 },\r\n                        { transition: \"normal\", fadeInSeconds: 0.04, fadeOutTicks: 6 },\r\n                        { transition: \"normal\", fadeInSeconds: 0.0, fadeOutTicks: 48 },\r\n                        { transition: \"normal\", fadeInSeconds: 0.0125, fadeOutTicks: 72 },\r\n                        { transition: \"normal\", fadeInSeconds: 0.06, fadeOutTicks: 96 },\r\n                    ];\r\n                    if (beforeThree && fromBeepBox) {\r\n                        const channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                        const settings = legacySettings[clamp(0, legacySettings.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];\r\n                        const instrument: Instrument = this.channels[channelIndex].instruments[0];\r\n                        instrument.fadeIn = Synth.secondsToFadeInSetting(settings.fadeInSeconds);\r\n                        instrument.fadeOut = Synth.ticksToFadeOutSetting(settings.fadeOutTicks);\r\n                        instrument.transition = Config.transitions.dictionary[settings.transition].index;\r\n                        if (instrument.transition != Config.transitions.dictionary[\"normal\"].index) {\r\n                            // Enable transition if it was used.\r\n                            instrument.effects |= 1 << EffectType.transition;\r\n                        }\r\n                    } else if (beforeSix && fromBeepBox) {\r\n                        for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n                            for (const instrument of this.channels[channelIndex].instruments) {\r\n                                const settings = legacySettings[clamp(0, legacySettings.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];\r\n                                instrument.fadeIn = Synth.secondsToFadeInSetting(settings.fadeInSeconds);\r\n                                instrument.fadeOut = Synth.ticksToFadeOutSetting(settings.fadeOutTicks);\r\n                                instrument.transition = Config.transitions.dictionary[settings.transition].index;\r\n                                if (instrument.transition != Config.transitions.dictionary[\"normal\"].index) {\r\n                                    // Enable transition if it was used.\r\n                                    instrument.effects |= 1 << EffectType.transition;\r\n                                }\r\n                            }\r\n                        }\r\n                    } else if (beforeFour || fromBeepBox) {\r\n                        const settings = legacySettings[clamp(0, legacySettings.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];\r\n                        const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                        instrument.fadeIn = Synth.secondsToFadeInSetting(settings.fadeInSeconds);\r\n                        instrument.fadeOut = Synth.ticksToFadeOutSetting(settings.fadeOutTicks);\r\n                        instrument.transition = Config.transitions.dictionary[settings.transition].index;\r\n                        if (instrument.transition != Config.transitions.dictionary[\"normal\"].index) {\r\n                            // Enable transition if it was used.\r\n                            instrument.effects |= 1 << EffectType.transition;\r\n                        }\r\n                    } else {\r\n                        const settings = legacySettings[clamp(0, legacySettings.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)])];\r\n                        const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                        instrument.fadeIn = Synth.secondsToFadeInSetting(settings.fadeInSeconds);\r\n                        instrument.fadeOut = Synth.ticksToFadeOutSetting(settings.fadeOutTicks);\r\n                        instrument.transition = Config.transitions.dictionary[settings.transition].index;\r\n\r\n                        // Read tie-note\r\n                        if (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] > 0) {\r\n                            // Set legacy tie over flag, which is only used to port notes in patterns using this instrument as tying.\r\n                            instrument.legacyTieOver = true;\r\n\r\n                        }\r\n                        instrument.clicklessTransition = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] ? true : false;\r\n\r\n                        if (instrument.transition != Config.transitions.dictionary[\"normal\"].index || instrument.clicklessTransition) {\r\n                            // Enable transition if it was used.\r\n                            instrument.effects |= 1 << EffectType.transition;\r\n                        }\r\n                    }\r\n                } else {\r\n                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                    instrument.fadeIn = clamp(0, Config.fadeInRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    instrument.fadeOut = clamp(0, Config.fadeOutTicks.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    if (fromJummBox)\r\n                        instrument.clicklessTransition = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] ? true : false;\r\n                }\r\n            } break;\r\n            case SongTagCode.vibrato: {\r\n                if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {\r\n                    if (beforeSeven && fromBeepBox) {\r\n                        if (beforeThree && fromBeepBox) {\r\n                            const legacyEffects: number[] = [0, 3, 2, 0];\r\n                            const legacyEnvelopes: string[] = [\"none\", \"none\", \"none\", \"tremolo2\"];\r\n                            const channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                            const effect: number = clamp(0, legacyEffects.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                            const instrument: Instrument = this.channels[channelIndex].instruments[0];\r\n                            const legacySettings: LegacySettings = legacySettingsCache![channelIndex][0];\r\n                            instrument.vibrato = legacyEffects[effect];\r\n                            if (legacySettings.filterEnvelope == undefined || legacySettings.filterEnvelope.type == EnvelopeType.none) {\r\n                                // Imitate the legacy tremolo with a filter envelope.\r\n                                legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyEnvelopes[effect]];\r\n                                instrument.convertLegacySettings(legacySettings, forceSimpleFilter);\r\n                            }\r\n                            if (instrument.vibrato != Config.vibratos.dictionary[\"none\"].index) {\r\n                                // Enable vibrato if it was used.\r\n                                instrument.effects |= 1 << EffectType.vibrato;\r\n                            }\r\n                        } else if (beforeSix && fromBeepBox) {\r\n                            const legacyEffects: number[] = [0, 1, 2, 3, 0, 0];\r\n                            const legacyEnvelopes: string[] = [\"none\", \"none\", \"none\", \"none\", \"tremolo5\", \"tremolo2\"];\r\n                            for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n                                for (let i: number = 0; i < this.channels[channelIndex].instruments.length; i++) {\r\n                                    const effect: number = clamp(0, legacyEffects.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                                    const instrument: Instrument = this.channels[channelIndex].instruments[i];\r\n                                    const legacySettings: LegacySettings = legacySettingsCache![channelIndex][i];\r\n                                    instrument.vibrato = legacyEffects[effect];\r\n                                    if (legacySettings.filterEnvelope == undefined || legacySettings.filterEnvelope.type == EnvelopeType.none) {\r\n                                        // Imitate the legacy tremolo with a filter envelope.\r\n                                        legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyEnvelopes[effect]];\r\n                                        instrument.convertLegacySettings(legacySettings, forceSimpleFilter);\r\n                                    }\r\n                                    if (instrument.vibrato != Config.vibratos.dictionary[\"none\"].index) {\r\n                                        // Enable vibrato if it was used.\r\n                                        instrument.effects |= 1 << EffectType.vibrato;\r\n                                    }\r\n                                    if ((legacyGlobalReverb != 0 || (fromJummBox && beforeFive)) && !this.getChannelIsNoise(channelIndex)) {\r\n                                        // Enable reverb if it was used globaly before. (Global reverb was added before the effects option so I need to pick somewhere else to initialize instrument reverb, and I picked the vibrato command.)\r\n                                        instrument.effects |= 1 << EffectType.reverb;\r\n                                        instrument.reverb = legacyGlobalReverb;\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            const legacyEffects: number[] = [0, 1, 2, 3, 0, 0];\r\n                            const legacyEnvelopes: string[] = [\"none\", \"none\", \"none\", \"none\", \"tremolo5\", \"tremolo2\"];\r\n                            const effect: number = clamp(0, legacyEffects.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                            const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                            const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n                            instrument.vibrato = legacyEffects[effect];\r\n                            if (legacySettings.filterEnvelope == undefined || legacySettings.filterEnvelope.type == EnvelopeType.none) {\r\n                                // Imitate the legacy tremolo with a filter envelope.\r\n                                legacySettings.filterEnvelope = Config.envelopes.dictionary[legacyEnvelopes[effect]];\r\n                                instrument.convertLegacySettings(legacySettings, forceSimpleFilter);\r\n                            }\r\n                            if (instrument.vibrato != Config.vibratos.dictionary[\"none\"].index) {\r\n                                // Enable vibrato if it was used.\r\n                                instrument.effects |= 1 << EffectType.vibrato;\r\n                            }\r\n                            if (legacyGlobalReverb != 0 || (fromJummBox && beforeFive)) {\r\n                                // Enable reverb if it was used globaly before. (Global reverb was added before the effects option so I need to pick somewhere else to initialize instrument reverb, and I picked the vibrato command.)\r\n                                instrument.effects |= 1 << EffectType.reverb;\r\n                                instrument.reverb = legacyGlobalReverb;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                        const vibrato: number = clamp(0, Config.vibratos.length + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        instrument.vibrato = vibrato;\r\n                        if (instrument.vibrato != Config.vibratos.dictionary[\"none\"].index) {\r\n                            // Enable vibrato if it was used.\r\n                            instrument.effects |= 1 << EffectType.vibrato;\r\n                        }\r\n                        // Custom vibrato\r\n                        if (vibrato == Config.vibratos.length) {\r\n                            instrument.vibratoDepth = clamp(0, Config.modulators.dictionary[\"vibrato depth\"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) / 50;\r\n                            instrument.vibratoSpeed = clamp(0, Config.modulators.dictionary[\"vibrato speed\"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                            instrument.vibratoDelay = clamp(0, Config.modulators.dictionary[\"vibrato delay\"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) / 2;\r\n                            instrument.vibratoType = clamp(0, Config.vibratoTypes.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                            instrument.effects |= 1 << EffectType.vibrato;\r\n                        }\r\n                        // Enforce standard vibrato settings\r\n                        else {\r\n                            instrument.vibratoDepth = Config.vibratos[instrument.vibrato].amplitude;\r\n                            instrument.vibratoSpeed = 10; // Normal speed\r\n                            instrument.vibratoDelay = Config.vibratos[instrument.vibrato].delayTicks / 2;\r\n                            instrument.vibratoType = Config.vibratos[instrument.vibrato].type;\r\n                        }\r\n                    }\r\n                } else {\r\n                    // Do nothing? This song tag code is deprecated for now.\r\n                }\r\n            } break;\r\n            case SongTagCode.arpeggioSpeed: {\r\n                // Deprecated, but supported for legacy purposes\r\n                if (fromJummBox && beforeFive) {\r\n                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                    instrument.arpeggioSpeed = clamp(0, Config.modulators.dictionary[\"arp speed\"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    instrument.fastTwoNoteArp = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] ? true : false; // Two note arp setting piggybacks on this\r\n                }\r\n                else {\r\n                    // Do nothing, deprecated for now\r\n                }\r\n            } break;\r\n            case SongTagCode.unison: {\r\n                if (beforeThree && fromBeepBox) {\r\n                    const channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                    this.channels[channelIndex].instruments[0].unison = clamp(0, Config.unisons.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                } else if (beforeSix && fromBeepBox) {\r\n                    for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n                        for (const instrument of this.channels[channelIndex].instruments) {\r\n                            const originalValue: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                            let unison: number = clamp(0, Config.unisons.length, originalValue);\r\n                            if (originalValue == 8) {\r\n                                // original \"custom harmony\" now maps to \"hum\" and \"custom interval\".\r\n                                unison = 2;\r\n                                instrument.chord = 3;\r\n                            }\r\n                            instrument.unison = unison;\r\n                        }\r\n                    }\r\n                } else if (beforeSeven && fromBeepBox) {\r\n                    const originalValue: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                    let unison: number = clamp(0, Config.unisons.length, originalValue);\r\n                    if (originalValue == 8) {\r\n                        // original \"custom harmony\" now maps to \"hum\" and \"custom interval\".\r\n                        unison = 2;\r\n                        this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].chord = 3;\r\n                    }\r\n                    this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].unison = unison;\r\n                } else {\r\n                    this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].unison = clamp(0, Config.unisons.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                }\r\n            } break;\r\n            case SongTagCode.chord: {\r\n                if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {\r\n                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                    instrument.chord = clamp(0, Config.chords.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    if (instrument.chord != Config.chords.dictionary[\"simultaneous\"].index) {\r\n                        // Enable chord if it was used.\r\n                        instrument.effects |= 1 << EffectType.chord;\r\n                    }\r\n                } else {\r\n                    // Do nothing? This song tag code is deprecated for now.\r\n                }\r\n            } break;\r\n            case SongTagCode.effects: {\r\n                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {\r\n                    instrument.effects = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] & ((1 << EffectType.length) - 1));\r\n                    if (legacyGlobalReverb == 0 && !(fromJummBox && beforeFive)) {\r\n                        // Disable reverb if legacy song reverb was zero.\r\n                        instrument.effects &= ~(1 << EffectType.reverb);\r\n                    } else if (effectsIncludeReverb(instrument.effects)) {\r\n                        instrument.reverb = legacyGlobalReverb;\r\n                    }\r\n                    // @jummbus - Enabling pan effect on song import no matter what to make it a default.\r\n                    //if (instrument.pan != Config.panCenter) {\r\n                    instrument.effects |= 1 << EffectType.panning;\r\n                    //}\r\n                    if (instrument.vibrato != Config.vibratos.dictionary[\"none\"].index) {\r\n                        // Enable vibrato if it was used.\r\n                        instrument.effects |= 1 << EffectType.vibrato;\r\n                    }\r\n                    if (instrument.detune != Config.detuneCenter) {\r\n                        // Enable detune if it was used.\r\n                        instrument.effects |= 1 << EffectType.detune;\r\n                    }\r\n                    if (instrument.aliases)\r\n                        instrument.effects |= 1 << EffectType.distortion;\r\n                    else\r\n                        instrument.effects &= ~(1 << EffectType.distortion);\r\n\r\n                    // convertLegacySettings may need to force-enable note filter, call\r\n                    // it again here to make sure that this override takes precedence.\r\n                    const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n                    instrument.convertLegacySettings(legacySettings, forceSimpleFilter);\r\n                } else {\r\n                    // BeepBox currently uses six base64 characters at 6 bits each for a bitfield representing all the enabled effects.\r\n                    if (EffectType.length > 32) throw new Error();\r\n                    instrument.effects = (\r\n                        (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 5))\r\n                        | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 4))\r\n                        | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 3))\r\n                        | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 2))\r\n                        | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 1))\r\n                        | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << (6 * 0))\r\n                        ) >>> 0;\r\n\r\n                    if (effectsIncludeNoteFilter(instrument.effects)) {\r\n                        let typeCheck: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                        if (fromBeepBox || typeCheck == 0) {\r\n                            instrument.noteFilterType = false;\r\n                            if (fromJummBox)\r\n                                typeCheck = base64CharCodeToInt[compressed.charCodeAt(charIndex++)]; // Skip to next index in jummbox to get actual count\r\n                            instrument.noteFilter.controlPointCount = clamp(0, Config.filterMaxPoints + 1, typeCheck);\r\n                            for (let i: number = instrument.noteFilter.controlPoints.length; i < instrument.noteFilter.controlPointCount; i++) {\r\n                                instrument.noteFilter.controlPoints[i] = new FilterControlPoint();\r\n                            }\r\n                            for (let i: number = 0; i < instrument.noteFilter.controlPointCount; i++) {\r\n                                const point: FilterControlPoint = instrument.noteFilter.controlPoints[i];\r\n                                point.type = clamp(0, FilterType.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                                point.freq = clamp(0, Config.filterFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                                point.gain = clamp(0, Config.filterGainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                            }\r\n                            for (let i: number = instrument.noteFilter.controlPointCount; i < typeCheck; i++) {\r\n                                charIndex += 3;\r\n                            }\r\n\r\n                            // Get subfilters as well. Skip Index 0, is a copy of the base filter.\r\n                            instrument.noteSubFilters[0] = instrument.noteFilter;\r\n                            if (fromJummBox && !beforeFive) {\r\n                                let usingSubFilterBitfield: number = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                                for (let j: number = 0; j < Config.filterMorphCount - 1; j++) {\r\n                                    if (usingSubFilterBitfield & (1 << j)) {\r\n                                        // Number of control points\r\n                                        const originalSubfilterControlPointCount: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                                        if (instrument.noteSubFilters[j + 1] == null)\r\n                                            instrument.noteSubFilters[j + 1] = new FilterSettings();\r\n                                        instrument.noteSubFilters[j + 1]!.controlPointCount = clamp(0, Config.filterMaxPoints + 1, originalSubfilterControlPointCount);\r\n                                        for (let i: number = instrument.noteSubFilters[j + 1]!.controlPoints.length; i < instrument.noteSubFilters[j + 1]!.controlPointCount; i++) {\r\n                                            instrument.noteSubFilters[j + 1]!.controlPoints[i] = new FilterControlPoint();\r\n                                        }\r\n                                        for (let i: number = 0; i < instrument.noteSubFilters[j + 1]!.controlPointCount; i++) {\r\n                                            const point: FilterControlPoint = instrument.noteSubFilters[j + 1]!.controlPoints[i];\r\n                                            point.type = clamp(0, FilterType.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                                            point.freq = clamp(0, Config.filterFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                                            point.gain = clamp(0, Config.filterGainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                                        }\r\n                                        for (let i: number = instrument.noteSubFilters[j + 1]!.controlPointCount; i < originalSubfilterControlPointCount; i++) {\r\n                                            charIndex += 3;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            instrument.noteFilterType = true;\r\n                            instrument.noteFilter.reset();\r\n                            instrument.noteFilterSimpleCut = clamp(0, Config.filterSimpleCutRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                            instrument.noteFilterSimplePeak = clamp(0, Config.filterSimplePeakRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\r\n                        }\r\n                    }\r\n                    if (effectsIncludeTransition(instrument.effects)) {\r\n                        instrument.transition = clamp(0, Config.transitions.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    }\r\n                    if (effectsIncludeChord(instrument.effects)) {\r\n                        instrument.chord = clamp(0, Config.chords.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        // Custom arpeggio speed... only in JB, and only if the instrument arpeggiates.\r\n                        if (instrument.chord == Config.chords.dictionary[\"arpeggio\"].index && fromJummBox) {\r\n                            instrument.arpeggioSpeed = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                            instrument.fastTwoNoteArp = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) ? true : false;\r\n                        }\r\n                    }\r\n                    if (effectsIncludePitchShift(instrument.effects)) {\r\n                        instrument.pitchShift = clamp(0, Config.pitchShiftRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    }\r\n                    if (effectsIncludeDetune(instrument.effects)) {\r\n                        if (fromBeepBox) {\r\n                            // Convert from BeepBox's formula\r\n                            instrument.detune = clamp(Config.detuneMin, Config.detuneMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                            instrument.detune = Math.round((instrument.detune - 9) * (Math.abs(instrument.detune - 9) + 1) / 2 + Config.detuneCenter);\r\n                        } else {\r\n                            instrument.detune = clamp(Config.detuneMin, Config.detuneMax + 1, (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        }\r\n                    }\r\n                    if (effectsIncludeVibrato(instrument.effects)) {\r\n                        instrument.vibrato = clamp(0, Config.vibratos.length + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n\r\n                        // Custom vibrato\r\n                        if (instrument.vibrato == Config.vibratos.length && fromJummBox) {\r\n                            instrument.vibratoDepth = clamp(0, Config.modulators.dictionary[\"vibrato depth\"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) / 25;\r\n                            instrument.vibratoSpeed = clamp(0, Config.modulators.dictionary[\"vibrato speed\"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                            instrument.vibratoDelay = clamp(0, Config.modulators.dictionary[\"vibrato delay\"].maxRawVol + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                            instrument.vibratoType = clamp(0, Config.vibratoTypes.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        }\r\n                        // Enforce standard vibrato settings\r\n                        else {\r\n                            instrument.vibratoDepth = Config.vibratos[instrument.vibrato].amplitude;\r\n                            instrument.vibratoSpeed = 10; // Normal speed\r\n                            instrument.vibratoDelay = Config.vibratos[instrument.vibrato].delayTicks / 2;\r\n                            instrument.vibratoType = Config.vibratos[instrument.vibrato].type;\r\n                        }\r\n                    }\r\n                    if (effectsIncludeDistortion(instrument.effects)) {\r\n                        instrument.distortion = clamp(0, Config.distortionRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        if (fromJummBox && !beforeFive)\r\n                            instrument.aliases = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] ? true : false;\r\n                    }\r\n                    if (effectsIncludeBitcrusher(instrument.effects)) {\r\n                        instrument.bitcrusherFreq = clamp(0, Config.bitcrusherFreqRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        instrument.bitcrusherQuantization = clamp(0, Config.bitcrusherQuantizationRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    }\r\n                    if (effectsIncludePanning(instrument.effects)) {\r\n                        if (fromBeepBox) {\r\n                            // Beepbox has a panMax of 8 (9 total positions), Jummbox has a panMax of 100 (101 total positions)\r\n                            instrument.pan = clamp(0, Config.panMax + 1, Math.round(base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * ((Config.panMax) / 8.0)));\r\n                        }\r\n                        else {\r\n                            instrument.pan = clamp(0, Config.panMax + 1, (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        }\r\n\r\n                        // Now, pan delay follows on new versions of jummbox.\r\n                        if (fromJummBox && !beforeTwo)\r\n                            instrument.panDelay = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                    }\r\n                    if (effectsIncludeChorus(instrument.effects)) {\r\n                        if (fromBeepBox) {\r\n                            // BeepBox has 4 chorus values vs. JB's 8\r\n                            instrument.chorus = clamp(0, (Config.chorusRange / 2) + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) * 2;\r\n                        }\r\n                        else {\r\n                            instrument.chorus = clamp(0, Config.chorusRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        }\r\n                    }\r\n                    if (effectsIncludeEcho(instrument.effects)) {\r\n                        instrument.echoSustain = clamp(0, Config.echoSustainRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        instrument.echoDelay = clamp(0, Config.echoDelayRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    }\r\n                    if (effectsIncludeReverb(instrument.effects)) {\r\n                        if (fromBeepBox) {\r\n                            instrument.reverb = clamp(0, Config.reverbRange, Math.round(base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * Config.reverbRange / 3.0));\r\n                        } else {\r\n                            instrument.reverb = clamp(0, Config.reverbRange, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        }\r\n                    }\r\n                    if (effectsIncludeNoteRange(instrument.effects)) {\r\n                        instrument.upperNoteLimit = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                        instrument.lowerNoteLimit = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                    }\r\n\r\n                    if (effectsIncludeInvertWave(instrument.effects)) {\r\n                        instrument.invertWave = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] ? true : false);\r\n                    }\r\n                }\r\n                // Clamp the range.\r\n                instrument.effects &= (1 << EffectType.length) - 1;\r\n            } break;\r\n            case SongTagCode.volume: {\r\n                if (beforeThree && fromBeepBox) {\r\n                    const channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                    const instrument: Instrument = this.channels[channelIndex].instruments[0];\r\n                    instrument.volume = Math.round(clamp(-Config.volumeRange / 2, 1, -base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 5.0));\r\n                } else if (beforeSix && fromBeepBox) {\r\n                    for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n                        for (const instrument of this.channels[channelIndex].instruments) {\r\n                            instrument.volume = Math.round(clamp(-Config.volumeRange / 2, 1, -base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 5.0));\r\n                        }\r\n                    }\r\n                } else if (beforeSeven && fromBeepBox) {\r\n                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                    instrument.volume = Math.round(clamp(-Config.volumeRange / 2, 1, -base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 5.0));\r\n                } else if (fromBeepBox) {\r\n                    // Beepbox v9's volume range is 0-7 (0 is max, 7 is mute)\r\n                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                    instrument.volume = Math.round(clamp(-Config.volumeRange / 2, 1, -base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 25.0 / 7.0));\r\n                } else {\r\n                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                    // Volume is stored in two bytes in jummbox just in case range ever exceeds one byte, e.g. through later waffling on the subject.\r\n                    instrument.volume = Math.round(clamp(-Config.volumeRange / 2, Config.volumeRange / 2 + 1, ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) | (base64CharCodeToInt[compressed.charCodeAt(charIndex++)])) - Config.volumeRange / 2));\r\n                }\r\n            } break;\r\n            case SongTagCode.pan: {\r\n                if (beforeNine && fromBeepBox) {\r\n                    // Beepbox has a panMax of 8 (9 total positions), Jummbox has a panMax of 100 (101 total positions)\r\n                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                    instrument.pan = clamp(0, Config.panMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * ((Config.panMax) / 8.0));\r\n                } else if (beforeFive && fromJummBox) {\r\n                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                    instrument.pan = clamp(0, Config.panMax + 1, (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    // Pan delay follows on v3 + v4\r\n                    if (fromJummBox && !beforeThree) {\r\n                        instrument.panDelay = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                    }\r\n                } else {\r\n                    // Do nothing? This song tag code is deprecated for now.\r\n                }\r\n            } break;\r\n            case SongTagCode.detune: {\r\n                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n\r\n                if (fromJummBox && beforeFive) {\r\n                    // Before jummbox v5, detune was -50 to 50. Now it is 0 to 400\r\n                    instrument.detune = clamp(Config.detuneMin, Config.detuneMax + 1, ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) * 4);\r\n                    instrument.effects |= 1 << EffectType.detune;\r\n                } else {\r\n                    // Now in v5, tag code is deprecated and handled thru detune effects.\r\n                }\r\n            } break;\r\n            case SongTagCode.customChipWave: {\r\n                let instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                // Pop custom wave values\r\n                for (let j: number = 0; j < 64; j++) {\r\n                    instrument.customChipWave[j]\r\n                        = clamp(-24, 25, base64CharCodeToInt[compressed.charCodeAt(charIndex++)] - 24);\r\n                }\r\n\r\n                let sum: number = 0.0;\r\n                for (let i: number = 0; i < instrument.customChipWave.length; i++) {\r\n                    sum += instrument.customChipWave[i];\r\n                }\r\n                const average: number = sum / instrument.customChipWave.length;\r\n\r\n                // Perform the integral on the wave. The chipSynth will perform the derivative to get the original wave back but with antialiasing.\r\n                let cumulative: number = 0;\r\n                let wavePrev: number = 0;\r\n                for (let i: number = 0; i < instrument.customChipWave.length; i++) {\r\n                    cumulative += wavePrev;\r\n                    wavePrev = instrument.customChipWave[i] - average;\r\n                    instrument.customChipWaveIntegral[i] = cumulative;\r\n                }\r\n\r\n                // 65th, last sample is for anti-aliasing\r\n                instrument.customChipWaveIntegral[64] = 0.0;\r\n\r\n            } break;\r\n            case SongTagCode.limiterSettings: {\r\n                let nextValue: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\r\n                // Check if limiter settings are used... if not, restore to default\r\n                if (nextValue == 0x3f) {\r\n                    this.restoreLimiterDefaults();\r\n                }\r\n                else {\r\n                    // Limiter is used, grab values\r\n                    this.compressionRatio = (nextValue < 10 ? nextValue / 10 : (1 + (nextValue - 10) / 60));\r\n                    nextValue = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                    this.limitRatio = (nextValue < 10 ? nextValue / 10 : (nextValue - 9));\r\n                    this.limitDecay = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                    this.limitRise = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)] * 250.0) + 2000.0;\r\n                    this.compressionThreshold = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] / 20.0;\r\n                    this.limitThreshold = base64CharCodeToInt[compressed.charCodeAt(charIndex++)] / 20.0;\r\n                    this.masterGain = ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) / 50.0;\r\n                }\r\n            } break;\r\n            case SongTagCode.channelNames: {\r\n                for (let channel: number = 0; channel < this.getChannelCount(); channel++) {\r\n                    // Length of channel name string. Due to some crazy Unicode characters this needs to be 2 bytes...\r\n                    var channelNameLength;\r\n                    if (beforeFour)\r\n                        channelNameLength = base64CharCodeToInt[compressed.charCodeAt(charIndex++)]\r\n                    else\r\n                        channelNameLength = ((base64CharCodeToInt[compressed.charCodeAt(charIndex++)] << 6) + base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    this.channels[channel].name = decodeURIComponent(compressed.substring(charIndex, charIndex + channelNameLength));\r\n\r\n                    charIndex += channelNameLength;\r\n                }\r\n            } break;\r\n            case SongTagCode.algorithm: {\r\n                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                instrument.algorithm = clamp(0, Config.algorithms.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {\r\n                    // The algorithm determines the carrier count, which affects how legacy settings are imported.\r\n                    const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n                    instrument.convertLegacySettings(legacySettings, forceSimpleFilter);\r\n                }\r\n            } break;\r\n            case SongTagCode.feedbackType: {\r\n                this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].feedbackType = clamp(0, Config.feedbacks.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n            } break;\r\n            case SongTagCode.feedbackAmplitude: {\r\n                this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].feedbackAmplitude = clamp(0, Config.operatorAmplitudeMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n            } break;\r\n            case SongTagCode.feedbackEnvelope: {\r\n                if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {\r\n                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                    const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n                    legacySettings.feedbackEnvelope = Song._envelopeFromLegacyIndex(base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    instrument.convertLegacySettings(legacySettings, forceSimpleFilter);\r\n                } else {\r\n                    // Do nothing? This song tag code is deprecated for now.\r\n                }\r\n            } break;\r\n            case SongTagCode.operatorFrequencies: {\r\n                for (let o: number = 0; o < Config.operatorCount; o++) {\r\n                    this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].operators[o].frequency = clamp(0, Config.operatorFrequencies.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                }\r\n            } break;\r\n            case SongTagCode.operatorAmplitudes: {\r\n                for (let o: number = 0; o < Config.operatorCount; o++) {\r\n                    this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator].operators[o].amplitude = clamp(0, Config.operatorAmplitudeMax + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                }\r\n            } break;\r\n            case SongTagCode.envelopes: {\r\n                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {\r\n                    const legacySettings: LegacySettings = legacySettingsCache![instrumentChannelIterator][instrumentIndexIterator];\r\n                    legacySettings.operatorEnvelopes = [];\r\n                    for (let o: number = 0; o < Config.operatorCount; o++) {\r\n                        legacySettings.operatorEnvelopes[o] = Song._envelopeFromLegacyIndex(base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    }\r\n                    instrument.convertLegacySettings(legacySettings, forceSimpleFilter);\r\n                } else {\r\n                    const envelopeCount: number = clamp(0, Config.maxEnvelopeCount + 1, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    for (let i: number = 0; i < envelopeCount; i++) {\r\n                        const target: number = clamp(0, Config.instrumentAutomationTargets.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        let index: number = 0;\r\n                        const maxCount: number = Config.instrumentAutomationTargets[target].maxCount;\r\n                        if (maxCount > 1) {\r\n                            index = clamp(0, maxCount, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        }\r\n                        const envelope: number = clamp(0, Config.envelopes.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                        instrument.addEnvelope(target, index, envelope);\r\n                    }\r\n                }\r\n            } break;\r\n            case SongTagCode.operatorWaves: {\r\n                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                for (let o: number = 0; o < Config.operatorCount; o++) {\r\n                    instrument.operators[o].waveform = clamp(0, Config.operatorWaves.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    // Pulse width follows, if it is a pulse width operator wave\r\n                    if (instrument.operators[o].waveform == 3) {\r\n                        instrument.operators[o].pulseWidth = clamp(0, Config.pwmOperatorWaves.length, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    }\r\n                }\r\n            } break;\r\n            case SongTagCode.spectrum: {\r\n                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                if (instrument.type == InstrumentType.spectrum) {\r\n                    const byteCount: number = Math.ceil(Config.spectrumControlPoints * Config.spectrumControlPointBits / 6)\r\n                    const bits: BitFieldReader = new BitFieldReader(compressed, charIndex, charIndex + byteCount);\r\n                    for (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n                        instrument.spectrumWave.spectrum[i] = bits.read(Config.spectrumControlPointBits);\r\n                    }\r\n                    instrument.spectrumWave.markCustomWaveDirty();\r\n                    charIndex += byteCount;\r\n                } else if (instrument.type == InstrumentType.drumset) {\r\n                    const byteCount: number = Math.ceil(Config.drumCount * Config.spectrumControlPoints * Config.spectrumControlPointBits / 6)\r\n                    const bits: BitFieldReader = new BitFieldReader(compressed, charIndex, charIndex + byteCount);\r\n                    for (let j: number = 0; j < Config.drumCount; j++) {\r\n                        for (let i: number = 0; i < Config.spectrumControlPoints; i++) {\r\n                            instrument.drumsetSpectrumWaves[j].spectrum[i] = bits.read(Config.spectrumControlPointBits);\r\n                        }\r\n                        instrument.drumsetSpectrumWaves[j].markCustomWaveDirty();\r\n                    }\r\n                    charIndex += byteCount;\r\n                } else {\r\n                    throw new Error(\"Unhandled instrument type for spectrum song tag code.\");\r\n                }\r\n            } break;\r\n            case SongTagCode.harmonics: {\r\n                const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                const byteCount: number = Math.ceil(Config.harmonicsControlPoints * Config.harmonicsControlPointBits / 6)\r\n                const bits: BitFieldReader = new BitFieldReader(compressed, charIndex, charIndex + byteCount);\r\n                for (let i: number = 0; i < Config.harmonicsControlPoints; i++) {\r\n                    instrument.harmonicsWave.harmonics[i] = bits.read(Config.harmonicsControlPointBits);\r\n                }\r\n                instrument.harmonicsWave.markCustomWaveDirty();\r\n                charIndex += byteCount;\r\n            } break;\r\n            case SongTagCode.aliases: {\r\n                if (fromJummBox && beforeFive) {\r\n                    const instrument: Instrument = this.channels[instrumentChannelIterator].instruments[instrumentIndexIterator];\r\n                    instrument.aliases = (base64CharCodeToInt[compressed.charCodeAt(charIndex++)]) ? true : false;\r\n                    if (instrument.aliases) {\r\n                        instrument.distortion = 0;\r\n                        instrument.effects |= 1 << EffectType.distortion;\r\n                    }\r\n                } else {\r\n                    // Do nothing, deprecated\r\n                }\r\n            }\r\n                break;\r\n            case SongTagCode.bars: {\r\n                let subStringLength: number;\r\n                if (beforeThree && fromBeepBox) {\r\n                    const channelIndex: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                    const barCount: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                    subStringLength = Math.ceil(barCount * 0.5);\r\n                    const bits: BitFieldReader = new BitFieldReader(compressed, charIndex, charIndex + subStringLength);\r\n                    for (let i: number = 0; i < barCount; i++) {\r\n                        this.channels[channelIndex].bars[i] = bits.read(3) + 1;\r\n                    }\r\n                } else if (beforeFive && fromBeepBox) {\r\n                    let neededBits: number = 0;\r\n                    while ((1 << neededBits) < this.patternsPerChannel) neededBits++;\r\n                    subStringLength = Math.ceil(this.getChannelCount() * this.barCount * neededBits / 6);\r\n                    const bits: BitFieldReader = new BitFieldReader(compressed, charIndex, charIndex + subStringLength);\r\n                    for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n                        for (let i: number = 0; i < this.barCount; i++) {\r\n                            this.channels[channelIndex].bars[i] = bits.read(neededBits) + 1;\r\n                        }\r\n                    }\r\n                } else {\r\n                    let neededBits: number = 0;\r\n                    while ((1 << neededBits) < this.patternsPerChannel + 1) neededBits++;\r\n                    subStringLength = Math.ceil(this.getChannelCount() * this.barCount * neededBits / 6);\r\n                    const bits: BitFieldReader = new BitFieldReader(compressed, charIndex, charIndex + subStringLength);\r\n                    for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n                        for (let i: number = 0; i < this.barCount; i++) {\r\n                            this.channels[channelIndex].bars[i] = bits.read(neededBits);\r\n                        }\r\n                    }\r\n                }\r\n                charIndex += subStringLength;\r\n            } break;\r\n            case SongTagCode.patterns: {\r\n                let bitStringLength: number = 0;\r\n                let channelIndex: number;\r\n                let largerChords: boolean = !((beforeFour && fromJummBox) || fromBeepBox);\r\n                let recentPitchBitLength: number = (largerChords ? 4 : 3);\r\n                let recentPitchLength: number = (largerChords ? 16 : 8);\r\n                if (beforeThree && fromBeepBox) {\r\n                    channelIndex = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\r\n                    // The old format used the next character to represent the number of patterns in the channel, which is usually eight, the default.\r\n                    charIndex++; //let patternCount: number = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n\r\n                    bitStringLength = base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                    bitStringLength = bitStringLength << 6;\r\n                    bitStringLength += base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                } else {\r\n                    channelIndex = 0;\r\n                    let bitStringLengthLength: number = validateRange(1, 4, base64CharCodeToInt[compressed.charCodeAt(charIndex++)]);\r\n                    while (bitStringLengthLength > 0) {\r\n                        bitStringLength = bitStringLength << 6;\r\n                        bitStringLength += base64CharCodeToInt[compressed.charCodeAt(charIndex++)];\r\n                        bitStringLengthLength--;\r\n                    }\r\n                }\r\n\r\n                const bits: BitFieldReader = new BitFieldReader(compressed, charIndex, charIndex + bitStringLength);\r\n                charIndex += bitStringLength;\r\n\r\n                const bitsPerNoteSize: number = Song.getNeededBits(Config.noteSizeMax);\r\n                let songReverbChannel: number = -1;\r\n                let songReverbInstrument: number = -1;\r\n                let songReverbIndex: number = -1;\r\n\r\n                while (true) {\r\n                    const channel: Channel = this.channels[channelIndex];\r\n                    const isNoiseChannel: boolean = this.getChannelIsNoise(channelIndex);\r\n                    const isModChannel: boolean = this.getChannelIsMod(channelIndex);\r\n\r\n                    const maxInstrumentsPerPattern: number = this.getMaxInstrumentsPerPattern(channelIndex);\r\n                    const neededInstrumentCountBits: number = Song.getNeededBits(maxInstrumentsPerPattern - Config.instrumentCountMin);\r\n\r\n                    const neededInstrumentIndexBits: number = Song.getNeededBits(channel.instruments.length - 1);\r\n\r\n                    // Some info about modulator settings immediately follows in mod channels.\r\n                    if (isModChannel) {\r\n\r\n                        // 2 more indices for 'all' and 'active'\r\n                        const neededModInstrumentIndexBits: number = (beforeFive) ? neededInstrumentIndexBits : Song.getNeededBits(this.getMaxInstrumentsPerChannel() + 2);\r\n\r\n                        for (let instrumentIndex: number = 0; instrumentIndex < channel.instruments.length; instrumentIndex++) {\r\n\r\n                            let instrument: Instrument = channel.instruments[instrumentIndex];\r\n\r\n                            for (let mod: number = 0; mod < Config.modCount; mod++) {\r\n                                // Still using legacy \"mod status\" format, but doing it manually as it's only used in the URL now.\r\n                                // 0 - For pitch/noise\r\n                                // 1 - (used to be For noise, not needed)\r\n                                // 2 - For song\r\n                                // 3 - None\r\n                                let status: number = bits.read(2);\r\n\r\n                                switch (status) {\r\n                                    case 0: // Pitch\r\n                                        instrument.modChannels[mod] = clamp(0, this.pitchChannelCount + this.noiseChannelCount + 1, bits.read(8));\r\n                                        instrument.modInstruments[mod] = clamp(0, this.channels[instrument.modChannels[mod]].instruments.length + 2, bits.read(neededModInstrumentIndexBits));\r\n                                        break;\r\n                                    case 1: // Noise\r\n                                        // Getting a status of 1 means this is legacy mod info. Need to add pitch channel count, as it used to just store noise channel index and not overall channel index\r\n                                        instrument.modChannels[mod] = this.pitchChannelCount + clamp(0, this.noiseChannelCount + 1, bits.read(8));\r\n                                        instrument.modInstruments[mod] = clamp(0, this.channels[instrument.modChannels[mod]].instruments.length + 2, bits.read(neededInstrumentIndexBits));\r\n                                        break;\r\n                                    case 2: // For song\r\n                                        instrument.modChannels[mod] = -1;\r\n                                        break;\r\n                                    case 3: // None\r\n                                        instrument.modChannels[mod] = -2;\r\n                                        break;\r\n                                }\r\n\r\n                                // Mod setting is only used if the status isn't \"none\".\r\n                                if (status != 3) {\r\n                                    instrument.modulators[mod] = bits.read(6);\r\n                                }\r\n\r\n                                if (!beforeFive && (Config.modulators[instrument.modulators[mod]].name == \"eq filter\" || Config.modulators[instrument.modulators[mod]].name == \"note filter\")) {\r\n                                    instrument.modFilterTypes[mod] = bits.read(6);\r\n                                }\r\n\r\n                                if (beforeFive && instrument.modChannels[mod] >= 0) {\r\n                                    let forNoteFilter: boolean = effectsIncludeNoteFilter(this.channels[instrument.modChannels[mod]].instruments[instrument.modInstruments[mod]].effects);\r\n\r\n                                    // For legacy filter cut/peak, need to denote since scaling must be applied\r\n                                    if (instrument.modulators[mod] == 7) {\r\n                                        // Legacy filter cut index\r\n                                        // Check if there is no filter dot on prospective filter. If so, add a low pass at max possible freq.\r\n\r\n                                        if (forNoteFilter) {\r\n                                            instrument.modulators[mod] = Config.modulators.dictionary[\"note filt cut\"].index;\r\n                                        }\r\n                                        else {\r\n                                            instrument.modulators[mod] = Config.modulators.dictionary[\"eq filt cut\"].index;\r\n                                        }\r\n\r\n                                        instrument.modFilterTypes[mod] = 1; // Dot 1 X\r\n\r\n                                    }\r\n                                    else if (instrument.modulators[mod] == 8) {\r\n                                        // Legacy filter peak index\r\n                                        if (forNoteFilter) {\r\n                                            instrument.modulators[mod] = Config.modulators.dictionary[\"note filt peak\"].index;\r\n                                        }\r\n                                        else {\r\n                                            instrument.modulators[mod] = Config.modulators.dictionary[\"eq filt peak\"].index;\r\n                                        }\r\n\r\n                                        instrument.modFilterTypes[mod] = 2; // Dot 1 Y\r\n                                    }\r\n                                }\r\n                                else if (beforeFive) {\r\n                                    // Check for song reverb mod, which must be handled differently now that it is a multiplier\r\n                                    if (instrument.modulators[mod] == Config.modulators.dictionary[\"song reverb\"].index) {\r\n                                        songReverbChannel = channelIndex;\r\n                                        songReverbInstrument = instrumentIndex;\r\n                                        songReverbIndex = mod;\r\n                                    }\r\n                                }\r\n\r\n                                // Based on setting, enable some effects for the modulated instrument. This isn't always set, say if the instrument's pan was right in the center.\r\n                                // Only used on import of old songs, because sometimes an invalid effect can be set in a mod in the new version that is actually unused. In that case,\r\n                                // keeping the mod invalid is better since it preserves the state.\r\n                                if (beforeFive && Config.modulators[instrument.modulators[mod]].associatedEffect != EffectType.length) {\r\n                                    this.channels[instrument.modChannels[mod]].instruments[instrument.modInstruments[mod]].effects |= 1 << Config.modulators[instrument.modulators[mod]].associatedEffect;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // Scalar applied to detune mods since its granularity was upped. Could be repurposed later if any other granularity changes occur.\r\n                    const detuneScaleNotes: number[][] = [];\r\n                    for (let j: number = 0; j < channel.instruments.length; j++) {\r\n                        detuneScaleNotes[j] = [];\r\n                        for (let i: number = 0; i < Config.modCount; i++) {\r\n                            detuneScaleNotes[j][Config.modCount - 1 - i] = 1 + 3 * +(beforeFive && fromJummBox && isModChannel && (channel.instruments[j].modulators[i] == Config.modulators.dictionary[\"detune\"].index));\r\n                        }\r\n                    }\r\n                    const octaveOffset: number = (isNoiseChannel || isModChannel) ? 0 : channel.octave * 12;\r\n                    let lastPitch: number = ((isNoiseChannel || isModChannel) ? 4 : octaveOffset);\r\n                    const recentPitches: number[] = isModChannel ? [0, 1, 2, 3, 4, 5] : (isNoiseChannel ? [4, 6, 7, 2, 3, 8, 0, 10] : [0, 7, 12, 19, 24, -5, -12]);\r\n                    const recentShapes: any[] = [];\r\n                    for (let i: number = 0; i < recentPitches.length; i++) {\r\n                        recentPitches[i] += octaveOffset;\r\n                    }\r\n                    for (let i: number = 0; i < this.patternsPerChannel; i++) {\r\n                        const newPattern: Pattern = channel.patterns[i];\r\n\r\n                        if ((beforeNine && fromBeepBox) || (beforeFive && fromJummBox)) {\r\n                            newPattern.instruments[0] = validateRange(0, channel.instruments.length - 1, bits.read(neededInstrumentIndexBits));\r\n                            newPattern.instruments.length = 1;\r\n                        } else {\r\n                            if (this.patternInstruments) {\r\n                                const instrumentCount: number = validateRange(Config.instrumentCountMin, maxInstrumentsPerPattern, bits.read(neededInstrumentCountBits) + Config.instrumentCountMin);\r\n                                for (let j: number = 0; j < instrumentCount; j++) {\r\n                                    newPattern.instruments[j] = validateRange(0, channel.instruments.length - 1 + +(isModChannel) * 2, bits.read(neededInstrumentIndexBits));\r\n                                }\r\n                                newPattern.instruments.length = instrumentCount;\r\n                            } else {\r\n                                newPattern.instruments[0] = 0;\r\n                                newPattern.instruments.length = Config.instrumentCountMin;\r\n                            }\r\n                        }\r\n\r\n                        if (!(fromBeepBox && beforeThree) && bits.read(1) == 0) {\r\n                            newPattern.notes.length = 0;\r\n                            continue;\r\n                        }\r\n\r\n                        let curPart: number = 0;\r\n                        const newNotes: Note[] = newPattern.notes;\r\n                        let noteCount: number = 0;\r\n                        // Due to arbitrary note positioning, mod channels don't end the count until curPart actually exceeds the max\r\n                        while (curPart < this.beatsPerBar * Config.partsPerBeat + (+isModChannel)) {\r\n\r\n                            const useOldShape: boolean = bits.read(1) == 1;\r\n                            let newNote: boolean = false;\r\n                            let shapeIndex: number = 0;\r\n                            if (useOldShape) {\r\n                                shapeIndex = validateRange(0, recentShapes.length - 1, bits.readLongTail(0, 0));\r\n                            } else {\r\n                                newNote = bits.read(1) == 1;\r\n                            }\r\n\r\n                            if (!useOldShape && !newNote) {\r\n                                // For mod channels, check if you need to move backward too (notes can appear in any order and offset from each other).\r\n                                if (isModChannel) {\r\n                                    const isBackwards: boolean = bits.read(1) == 1;\r\n                                    const restLength: number = bits.readPartDuration();\r\n                                    if (isBackwards) {\r\n                                        curPart -= restLength;\r\n                                    }\r\n                                    else {\r\n                                        curPart += restLength;\r\n                                    }\r\n                                } else {\r\n                                    const restLength: number = (beforeSeven && fromBeepBox)\r\n                                        ? bits.readLegacyPartDuration() * Config.partsPerBeat / Config.rhythms[this.rhythm].stepsPerBeat\r\n                                        : bits.readPartDuration();\r\n                                    curPart += restLength;\r\n\r\n                                }\r\n                            } else {\r\n                                let shape: any;\r\n                                if (useOldShape) {\r\n                                    shape = recentShapes[shapeIndex];\r\n                                    recentShapes.splice(shapeIndex, 1);\r\n                                } else {\r\n                                    shape = {};\r\n\r\n                                    if (!largerChords) {\r\n                                        // Old format: X 1's followed by a 0 => X+1 pitches, up to 4\r\n                                        shape.pitchCount = 1;\r\n                                        while (shape.pitchCount < 4 && bits.read(1) == 1) shape.pitchCount++;\r\n                                    }\r\n                                    else {\r\n                                        // New format is:\r\n                                        //      0: 1 pitch\r\n                                        // 1[XXX]: 3 bits of binary signifying 2+ pitches\r\n                                        if (bits.read(1) == 1) {\r\n                                            shape.pitchCount = bits.read(3) + 2;\r\n                                        }\r\n                                        else {\r\n                                            shape.pitchCount = 1;\r\n                                        }\r\n                                    }\r\n\r\n                                    shape.pinCount = bits.readPinCount();\r\n                                    if (fromBeepBox) {\r\n                                        shape.initialSize = bits.read(2) * 2;\r\n                                    } else if (!isModChannel) {\r\n                                        shape.initialSize = bits.read(bitsPerNoteSize);\r\n                                    } else {\r\n                                        shape.initialSize = bits.read(9);\r\n                                    }\r\n\r\n                                    shape.pins = [];\r\n                                    shape.length = 0;\r\n                                    shape.bendCount = 0;\r\n                                    for (let j: number = 0; j < shape.pinCount; j++) {\r\n                                        let pinObj: any = {};\r\n                                        pinObj.pitchBend = bits.read(1) == 1;\r\n                                        if (pinObj.pitchBend) shape.bendCount++;\r\n                                        shape.length += (beforeSeven && fromBeepBox)\r\n                                            ? bits.readLegacyPartDuration() * Config.partsPerBeat / Config.rhythms[this.rhythm].stepsPerBeat\r\n                                            : bits.readPartDuration();\r\n                                        pinObj.time = shape.length;\r\n                                        if (fromBeepBox) {\r\n                                            pinObj.size = bits.read(2) * 2;\r\n                                        } else if (!isModChannel) {\r\n                                            pinObj.size = bits.read(bitsPerNoteSize);\r\n                                        }\r\n                                        else {\r\n                                            pinObj.size = bits.read(9);\r\n                                        }\r\n                                        shape.pins.push(pinObj);\r\n                                    }\r\n                                }\r\n                                recentShapes.unshift(shape);\r\n                                if (recentShapes.length > 10) recentShapes.pop(); // TODO: Use Deque?\r\n\r\n                                let note: Note;\r\n                                if (newNotes.length <= noteCount) {\r\n                                    note = new Note(0, curPart, curPart + shape.length, shape.initialSize);\r\n                                    newNotes[noteCount++] = note;\r\n                                } else {\r\n                                    note = newNotes[noteCount++];\r\n                                    note.start = curPart;\r\n                                    note.end = curPart + shape.length;\r\n                                    note.pins[0].size = shape.initialSize;\r\n                                }\r\n\r\n                                let pitch: number;\r\n                                let pitchCount: number = 0;\r\n                                const pitchBends: number[] = []; // TODO: allocate this array only once! keep separate length and iterator index. Use Deque?\r\n                                for (let j: number = 0; j < shape.pitchCount + shape.bendCount; j++) {\r\n                                    const useOldPitch: boolean = bits.read(1) == 1;\r\n                                    if (!useOldPitch) {\r\n                                        const interval: number = bits.readPitchInterval();\r\n                                        pitch = lastPitch;\r\n                                        let intervalIter: number = interval;\r\n                                        while (intervalIter > 0) {\r\n                                            pitch++;\r\n                                            while (recentPitches.indexOf(pitch) != -1) pitch++;\r\n                                            intervalIter--;\r\n                                        }\r\n                                        while (intervalIter < 0) {\r\n                                            pitch--;\r\n                                            while (recentPitches.indexOf(pitch) != -1) pitch--;\r\n                                            intervalIter++;\r\n                                        }\r\n                                    } else {\r\n                                        const pitchIndex: number = validateRange(0, recentPitches.length - 1, bits.read(recentPitchBitLength));\r\n                                        pitch = recentPitches[pitchIndex];\r\n                                        recentPitches.splice(pitchIndex, 1);\r\n                                    }\r\n\r\n                                    recentPitches.unshift(pitch);\r\n                                    if (recentPitches.length > recentPitchLength) recentPitches.pop();\r\n\r\n                                    if (j < shape.pitchCount) {\r\n                                        note.pitches[pitchCount++] = pitch;\r\n                                    } else {\r\n                                        pitchBends.push(pitch);\r\n                                    }\r\n\r\n                                    if (j == shape.pitchCount - 1) {\r\n                                        lastPitch = note.pitches[0];\r\n                                    } else {\r\n                                        lastPitch = pitch;\r\n                                    }\r\n                                }\r\n                                note.pitches.length = pitchCount;\r\n                                pitchBends.unshift(note.pitches[0]); // TODO: Use Deque?\r\n                                if (isModChannel) {\r\n                                    note.pins[0].size *= detuneScaleNotes[newPattern.instruments[0]][note.pitches[0]];\r\n                                }\r\n                                let pinCount: number = 1;\r\n                                for (const pinObj of shape.pins) {\r\n                                    if (pinObj.pitchBend) pitchBends.shift();\r\n\r\n                                    const interval: number = pitchBends[0] - note.pitches[0];\r\n                                    if (note.pins.length <= pinCount) {\r\n                                        if (isModChannel) {\r\n                                            note.pins[pinCount++] = makeNotePin(interval, pinObj.time, pinObj.size * detuneScaleNotes[newPattern.instruments[0]][note.pitches[0]]);\r\n                                        } else {\r\n                                            note.pins[pinCount++] = makeNotePin(interval, pinObj.time, pinObj.size);\r\n                                        }\r\n                                    } else {\r\n                                        const pin: NotePin = note.pins[pinCount++];\r\n                                        pin.interval = interval;\r\n                                        pin.time = pinObj.time;\r\n                                        if (isModChannel) {\r\n                                            pin.size = pinObj.size * detuneScaleNotes[newPattern.instruments[0]][note.pitches[0]];\r\n                                        } else {\r\n                                            pin.size = pinObj.size;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                note.pins.length = pinCount;\r\n\r\n                                if (note.start == 0) {\r\n                                    if (!((beforeNine && fromBeepBox) || (beforeFive && fromJummBox))) {\r\n                                        note.continuesLastPattern = (bits.read(1) == 1);\r\n                                    } else {\r\n                                        if (beforeFour || fromBeepBox) {\r\n                                            note.continuesLastPattern = false;\r\n                                        } else {\r\n                                            note.continuesLastPattern = channel.instruments[newPattern.instruments[0]].legacyTieOver;\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                curPart = validateRange(0, this.beatsPerBar * Config.partsPerBeat, note.end);\r\n                            }\r\n                        }\r\n                        newNotes.length = noteCount;\r\n                    }\r\n\r\n                    if (beforeThree && fromBeepBox) {\r\n                        break;\r\n                    } else {\r\n                        channelIndex++;\r\n                        if (channelIndex >= this.getChannelCount()) break;\r\n                    }\r\n                } // while (true)\r\n\r\n                // Correction for old JB songs that had song reverb mods. Change all instruments using reverb to max reverb\r\n                if (fromJummBox && beforeFive && songReverbIndex >= 0) {\r\n                    for (let channelIndex: number = 0; channelIndex < this.channels.length; channelIndex++) {\r\n                        for (let instrumentIndex: number = 0; instrumentIndex < this.channels[channelIndex].instruments.length; instrumentIndex++) {\r\n                            const instrument: Instrument = this.channels[channelIndex].instruments[instrumentIndex];\r\n                            if (effectsIncludeReverb(instrument.effects)) {\r\n                                instrument.reverb = Config.reverbRange - 1;\r\n                            }\r\n                            // Set song reverb via mod to the old setting at song start.\r\n                            if (songReverbChannel == channelIndex && songReverbInstrument == instrumentIndex) {\r\n                                const patternIndex: number = this.channels[channelIndex].bars[0];\r\n                                if (patternIndex > 0) {\r\n                                    // Doesn't work if 1st pattern isn't using the right ins for song reverb...\r\n                                    // Add note to start of pattern\r\n                                    const pattern: Pattern = this.channels[channelIndex].patterns[patternIndex - 1];\r\n                                    let lowestPart: number = 6;\r\n                                    for (const note of pattern.notes) {\r\n                                        if (note.pitches[0] == Config.modCount - 1 - songReverbIndex) {\r\n                                            lowestPart = Math.min(lowestPart, note.start);\r\n                                        }\r\n                                    }\r\n\r\n                                    if (lowestPart > 0) {\r\n                                        pattern.notes.push(new Note(Config.modCount - 1 - songReverbIndex, 0, lowestPart, legacyGlobalReverb));\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    // Add pattern\r\n                                    if (this.channels[channelIndex].patterns.length < Config.barCountMax) {\r\n                                        const pattern: Pattern = new Pattern();\r\n                                        this.channels[channelIndex].patterns.push(pattern);\r\n                                        this.channels[channelIndex].bars[0] = this.channels[channelIndex].patterns.length;\r\n                                        if (this.channels[channelIndex].patterns.length > this.patternsPerChannel) {\r\n                                            for (let chn: number = 0; chn < this.channels.length; chn++) {\r\n                                                if (this.channels[chn].patterns.length <= this.patternsPerChannel) {\r\n                                                    this.channels[chn].patterns.push(new Pattern());\r\n                                                }\r\n                                            }\r\n                                            this.patternsPerChannel++;\r\n                                        }\r\n                                        pattern.instruments.length = 1;\r\n                                        pattern.instruments[0] = songReverbInstrument;\r\n                                        pattern.notes.length = 0;\r\n                                        pattern.notes.push(new Note(Config.modCount - 1 - songReverbIndex, 0, 6, legacyGlobalReverb));\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } break;\r\n            default: {\r\n                throw new Error(\"Unrecognized song tag code \" + String.fromCharCode(command) + \" at index \" + (charIndex - 1));\r\n            } break;\r\n        }\r\n    }\r\n\r\n    public toJsonObject(enableIntro: boolean = true, loopCount: number = 1, enableOutro: boolean = true): Object {\r\n        const channelArray: Object[] = [];\r\n        for (let channelIndex: number = 0; channelIndex < this.getChannelCount(); channelIndex++) {\r\n            const channel: Channel = this.channels[channelIndex];\r\n            const instrumentArray: Object[] = [];\r\n            const isNoiseChannel: boolean = this.getChannelIsNoise(channelIndex);\r\n            const isModChannel: boolean = this.getChannelIsMod(channelIndex);\r\n            for (const instrument of channel.instruments) {\r\n                instrumentArray.push(instrument.toJsonObject());\r\n            }\r\n\r\n            const patternArray: Object[] = [];\r\n            for (const pattern of channel.patterns) {\r\n                patternArray.push(pattern.toJsonObject(this, channel, isModChannel));\r\n            }\r\n\r\n            const sequenceArray: number[] = [];\r\n            if (enableIntro) for (let i: number = 0; i < this.loopStart; i++) {\r\n                sequenceArray.push(channel.bars[i]);\r\n            }\r\n            for (let l: number = 0; l < loopCount; l++) for (let i: number = this.loopStart; i < this.loopStart + this.loopLength; i++) {\r\n                sequenceArray.push(channel.bars[i]);\r\n            }\r\n            if (enableOutro) for (let i: number = this.loopStart + this.loopLength; i < this.barCount; i++) {\r\n                sequenceArray.push(channel.bars[i]);\r\n            }\r\n\r\n            const channelObject: any = {\r\n                \"type\": isModChannel ? \"mod\" : (isNoiseChannel ? \"drum\" : \"pitch\"),\r\n                \"name\": channel.name,\r\n                \"instruments\": instrumentArray,\r\n                \"patterns\": patternArray,\r\n                \"sequence\": sequenceArray,\r\n            };\r\n            if (!isNoiseChannel) {\r\n                // For compatibility with old versions the octave is offset by one.\r\n                channelObject[\"octaveScrollBar\"] = channel.octave - 1;\r\n            }\r\n            channelArray.push(channelObject);\r\n        }\r\n\r\n        return {\r\n            \"name\": this.title,\r\n            \"format\": Song._format,\r\n            \"version\": Song._latestJummBoxVersion,\r\n            \"scale\": Config.scales[this.scale].name,\r\n            \"key\": Config.keys[this.key].name,\r\n            \"introBars\": this.loopStart,\r\n            \"loopBars\": this.loopLength,\r\n            \"beatsPerBar\": this.beatsPerBar,\r\n            \"ticksPerBeat\": Config.rhythms[this.rhythm].stepsPerBeat,\r\n            \"beatsPerMinute\": this.tempo,\r\n            \"reverb\": this.reverb,\r\n            \"masterGain\": this.masterGain,\r\n            \"compressionThreshold\": this.compressionThreshold,\r\n            \"limitThreshold\": this.limitThreshold,\r\n            \"limitDecay\": this.limitDecay,\r\n            \"limitRise\": this.limitRise,\r\n            \"limitRatio\": this.limitRatio,\r\n            \"compressionRatio\": this.compressionRatio,\r\n            //\"outroBars\": this.barCount - this.loopStart - this.loopLength; // derive this from bar arrays?\r\n            //\"patternCount\": this.patternsPerChannel, // derive this from pattern arrays?\r\n            \"layeredInstruments\": this.layeredInstruments,\r\n            \"patternInstruments\": this.patternInstruments,\r\n            \"channels\": channelArray,\r\n        };\r\n    }\r\n\r\n    public fromJsonObject(jsonObject: any): void {\r\n        this.initToDefault(true);\r\n        if (!jsonObject) return;\r\n\r\n        //const version: number = jsonObject[\"version\"] | 0;\r\n        //if (version > Song._latestVersion) return; // Go ahead and try to parse something from the future I guess? JSON is pretty easy-going!\r\n\r\n        if (jsonObject[\"name\"] != undefined) {\r\n            this.title = jsonObject[\"name\"];\r\n        }\r\n\r\n        this.scale = 0; // default to free.\r\n        if (jsonObject[\"scale\"] != undefined) {\r\n            const oldScaleNames: Dictionary<string> = {\r\n                \"romani :)\": \"dbl harmonic :)\",\r\n                \"romani :(\": \"dbl harmonic :(\",\r\n                \"enigma\": \"strange\",\r\n            };\r\n            const scaleName: string = (oldScaleNames[jsonObject[\"scale\"]] != undefined) ? oldScaleNames[jsonObject[\"scale\"]] : jsonObject[\"scale\"];\r\n            const scale: number = Config.scales.findIndex(scale => scale.name == scaleName);\r\n            if (scale != -1) this.scale = scale;\r\n        }\r\n\r\n        if (jsonObject[\"key\"] != undefined) {\r\n            if (typeof (jsonObject[\"key\"]) == \"number\") {\r\n                this.key = ((jsonObject[\"key\"] + 1200) >>> 0) % Config.keys.length;\r\n            } else if (typeof (jsonObject[\"key\"]) == \"string\") {\r\n                const key: string = jsonObject[\"key\"];\r\n                const letter: string = key.charAt(0).toUpperCase();\r\n                const symbol: string = key.charAt(1).toLowerCase();\r\n                const letterMap: Readonly<Dictionary<number>> = { \"C\": 0, \"D\": 2, \"E\": 4, \"F\": 5, \"G\": 7, \"A\": 9, \"B\": 11 };\r\n                const accidentalMap: Readonly<Dictionary<number>> = { \"#\": 1, \"♯\": 1, \"b\": -1, \"♭\": -1 };\r\n                let index: number | undefined = letterMap[letter];\r\n                const offset: number | undefined = accidentalMap[symbol];\r\n                if (index != undefined) {\r\n                    if (offset != undefined) index += offset;\r\n                    if (index < 0) index += 12;\r\n                    index = index % 12;\r\n                    this.key = index;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (jsonObject[\"beatsPerMinute\"] != undefined) {\r\n            this.tempo = clamp(Config.tempoMin, Config.tempoMax + 1, jsonObject[\"beatsPerMinute\"] | 0);\r\n        }\r\n\r\n        let legacyGlobalReverb: number = 0; // In older songs, reverb was song-global, record that here and pass it to Instrument.fromJsonObject() for context.\r\n        if (jsonObject[\"reverb\"] != undefined) {\r\n            legacyGlobalReverb = clamp(0, 32, jsonObject[\"reverb\"] | 0);\r\n        }\r\n\r\n        if (jsonObject[\"beatsPerBar\"] != undefined) {\r\n            this.beatsPerBar = Math.max(Config.beatsPerBarMin, Math.min(Config.beatsPerBarMax, jsonObject[\"beatsPerBar\"] | 0));\r\n        }\r\n\r\n        let importedPartsPerBeat: number = 4;\r\n        if (jsonObject[\"ticksPerBeat\"] != undefined) {\r\n            importedPartsPerBeat = (jsonObject[\"ticksPerBeat\"] | 0) || 4;\r\n            this.rhythm = Config.rhythms.findIndex(rhythm => rhythm.stepsPerBeat == importedPartsPerBeat);\r\n            if (this.rhythm == -1) {\r\n                this.rhythm = 1;\r\n            }\r\n        }\r\n\r\n        // Read limiter settings. Ranges and defaults are based on slider settings\r\n\r\n        if (jsonObject[\"masterGain\"] != undefined) {\r\n            this.masterGain = Math.max(0.0, Math.min(5.0, jsonObject[\"masterGain\"] || 0));\r\n        } else {\r\n            this.masterGain = 1.0;\r\n        }\r\n\r\n        if (jsonObject[\"limitThreshold\"] != undefined) {\r\n            this.limitThreshold = Math.max(0.0, Math.min(2.0, jsonObject[\"limitThreshold\"] || 0));\r\n        }\r\n        else {\r\n            this.limitThreshold = 1.0;\r\n        }\r\n\r\n        if (jsonObject[\"compressionThreshold\"] != undefined) {\r\n            this.compressionThreshold = Math.max(0.0, Math.min(1.1, jsonObject[\"compressionThreshold\"] || 0));\r\n        }\r\n        else {\r\n            this.compressionThreshold = 1.0;\r\n        }\r\n\r\n        if (jsonObject[\"limitRise\"] != undefined) {\r\n            this.limitRise = Math.max(2000.0, Math.min(10000.0, jsonObject[\"limitRise\"] || 0));\r\n        }\r\n        else {\r\n            this.limitRise = 4000.0;\r\n        }\r\n\r\n        if (jsonObject[\"limitDecay\"] != undefined) {\r\n            this.limitDecay = Math.max(1.0, Math.min(30.0, jsonObject[\"limitDecay\"] || 0));\r\n        }\r\n        else {\r\n            this.limitDecay = 4.0;\r\n        }\r\n\r\n        if (jsonObject[\"limitRatio\"] != undefined) {\r\n            this.limitRatio = Math.max(0.0, Math.min(11.0, jsonObject[\"limitRatio\"] || 0));\r\n        }\r\n        else {\r\n            this.limitRatio = 1.0;\r\n        }\r\n\r\n        if (jsonObject[\"compressionRatio\"] != undefined) {\r\n            this.compressionRatio = Math.max(0.0, Math.min(1.168, jsonObject[\"compressionRatio\"] || 0));\r\n        }\r\n        else {\r\n            this.compressionRatio = 1.0;\r\n        }\r\n\r\n        let maxInstruments: number = 1;\r\n        let maxPatterns: number = 1;\r\n        let maxBars: number = 1;\r\n        if (jsonObject[\"channels\"] != undefined) {\r\n            for (const channelObject of jsonObject[\"channels\"]) {\r\n                if (channelObject[\"instruments\"]) maxInstruments = Math.max(maxInstruments, channelObject[\"instruments\"].length | 0);\r\n                if (channelObject[\"patterns\"]) maxPatterns = Math.max(maxPatterns, channelObject[\"patterns\"].length | 0);\r\n                if (channelObject[\"sequence\"]) maxBars = Math.max(maxBars, channelObject[\"sequence\"].length | 0);\r\n            }\r\n        }\r\n\r\n        if (jsonObject[\"layeredInstruments\"] != undefined) {\r\n            this.layeredInstruments = !!jsonObject[\"layeredInstruments\"];\r\n        } else {\r\n            this.layeredInstruments = false;\r\n        }\r\n        if (jsonObject[\"patternInstruments\"] != undefined) {\r\n            this.patternInstruments = !!jsonObject[\"patternInstruments\"];\r\n        } else {\r\n            this.patternInstruments = (maxInstruments > 1);\r\n        }\r\n        this.patternsPerChannel = Math.min(maxPatterns, Config.barCountMax);\r\n        this.barCount = Math.min(maxBars, Config.barCountMax);\r\n\r\n        if (jsonObject[\"introBars\"] != undefined) {\r\n            this.loopStart = clamp(0, this.barCount, jsonObject[\"introBars\"] | 0);\r\n        }\r\n        if (jsonObject[\"loopBars\"] != undefined) {\r\n            this.loopLength = clamp(1, this.barCount - this.loopStart + 1, jsonObject[\"loopBars\"] | 0);\r\n        }\r\n\r\n        const newPitchChannels: Channel[] = [];\r\n        const newNoiseChannels: Channel[] = [];\r\n        const newModChannels: Channel[] = [];\r\n        if (jsonObject[\"channels\"] != undefined) {\r\n            for (let channelIndex: number = 0; channelIndex < jsonObject[\"channels\"].length; channelIndex++) {\r\n                let channelObject: any = jsonObject[\"channels\"][channelIndex];\r\n\r\n                const channel: Channel = new Channel();\r\n\r\n                let isNoiseChannel: boolean = false;\r\n                let isModChannel: boolean = false;\r\n                if (channelObject[\"type\"] != undefined) {\r\n                    isNoiseChannel = (channelObject[\"type\"] == \"drum\");\r\n                    isModChannel = (channelObject[\"type\"] == \"mod\");\r\n                } else {\r\n                    // for older files, assume drums are channel 3.\r\n                    isNoiseChannel = (channelIndex >= 3);\r\n                }\r\n                if (isNoiseChannel) {\r\n                    newNoiseChannels.push(channel);\r\n                } else if (isModChannel) {\r\n                    newModChannels.push(channel);\r\n                }\r\n                else {\r\n                    newPitchChannels.push(channel);\r\n                }\r\n\r\n                if (channelObject[\"octaveScrollBar\"] != undefined) {\r\n                    channel.octave = clamp(0, Config.pitchOctaves, (channelObject[\"octaveScrollBar\"] | 0) + 1);\r\n                    if (isNoiseChannel) channel.octave = 0;\r\n                }\r\n\r\n                if (channelObject[\"name\"] != undefined) {\r\n                    channel.name = channelObject[\"name\"];\r\n                }\r\n                else {\r\n                    channel.name = \"\";\r\n                }\r\n\r\n                if (Array.isArray(channelObject[\"instruments\"])) {\r\n                    const instrumentObjects: any[] = channelObject[\"instruments\"];\r\n                    for (let i: number = 0; i < instrumentObjects.length; i++) {\r\n                        if (i >= this.getMaxInstrumentsPerChannel()) break;\r\n                        const instrument: Instrument = new Instrument(isNoiseChannel, isModChannel);\r\n                        channel.instruments[i] = instrument;\r\n                        instrument.fromJsonObject(instrumentObjects[i], isNoiseChannel, isModChannel, false, false, legacyGlobalReverb);\r\n                    }\r\n\r\n                }\r\n\r\n                for (let i: number = 0; i < this.patternsPerChannel; i++) {\r\n                    const pattern: Pattern = new Pattern();\r\n                    channel.patterns[i] = pattern;\r\n\r\n                    let patternObject: any = undefined;\r\n                    if (channelObject[\"patterns\"]) patternObject = channelObject[\"patterns\"][i];\r\n                    if (patternObject == undefined) continue;\r\n\r\n                    pattern.fromJsonObject(patternObject, this, channel, importedPartsPerBeat, isNoiseChannel, isModChannel);\r\n                }\r\n                channel.patterns.length = this.patternsPerChannel;\r\n\r\n                for (let i: number = 0; i < this.barCount; i++) {\r\n                    channel.bars[i] = (channelObject[\"sequence\"] != undefined) ? Math.min(this.patternsPerChannel, channelObject[\"sequence\"][i] >>> 0) : 0;\r\n                }\r\n                channel.bars.length = this.barCount;\r\n            }\r\n        }\r\n\r\n        if (newPitchChannels.length > Config.pitchChannelCountMax) newPitchChannels.length = Config.pitchChannelCountMax;\r\n        if (newNoiseChannels.length > Config.noiseChannelCountMax) newNoiseChannels.length = Config.noiseChannelCountMax;\r\n        if (newModChannels.length > Config.modChannelCountMax) newModChannels.length = Config.modChannelCountMax;\r\n        this.pitchChannelCount = newPitchChannels.length;\r\n        this.noiseChannelCount = newNoiseChannels.length;\r\n        this.modChannelCount = newModChannels.length;\r\n        this.channels.length = 0;\r\n        Array.prototype.push.apply(this.channels, newPitchChannels);\r\n        Array.prototype.push.apply(this.channels, newNoiseChannels);\r\n        Array.prototype.push.apply(this.channels, newModChannels);\r\n    }\r\n\r\n    public getPattern(channelIndex: number, bar: number): Pattern | null {\r\n        if (bar < 0 || bar >= this.barCount) return null;\r\n        const patternIndex: number = this.channels[channelIndex].bars[bar];\r\n        if (patternIndex == 0) return null;\r\n        return this.channels[channelIndex].patterns[patternIndex - 1];\r\n    }\r\n\r\n    public getBeatsPerMinute(): number {\r\n        return this.tempo;\r\n    }\r\n\r\n    public static getNeededBits(maxValue: number): number {\r\n        return 32 - Math.clz32(Math.ceil(maxValue + 1) - 1);\r\n    }\r\n\r\n    public restoreLimiterDefaults(): void {\r\n        this.compressionRatio = 1.0;\r\n        this.limitRatio = 1.0;\r\n        this.limitRise = 4000.0;\r\n        this.limitDecay = 4.0;\r\n        this.limitThreshold = 1.0;\r\n        this.compressionThreshold = 1.0;\r\n        this.masterGain = 1.0;\r\n    }\r\n}\r\n\r\nclass PickedString {\r\n    public delayLine: Float32Array | null = null;\r\n    public delayIndex: number;\r\n    public allPassSample: number;\r\n    public allPassPrevInput: number;\r\n    public shelfSample: number;\r\n    public shelfPrevInput: number;\r\n    public fractionalDelaySample: number;\r\n    public prevDelayLength: number;\r\n    public delayLengthDelta: number;\r\n    public delayResetOffset: number;\r\n\r\n    public allPassG: number = 0.0;\r\n    public allPassGDelta: number = 0.0;\r\n    public shelfA1: number = 0.0;\r\n    public shelfA1Delta: number = 0.0;\r\n    public shelfB0: number = 0.0;\r\n    public shelfB0Delta: number = 0.0;\r\n    public shelfB1: number = 0.0;\r\n    public shelfB1Delta: number = 0.0;\r\n\r\n    constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.delayIndex = -1;\r\n        this.allPassSample = 0.0;\r\n        this.allPassPrevInput = 0.0;\r\n        this.shelfSample = 0.0;\r\n        this.shelfPrevInput = 0.0;\r\n        this.fractionalDelaySample = 0.0;\r\n        this.prevDelayLength = -1.0;\r\n        this.delayResetOffset = 0;\r\n    }\r\n\r\n    public update(synth: Synth, instrumentState: InstrumentState, tone: Tone, stringIndex: number, roundedSamplesPerTick: number, stringDecayStart: number, stringDecayEnd: number): void {\r\n        const allPassCenter: number = 2.0 * Math.PI * Config.pickedStringDispersionCenterFreq / synth.samplesPerSecond;\r\n        const shelfRadians: number = 2.0 * Math.PI * Config.pickedStringShelfHz / synth.samplesPerSecond;\r\n        const decayCurveStart: number = (Math.pow(100.0, stringDecayStart) - 1.0) / 99.0;\r\n        const decayCurveEnd: number = (Math.pow(100.0, stringDecayEnd) - 1.0) / 99.0;\r\n\r\n        const prevDelayLength: number = this.prevDelayLength;\r\n\r\n        const phaseDeltaStart: number = tone.phaseDeltas[stringIndex];\r\n        const phaseDeltaScale: number = tone.phaseDeltaScales[stringIndex];\r\n        const phaseDeltaEnd: number = phaseDeltaStart * Math.pow(phaseDeltaScale, roundedSamplesPerTick);\r\n\r\n        const radiansPerSampleStart: number = Math.PI * 2.0 * phaseDeltaStart;\r\n        const radiansPerSampleEnd: number = Math.PI * 2.0 * phaseDeltaEnd;\r\n\r\n        const centerHarmonicStart: number = radiansPerSampleStart * 2.0;\r\n        const centerHarmonicEnd: number = radiansPerSampleEnd * 2.0;\r\n\r\n        const allPassRadiansStart: number = Math.min(Math.PI, radiansPerSampleStart * Config.pickedStringDispersionFreqMult * Math.pow(allPassCenter / radiansPerSampleStart, Config.pickedStringDispersionFreqScale));\r\n        const allPassRadiansEnd: number = Math.min(Math.PI, radiansPerSampleEnd * Config.pickedStringDispersionFreqMult * Math.pow(allPassCenter / radiansPerSampleEnd, Config.pickedStringDispersionFreqScale));\r\n\r\n        const decayRateStart: number = Math.pow(0.5, decayCurveStart * shelfRadians / radiansPerSampleStart);\r\n        const decayRateEnd: number = Math.pow(0.5, decayCurveEnd * shelfRadians / radiansPerSampleEnd);\r\n        const shelfGainStart: number = Math.pow(decayRateStart, Config.stringDecayRate);\r\n        const shelfGainEnd: number = Math.pow(decayRateEnd, Config.stringDecayRate);\r\n        const expressionDecayStart: number = Math.pow(decayRateStart, 0.002);\r\n        const expressionDecayEnd: number = Math.pow(decayRateEnd, 0.002);\r\n\r\n        Synth.tempFilterStartCoefficients.allPass1stOrderInvertPhaseAbove(allPassRadiansStart);\r\n        synth.tempFrequencyResponse.analyze(Synth.tempFilterStartCoefficients, centerHarmonicStart);\r\n        const allPassGStart: number = Synth.tempFilterStartCoefficients.b[0]; /* same as a[1] */\r\n        const allPassPhaseDelayStart: number = -synth.tempFrequencyResponse.angle() / centerHarmonicStart;\r\n\r\n        Synth.tempFilterEndCoefficients.allPass1stOrderInvertPhaseAbove(allPassRadiansEnd);\r\n        synth.tempFrequencyResponse.analyze(Synth.tempFilterEndCoefficients, centerHarmonicEnd);\r\n        const allPassGEnd: number = Synth.tempFilterEndCoefficients.b[0]; /* same as a[1] */\r\n        const allPassPhaseDelayEnd: number = -synth.tempFrequencyResponse.angle() / centerHarmonicEnd;\r\n\r\n        Synth.tempFilterStartCoefficients.highShelf1stOrder(shelfRadians, shelfGainStart);\r\n        synth.tempFrequencyResponse.analyze(Synth.tempFilterStartCoefficients, centerHarmonicStart);\r\n        const shelfA1Start: number = Synth.tempFilterStartCoefficients.a[1];\r\n        const shelfB0Start: number = Synth.tempFilterStartCoefficients.b[0] * expressionDecayStart;\r\n        const shelfB1Start: number = Synth.tempFilterStartCoefficients.b[1] * expressionDecayStart;\r\n        const shelfPhaseDelayStart: number = -synth.tempFrequencyResponse.angle() / centerHarmonicStart;\r\n\r\n        Synth.tempFilterEndCoefficients.highShelf1stOrder(shelfRadians, shelfGainEnd);\r\n        synth.tempFrequencyResponse.analyze(Synth.tempFilterEndCoefficients, centerHarmonicEnd);\r\n        const shelfA1End: number = Synth.tempFilterEndCoefficients.a[1];\r\n        const shelfB0End: number = Synth.tempFilterEndCoefficients.b[0] * expressionDecayEnd;\r\n        const shelfB1End: number = Synth.tempFilterEndCoefficients.b[1] * expressionDecayEnd;\r\n        const shelfPhaseDelayEnd: number = -synth.tempFrequencyResponse.angle() / centerHarmonicEnd;\r\n\r\n        const periodLengthStart: number = 1.0 / phaseDeltaStart;\r\n        const periodLengthEnd: number = 1.0 / phaseDeltaEnd;\r\n        const minBufferLength: number = Math.ceil(Math.max(periodLengthStart, periodLengthEnd) * 2);\r\n        const delayLength: number = periodLengthStart - allPassPhaseDelayStart - shelfPhaseDelayStart;\r\n        const delayLengthEnd: number = periodLengthEnd - allPassPhaseDelayEnd - shelfPhaseDelayEnd;\r\n\r\n        this.prevDelayLength = delayLength;\r\n        this.delayLengthDelta = (delayLengthEnd - delayLength) / roundedSamplesPerTick;\r\n        this.allPassG = allPassGStart;\r\n        this.shelfA1 = shelfA1Start;\r\n        this.shelfB0 = shelfB0Start;\r\n        this.shelfB1 = shelfB1Start;\r\n        this.allPassGDelta = (allPassGEnd - allPassGStart) / roundedSamplesPerTick;\r\n        this.shelfA1Delta = (shelfA1End - shelfA1Start) / roundedSamplesPerTick;\r\n        this.shelfB0Delta = (shelfB0End - shelfB0Start) / roundedSamplesPerTick;\r\n        this.shelfB1Delta = (shelfB1End - shelfB1Start) / roundedSamplesPerTick;\r\n\r\n        const pitchChanged: boolean = Math.abs(Math.log2(delayLength / prevDelayLength)) > 0.01;\r\n\r\n        const reinitializeImpulse: boolean = (this.delayIndex == -1 || pitchChanged);\r\n        if (this.delayLine == null || this.delayLine.length <= minBufferLength) {\r\n            // The delay line buffer will get reused for other tones so might as well\r\n            // start off with a buffer size that is big enough for most notes.\r\n            const likelyMaximumLength: number = Math.ceil(2 * synth.samplesPerSecond / Instrument.frequencyFromPitch(12));\r\n            const newDelayLine: Float32Array = new Float32Array(Synth.fittingPowerOfTwo(Math.max(likelyMaximumLength, minBufferLength)));\r\n            if (!reinitializeImpulse && this.delayLine != null) {\r\n                // If the tone has already started but the buffer needs to be reallocated,\r\n                // transfer the old data to the new buffer.\r\n                const oldDelayBufferMask: number = (this.delayLine.length - 1) >> 0;\r\n                const startCopyingFromIndex: number = this.delayIndex + this.delayResetOffset;\r\n                this.delayIndex = this.delayLine.length - this.delayResetOffset;\r\n                for (let i: number = 0; i < this.delayLine.length; i++) {\r\n                    newDelayLine[i] = this.delayLine[(startCopyingFromIndex + i) & oldDelayBufferMask];\r\n                }\r\n            }\r\n            this.delayLine = newDelayLine;\r\n        }\r\n        const delayLine: Float32Array = this.delayLine;\r\n        const delayBufferMask: number = (delayLine.length - 1) >> 0;\r\n\r\n        if (reinitializeImpulse) {\r\n            // -1 delay index means the tone was reset.\r\n            // Also, if the pitch changed suddenly (e.g. from seamless or arpeggio) then reset the wave.\r\n\r\n            this.delayIndex = 0;\r\n            this.allPassSample = 0.0;\r\n            this.allPassPrevInput = 0.0;\r\n            this.shelfSample = 0.0;\r\n            this.shelfPrevInput = 0.0;\r\n            this.fractionalDelaySample = 0.0;\r\n\r\n            // Clear away a region of the delay buffer for the new impulse.\r\n            const startImpulseFrom: number = -delayLength;\r\n            const startZerosFrom: number = Math.floor(startImpulseFrom - periodLengthStart / 2);\r\n            const stopZerosAt: number = Math.ceil(startZerosFrom + periodLengthStart * 2);\r\n            this.delayResetOffset = stopZerosAt; // And continue clearing the area in front of the delay line.\r\n            for (let i: number = startZerosFrom; i <= stopZerosAt; i++) {\r\n                delayLine[i & delayBufferMask] = 0.0;\r\n            }\r\n\r\n            const impulseWave: Float32Array = instrumentState.wave!;\r\n            const impulseWaveLength: number = impulseWave.length - 1; // The first sample is duplicated at the end, don't double-count it.\r\n            const impulsePhaseDelta: number = impulseWaveLength / periodLengthStart;\r\n\r\n            const fadeDuration: number = Math.min(periodLengthStart * 0.2, synth.samplesPerSecond * 0.003);\r\n            const startImpulseFromSample: number = Math.ceil(startImpulseFrom);\r\n            const stopImpulseAt: number = startImpulseFrom + periodLengthStart + fadeDuration;\r\n            const stopImpulseAtSample: number = stopImpulseAt;\r\n            let impulsePhase: number = (startImpulseFromSample - startImpulseFrom) * impulsePhaseDelta;\r\n            let prevWaveIntegral: number = 0.0;\r\n            for (let i: number = startImpulseFromSample; i <= stopImpulseAtSample; i++) {\r\n                const impulsePhaseInt: number = impulsePhase | 0;\r\n                const index: number = impulsePhaseInt % impulseWaveLength;\r\n                let nextWaveIntegral: number = impulseWave[index];\r\n                const phaseRatio: number = impulsePhase - impulsePhaseInt;\r\n                nextWaveIntegral += (impulseWave[index + 1] - nextWaveIntegral) * phaseRatio;\r\n                const sample: number = (nextWaveIntegral - prevWaveIntegral) / impulsePhaseDelta;\r\n                const fadeIn: number = Math.min(1.0, (i - startImpulseFrom) / fadeDuration);\r\n                const fadeOut: number = Math.min(1.0, (stopImpulseAt - i) / fadeDuration);\r\n                const combinedFade: number = fadeIn * fadeOut;\r\n                const curvedFade: number = combinedFade * combinedFade * (3.0 - 2.0 * combinedFade); // A cubic sigmoid from 0 to 1.\r\n                delayLine[i & delayBufferMask] += sample * curvedFade;\r\n                prevWaveIntegral = nextWaveIntegral;\r\n                impulsePhase += impulsePhaseDelta;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass EnvelopeComputer {\r\n    public noteSecondsStart: number = 0.0;\r\n    public noteSecondsEnd: number = 0.0;\r\n    public noteTicksStart: number = 0.0;\r\n    public noteTicksEnd: number = 0.0;\r\n    public noteSizeStart: number = Config.noteSizeMax;\r\n    public noteSizeEnd: number = Config.noteSizeMax;\r\n    public prevNoteSize: number = Config.noteSizeMax;\r\n    public nextNoteSize: number = Config.noteSizeMax;\r\n    private _noteSizeFinal: number = Config.noteSizeMax;\r\n    public prevNoteSecondsStart: number = 0.0;\r\n    public prevNoteSecondsEnd: number = 0.0;\r\n    public prevNoteTicksStart: number = 0.0;\r\n    public prevNoteTicksEnd: number = 0.0;\r\n    private _prevNoteSizeFinal: number = Config.noteSizeMax;\r\n\r\n    public prevSlideStart: boolean = false;\r\n    public prevSlideEnd: boolean = false;\r\n    public nextSlideStart: boolean = false;\r\n    public nextSlideEnd: boolean = false;\r\n    public prevSlideRatioStart: number = 0.0;\r\n    public prevSlideRatioEnd: number = 0.0;\r\n    public nextSlideRatioStart: number = 0.0;\r\n    public nextSlideRatioEnd: number = 0.0;\r\n\r\n    public readonly envelopeStarts: number[] = [];\r\n    public readonly envelopeEnds: number[] = [];\r\n    private readonly _modifiedEnvelopeIndices: number[] = [];\r\n    private _modifiedEnvelopeCount: number = 0;\r\n    public lowpassCutoffDecayVolumeCompensation: number = 1.0;\r\n\r\n    constructor(/*private _perNote: boolean*/) {\r\n        //const length: number = this._perNote ? EnvelopeComputeIndex.length : InstrumentAutomationIndex.length;\r\n        const length: number = EnvelopeComputeIndex.length;\r\n        for (let i: number = 0; i < length; i++) {\r\n            this.envelopeStarts[i] = 1.0;\r\n            this.envelopeEnds[i] = 1.0;\r\n        }\r\n\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.noteSecondsEnd = 0.0;\r\n        this.noteTicksEnd = 0.0;\r\n        this._noteSizeFinal = Config.noteSizeMax;\r\n        this.prevNoteSecondsEnd = 0.0;\r\n        this.prevNoteTicksEnd = 0.0;\r\n        this._prevNoteSizeFinal = Config.noteSizeMax;\r\n        this._modifiedEnvelopeCount = 0;\r\n    }\r\n\r\n    public computeEnvelopes(instrument: Instrument, currentPart: number, tickTimeStart: number, secondsPerTick: number, tone: Tone | null): void {\r\n        const transition: Transition = instrument.getTransition();\r\n        if (tone != null && tone.atNoteStart && !transition.continues && !tone.forceContinueAtStart) {\r\n            this.prevNoteSecondsEnd = this.noteSecondsEnd;\r\n            this.prevNoteTicksEnd = this.noteTicksEnd;\r\n            this._prevNoteSizeFinal = this._noteSizeFinal;\r\n            this.noteSecondsEnd = 0.0;\r\n            this.noteTicksEnd = 0.0;\r\n        }\r\n        if (tone != null) {\r\n            if (tone.note != null) {\r\n                this._noteSizeFinal = tone.note.pins[tone.note.pins.length - 1].size;\r\n            } else {\r\n                this._noteSizeFinal = Config.noteSizeMax;\r\n            }\r\n        }\r\n\r\n        const tickTimeEnd: number = tickTimeStart + 1.0;\r\n        const noteSecondsStart: number = this.noteSecondsEnd;\r\n        const noteSecondsEnd: number = noteSecondsStart + secondsPerTick;\r\n        const noteTicksStart: number = this.noteTicksEnd;\r\n        const noteTicksEnd: number = noteTicksStart + 1.0;\r\n        const prevNoteSecondsStart: number = this.prevNoteSecondsEnd;\r\n        const prevNoteSecondsEnd: number = prevNoteSecondsStart + secondsPerTick;\r\n        const prevNoteTicksStart: number = this.prevNoteTicksEnd;\r\n        const prevNoteTicksEnd: number = prevNoteTicksStart + 1.0;\r\n\r\n        const beatsPerTick: number = 1.0 / (Config.ticksPerPart * Config.partsPerBeat);\r\n        const beatTimeStart: number = beatsPerTick * tickTimeStart;\r\n        const beatTimeEnd: number = beatsPerTick * tickTimeEnd;\r\n\r\n        let noteSizeStart: number = this._noteSizeFinal;\r\n        let noteSizeEnd: number = this._noteSizeFinal;\r\n        let prevNoteSize: number = this._prevNoteSizeFinal;\r\n        let nextNoteSize: number = 0;\r\n        let prevSlideStart: boolean = false;\r\n        let prevSlideEnd: boolean = false;\r\n        let nextSlideStart: boolean = false;\r\n        let nextSlideEnd: boolean = false;\r\n        let prevSlideRatioStart: number = 0.0;\r\n        let prevSlideRatioEnd: number = 0.0;\r\n        let nextSlideRatioStart: number = 0.0;\r\n        let nextSlideRatioEnd: number = 0.0;\r\n        if (tone != null && tone.note != null && !tone.passedEndOfNote) {\r\n            const endPinIndex: number = tone.note.getEndPinIndex(currentPart);\r\n            const startPin: NotePin = tone.note.pins[endPinIndex - 1];\r\n            const endPin: NotePin = tone.note.pins[endPinIndex];\r\n            const startPinTick: number = (tone.note.start + startPin.time) * Config.ticksPerPart;\r\n            const endPinTick: number = (tone.note.start + endPin.time) * Config.ticksPerPart;\r\n            const ratioStart: number = (tickTimeStart - startPinTick) / (endPinTick - startPinTick);\r\n            const ratioEnd: number = (tickTimeEnd - startPinTick) / (endPinTick - startPinTick);\r\n            noteSizeStart = startPin.size + (endPin.size - startPin.size) * ratioStart;\r\n            noteSizeEnd = startPin.size + (endPin.size - startPin.size) * ratioEnd;\r\n\r\n            if (transition.slides) {\r\n                const noteStartTick: number = tone.noteStartPart * Config.ticksPerPart;\r\n                const noteEndTick: number = tone.noteEndPart * Config.ticksPerPart;\r\n                const noteLengthTicks: number = noteEndTick - noteStartTick;\r\n                const maximumSlideTicks: number = noteLengthTicks * 0.5;\r\n                const slideTicks: number = Math.min(maximumSlideTicks, transition.slideTicks);\r\n                if (tone.prevNote != null && !tone.forceContinueAtStart) {\r\n                    if (tickTimeStart - noteStartTick < slideTicks) {\r\n                        prevSlideStart = true;\r\n                        prevSlideRatioStart = 0.5 * (1.0 - (tickTimeStart - noteStartTick) / slideTicks);\r\n                    }\r\n                    if (tickTimeEnd - noteStartTick < slideTicks) {\r\n                        prevSlideEnd = true;\r\n                        prevSlideRatioEnd = 0.5 * (1.0 - (tickTimeEnd - noteStartTick) / slideTicks);\r\n                    }\r\n                }\r\n                if (tone.nextNote != null && !tone.forceContinueAtEnd) {\r\n                    nextNoteSize = tone.nextNote.pins[0].size\r\n                    if (noteEndTick - tickTimeStart < slideTicks) {\r\n                        nextSlideStart = true;\r\n                        nextSlideRatioStart = 0.5 * (1.0 - (noteEndTick - tickTimeStart) / slideTicks);\r\n                    }\r\n                    if (noteEndTick - tickTimeEnd < slideTicks) {\r\n                        nextSlideEnd = true;\r\n                        nextSlideRatioEnd = 0.5 * (1.0 - (noteEndTick - tickTimeEnd) / slideTicks);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        let lowpassCutoffDecayVolumeCompensation: number = 1.0;\r\n        let usedNoteSize: boolean = false;\r\n        for (let envelopeIndex: number = 0; envelopeIndex <= instrument.envelopeCount; envelopeIndex++) {\r\n            let automationTarget: AutomationTarget;\r\n            let targetIndex: number;\r\n            let envelope: Envelope;\r\n            if (envelopeIndex == instrument.envelopeCount) {\r\n                if (usedNoteSize /*|| !this._perNote*/) break;\r\n                // Special case: if no other envelopes used note size, default to applying it to note volume.\r\n                automationTarget = Config.instrumentAutomationTargets.dictionary[\"noteVolume\"];\r\n                targetIndex = 0;\r\n                envelope = Config.envelopes.dictionary[\"note size\"];\r\n            } else {\r\n                let envelopeSettings: EnvelopeSettings = instrument.envelopes[envelopeIndex];\r\n                automationTarget = Config.instrumentAutomationTargets[envelopeSettings.target];\r\n                targetIndex = envelopeSettings.index;\r\n                envelope = Config.envelopes[envelopeSettings.envelope];\r\n                if (envelope.type == EnvelopeType.noteSize) usedNoteSize = true;\r\n            }\r\n            if (/*automationTarget.perNote == this._perNote &&*/ automationTarget.computeIndex != null) {\r\n                const computeIndex: number = automationTarget.computeIndex + targetIndex;\r\n                let envelopeStart: number = EnvelopeComputer.computeEnvelope(envelope, noteSecondsStart, beatTimeStart, noteSizeStart);\r\n                let envelopeEnd: number = EnvelopeComputer.computeEnvelope(envelope, noteSecondsEnd, beatTimeEnd, noteSizeEnd);\r\n\r\n                if (prevSlideStart) {\r\n                    const other: number = EnvelopeComputer.computeEnvelope(envelope, prevNoteSecondsStart, beatTimeStart, prevNoteSize);\r\n                    envelopeStart += (other - envelopeStart) * prevSlideRatioStart;\r\n                }\r\n                if (prevSlideEnd) {\r\n                    const other: number = EnvelopeComputer.computeEnvelope(envelope, prevNoteSecondsEnd, beatTimeEnd, prevNoteSize);\r\n                    envelopeEnd += (other - envelopeEnd) * prevSlideRatioEnd;\r\n                }\r\n                if (nextSlideStart) {\r\n                    const other: number = EnvelopeComputer.computeEnvelope(envelope, 0.0, beatTimeStart, nextNoteSize);\r\n                    envelopeStart += (other - envelopeStart) * nextSlideRatioStart;\r\n                }\r\n                if (nextSlideEnd) {\r\n                    const other: number = EnvelopeComputer.computeEnvelope(envelope, 0.0, beatTimeEnd, nextNoteSize);\r\n                    envelopeEnd += (other - envelopeEnd) * nextSlideRatioEnd;\r\n                }\r\n\r\n                this.envelopeStarts[computeIndex] *= envelopeStart;\r\n                this.envelopeEnds[computeIndex] *= envelopeEnd;\r\n                this._modifiedEnvelopeIndices[this._modifiedEnvelopeCount++] = computeIndex;\r\n\r\n                if (automationTarget.isFilter) {\r\n                    const filterSettings: FilterSettings = /*this._perNote ?*/ (instrument.tmpNoteFilterStart != null) ? instrument.tmpNoteFilterStart : instrument.noteFilter /*: instrument.eqFilter*/;\r\n                    if (filterSettings.controlPointCount > targetIndex && filterSettings.controlPoints[targetIndex].type == FilterType.lowPass) {\r\n                        lowpassCutoffDecayVolumeCompensation = Math.max(lowpassCutoffDecayVolumeCompensation, EnvelopeComputer.getLowpassCutoffDecayVolumeCompensation(envelope));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.noteSecondsStart = noteSecondsStart;\r\n        this.noteSecondsEnd = noteSecondsEnd;\r\n        this.noteTicksStart = noteTicksStart;\r\n        this.noteTicksEnd = noteTicksEnd;\r\n        this.prevNoteSecondsStart = prevNoteSecondsStart;\r\n        this.prevNoteSecondsEnd = prevNoteSecondsEnd;\r\n        this.prevNoteTicksStart = prevNoteTicksStart;\r\n        this.prevNoteTicksEnd = prevNoteTicksEnd;\r\n        this.prevNoteSize = prevNoteSize;\r\n        this.nextNoteSize = nextNoteSize;\r\n        this.noteSizeStart = noteSizeStart;\r\n        this.noteSizeEnd = noteSizeEnd;\r\n        this.prevSlideStart = prevSlideStart;\r\n        this.prevSlideEnd = prevSlideEnd;\r\n        this.nextSlideStart = nextSlideStart;\r\n        this.nextSlideEnd = nextSlideEnd;\r\n        this.prevSlideRatioStart = prevSlideRatioStart;\r\n        this.prevSlideRatioEnd = prevSlideRatioEnd;\r\n        this.nextSlideRatioStart = nextSlideRatioStart;\r\n        this.nextSlideRatioEnd = nextSlideRatioEnd;\r\n        this.lowpassCutoffDecayVolumeCompensation = lowpassCutoffDecayVolumeCompensation;\r\n    }\r\n\r\n    public clearEnvelopes(): void {\r\n        for (let envelopeIndex: number = 0; envelopeIndex < this._modifiedEnvelopeCount; envelopeIndex++) {\r\n            const computeIndex: number = this._modifiedEnvelopeIndices[envelopeIndex];\r\n            this.envelopeStarts[computeIndex] = 1.0;\r\n            this.envelopeEnds[computeIndex] = 1.0;\r\n        }\r\n        this._modifiedEnvelopeCount = 0;\r\n    }\r\n\r\n    public static computeEnvelope(envelope: Envelope, time: number, beats: number, noteSize: number): number {\r\n        switch (envelope.type) {\r\n            case EnvelopeType.noteSize: return Synth.noteSizeToVolumeMult(noteSize);\r\n            case EnvelopeType.none: return 1.0;\r\n            case EnvelopeType.twang: return 1.0 / (1.0 + time * envelope.speed);\r\n            case EnvelopeType.swell: return 1.0 - 1.0 / (1.0 + time * envelope.speed);\r\n            case EnvelopeType.tremolo: return 0.5 - Math.cos(beats * 2.0 * Math.PI * envelope.speed) * 0.5;\r\n            case EnvelopeType.tremolo2: return 0.75 - Math.cos(beats * 2.0 * Math.PI * envelope.speed) * 0.25;\r\n            case EnvelopeType.punch: return Math.max(1.0, 2.0 - time * 10.0);\r\n            case EnvelopeType.flare: const attack: number = 0.25 / Math.sqrt(envelope.speed); return time < attack ? time / attack : 1.0 / (1.0 + (time - attack) * envelope.speed);\r\n            case EnvelopeType.decay: return Math.pow(2, -envelope.speed * time);\r\n            default: throw new Error(\"Unrecognized operator envelope type.\");\r\n        }\r\n\r\n    }\r\n\r\n    public static getLowpassCutoffDecayVolumeCompensation(envelope: Envelope): number {\r\n        // This is a little hokey in the details, but I designed it a while ago and keep it\r\n        // around for compatibility. This decides how much to increase the volume (or\r\n        // expression) to compensate for a decaying lowpass cutoff to maintain perceived\r\n        // volume overall.\r\n        if (envelope.type == EnvelopeType.decay) return 1.25 + 0.025 * envelope.speed;\r\n        if (envelope.type == EnvelopeType.twang) return 1.0 + 0.02 * envelope.speed;\r\n        return 1.0;\r\n    }\r\n}\r\n\r\nclass Tone {\r\n    public instrumentIndex: number;\r\n    public readonly pitches: number[] = Array(Config.maxChordSize).fill(0);\r\n    public pitchCount: number = 0;\r\n    public chordSize: number = 0;\r\n    public drumsetPitch: number | null = null;\r\n    public note: Note | null = null;\r\n    public prevNote: Note | null = null;\r\n    public nextNote: Note | null = null;\r\n    public prevNotePitchIndex: number = 0;\r\n    public nextNotePitchIndex: number = 0;\r\n    public freshlyAllocated: boolean = true;\r\n    public atNoteStart: boolean = false;\r\n    public isOnLastTick: boolean = false; // Whether the tone is finished fading out and ready to be freed.\r\n    public passedEndOfNote: boolean = false;\r\n    public forceContinueAtStart: boolean = false;\r\n    public forceContinueAtEnd: boolean = false;\r\n    public noteStartPart: number = 0;\r\n    public noteEndPart: number = 0;\r\n    public ticksSinceReleased: number = 0;\r\n    public liveInputSamplesHeld: number = 0;\r\n    public lastInterval: number = 0;\r\n    public noiseSample: number = 0.0;\r\n    public stringSustainStart: number = 0;\r\n    public stringSustainEnd: number = 0;\r\n    public readonly phases: number[] = [];\r\n    public readonly operatorWaves: OperatorWave[] = [];\r\n    public readonly phaseDeltas: number[] = [];\r\n    public readonly phaseDeltaScales: number[] = [];\r\n    public expression: number = 0.0;\r\n    public expressionDelta: number = 0.0;\r\n    public readonly operatorExpressions: number[] = [];\r\n    public readonly operatorExpressionDeltas: number[] = [];\r\n    public readonly prevPitchExpressions: Array<number | null> = Array(Config.maxPitchOrOperatorCount).fill(null);\r\n    public prevVibrato: number | null = null;\r\n    public prevStringDecay: number | null = null;\r\n    public pulseWidth: number = 0.0;\r\n    public pulseWidthDelta: number = 0.0;\r\n    public readonly pickedStrings: PickedString[] = [];\r\n\r\n    public readonly noteFilters: DynamicBiquadFilter[] = [];\r\n    public noteFilterCount: number = 0;\r\n    public initialNoteFilterInput1: number = 0.0;\r\n    public initialNoteFilterInput2: number = 0.0;\r\n\r\n    public specialIntervalExpressionMult: number = 1.0;\r\n    public readonly feedbackOutputs: number[] = [];\r\n    public feedbackMult: number = 0.0;\r\n    public feedbackDelta: number = 0.0;\r\n    public stereoVolumeLStart: number = 0.0;\r\n    public stereoVolumeRStart: number = 0.0;\r\n    public stereoVolumeLDelta: number = 0.0;\r\n    public stereoVolumeRDelta: number = 0.0;\r\n    public stereoDelayStart: number = 0.0;\r\n    public stereoDelayEnd: number = 0.0;\r\n    public stereoDelayDelta: number = 0.0;\r\n    public customVolumeStart: number = 0.0;\r\n    public customVolumeEnd: number = 0.0;\r\n    public filterResonanceStart: number = 0.0;\r\n    public filterResonanceDelta: number = 0.0;\r\n    public isFirstOrder: boolean = false;\r\n\r\n    public readonly envelopeComputer: EnvelopeComputer = new EnvelopeComputer(/*true*/);\r\n\r\n    constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.noiseSample = 0.0;\r\n        for (let i: number = 0; i < Config.maxPitchOrOperatorCount; i++) {\r\n            this.phases[i] = 0.0;\r\n            this.operatorWaves[i] = Config.operatorWaves[0];\r\n            this.feedbackOutputs[i] = 0.0;\r\n            this.prevPitchExpressions[i] = null;\r\n        }\r\n        for (let i: number = 0; i < this.noteFilterCount; i++) {\r\n            this.noteFilters[i].resetOutput();\r\n        }\r\n        this.noteFilterCount = 0;\r\n        this.initialNoteFilterInput1 = 0.0;\r\n        this.initialNoteFilterInput2 = 0.0;\r\n        this.liveInputSamplesHeld = 0;\r\n        for (const pickedString of this.pickedStrings) {\r\n            pickedString.reset();\r\n        }\r\n        this.envelopeComputer.reset();\r\n        this.prevVibrato = null;\r\n        this.prevStringDecay = null;\r\n        this.drumsetPitch = null;\r\n    }\r\n}\r\n\r\nclass InstrumentState {\r\n    public instrument: Instrument;\r\n\r\n    public awake: boolean = false; // Whether the instrument's effects-processing loop should continue.\r\n    public computed: boolean = false; // Whether the effects-processing parameters are up-to-date for the current synth run.\r\n    public tonesAddedInThisTick: boolean = false; // Whether any instrument tones are currently active.\r\n    public flushingDelayLines: boolean = false; // If no tones were active recently, enter a mode where the delay lines are filled with zeros to reset them for later use.\r\n    public deactivateAfterThisTick: boolean = false; // Whether the instrument is ready to be deactivated because the delay lines, if any, are fully zeroed.\r\n    public attentuationProgress: number = 0.0; // How long since an active tone introduced an input signal to the delay lines, normalized from 0 to 1 based on how long to wait until the delay lines signal will have audibly dissapated.\r\n    public flushedSamples: number = 0; // How many delay line samples have been flushed to zero.\r\n    public readonly activeTones: Deque<Tone> = new Deque<Tone>();\r\n    public readonly activeModTones: Deque<Tone> = new Deque<Tone>();\r\n    public readonly releasedTones: Deque<Tone> = new Deque<Tone>(); // Tones that are in the process of fading out after the corresponding notes ended.\r\n    public readonly liveInputTones: Deque<Tone> = new Deque<Tone>(); // Tones that are initiated by a source external to the loaded song data.\r\n\r\n    public type: InstrumentType = InstrumentType.chip;\r\n    public synthesizer: Function | null = null;\r\n    public wave: Float32Array | null = null;\r\n    public noisePitchFilterMult: number = 1.0;\r\n    public unison: Unison | null = null;\r\n    public chord: Chord | null = null;\r\n    public effects: number = 0;\r\n\r\n    public volumeScale: number = 0;\r\n    public aliases: boolean = false;\r\n\r\n    public eqFilterVolume: number = 1.0;\r\n    public eqFilterVolumeDelta: number = 0.0;\r\n    public mixVolume: number = 1.0;\r\n    public mixVolumeDelta: number = 0.0;\r\n    public delayInputMult: number = 0.0;\r\n    public delayInputMultDelta: number = 0.0;\r\n\r\n    public distortion: number = 0.0;\r\n    public distortionDelta: number = 0.0;\r\n    public distortionDrive: number = 0.0;\r\n    public distortionDriveDelta: number = 0.0;\r\n    public distortionFractionalInput1: number = 0.0;\r\n    public distortionFractionalInput2: number = 0.0;\r\n    public distortionFractionalInput3: number = 0.0;\r\n    public distortionPrevInput: number = 0.0;\r\n    public distortionNextOutput: number = 0.0;\r\n\r\n    public bitcrusherPrevInput: number = 0.0;\r\n    public bitcrusherCurrentOutput: number = 0.0;\r\n    public bitcrusherPhase: number = 1.0;\r\n    public bitcrusherPhaseDelta: number = 0.0;\r\n    public bitcrusherPhaseDeltaScale: number = 1.0;\r\n    public bitcrusherScale: number = 1.0;\r\n    public bitcrusherScaleScale: number = 1.0;\r\n    public bitcrusherFoldLevel: number = 1.0;\r\n    public bitcrusherFoldLevelScale: number = 1.0;\r\n\r\n    public readonly eqFilters: DynamicBiquadFilter[] = [];\r\n    public eqFilterCount: number = 0;\r\n    public initialEqFilterInput1: number = 0.0;\r\n    public initialEqFilterInput2: number = 0.0;\r\n\r\n    public panningDelayLine: Float32Array | null = null;\r\n    public panningDelayPos: number = 0;\r\n    public panningVolumeL: number = 0.0;\r\n    public panningVolumeR: number = 0.0;\r\n    public panningVolumeDeltaL: number = 0.0;\r\n    public panningVolumeDeltaR: number = 0.0;\r\n    public panningOffsetL: number = 0.0;\r\n    public panningOffsetR: number = 0.0;\r\n    public panningOffsetDeltaL: number = 0.0;\r\n    public panningOffsetDeltaR: number = 0.0;\r\n\r\n    public chorusDelayLineL: Float32Array | null = null;\r\n    public chorusDelayLineR: Float32Array | null = null;\r\n    public chorusDelayLineDirty: boolean = false;\r\n    public chorusDelayPos: number = 0;\r\n    public chorusPhase: number = 0;\r\n    public chorusVoiceMult: number = 0;\r\n    public chorusVoiceMultDelta: number = 0;\r\n    public chorusCombinedMult: number = 0;\r\n    public chorusCombinedMultDelta: number = 0;\r\n\r\n    public echoDelayLineL: Float32Array | null = null;\r\n    public echoDelayLineR: Float32Array | null = null;\r\n    public echoDelayLineDirty: boolean = false;\r\n    public echoDelayPos: number = 0;\r\n    public echoDelayOffsetStart: number = 0;\r\n    public echoDelayOffsetEnd: number | null = null;\r\n    public echoDelayOffsetRatio: number = 0.0;\r\n    public echoDelayOffsetRatioDelta: number = 0.0;\r\n    public echoMult: number = 0.0;\r\n    public echoMultDelta: number = 0.0;\r\n    public echoShelfA1: number = 0.0;\r\n    public echoShelfB0: number = 0.0;\r\n    public echoShelfB1: number = 0.0;\r\n    public echoShelfSampleL: number = 0.0;\r\n    public echoShelfSampleR: number = 0.0;\r\n    public echoShelfPrevInputL: number = 0.0;\r\n    public echoShelfPrevInputR: number = 0.0;\r\n\r\n    public reverbDelayLine: Float32Array | null = null;\r\n    public reverbDelayLineDirty: boolean = false;\r\n    public reverbDelayPos: number = 0;\r\n    public reverbMult: number = 0.0;\r\n    public reverbMultDelta: number = 0.0;\r\n    public reverbShelfA1: number = 0.0;\r\n    public reverbShelfB0: number = 0.0;\r\n    public reverbShelfB1: number = 0.0;\r\n    public reverbShelfSample0: number = 0.0;\r\n    public reverbShelfSample1: number = 0.0;\r\n    public reverbShelfSample2: number = 0.0;\r\n    public reverbShelfSample3: number = 0.0;\r\n    public reverbShelfPrevInput0: number = 0.0;\r\n    public reverbShelfPrevInput1: number = 0.0;\r\n    public reverbShelfPrevInput2: number = 0.0;\r\n    public reverbShelfPrevInput3: number = 0.0;\r\n\r\n    public invertWave: boolean = false;\r\n\r\n    //public readonly envelopeComputer: EnvelopeComputer = new EnvelopeComputer(false);\r\n\r\n    public readonly spectrumWave: SpectrumWaveState = new SpectrumWaveState();\r\n    public readonly harmonicsWave: HarmonicsWaveState = new HarmonicsWaveState();\r\n    public readonly drumsetSpectrumWaves: SpectrumWaveState[] = [];\r\n\r\n    constructor() {\r\n        for (let i: number = 0; i < Config.drumCount; i++) {\r\n            this.drumsetSpectrumWaves[i] = new SpectrumWaveState();\r\n        }\r\n    }\r\n\r\n\r\n    public allocateNecessaryBuffers(synth: Synth, instrument: Instrument, samplesPerTick: number): void {\r\n        if (effectsIncludePanning(instrument.effects)) {\r\n            if (this.panningDelayLine == null || this.panningDelayLine.length < synth.panningDelayBufferSize) {\r\n                this.panningDelayLine = new Float32Array(synth.panningDelayBufferSize);\r\n            }\r\n        }\r\n        if (effectsIncludeChorus(instrument.effects)) {\r\n            if (this.chorusDelayLineL == null || this.chorusDelayLineL.length < synth.chorusDelayBufferSize) {\r\n                this.chorusDelayLineL = new Float32Array(synth.chorusDelayBufferSize);\r\n            }\r\n            if (this.chorusDelayLineR == null || this.chorusDelayLineR.length < synth.chorusDelayBufferSize) {\r\n                this.chorusDelayLineR = new Float32Array(synth.chorusDelayBufferSize);\r\n            }\r\n        }\r\n        if (effectsIncludeEcho(instrument.effects)) {\r\n            // account for tempo and delay automation changing delay length during a tick?\r\n            const safeEchoDelaySteps: number = Math.max(Config.echoDelayRange >> 1, (instrument.echoDelay + 1)); // The delay may be very short now, but if it increases later make sure we have enough sample history.\r\n            const baseEchoDelayBufferSize: number = Synth.fittingPowerOfTwo(safeEchoDelaySteps * Config.echoDelayStepTicks * samplesPerTick);\r\n            const safeEchoDelayBufferSize: number = baseEchoDelayBufferSize * 2; // If the tempo or delay changes and we suddenly need a longer delay, make sure that we have enough sample history to accomodate the longer delay.\r\n\r\n            if (this.echoDelayLineL == null || this.echoDelayLineR == null) {\r\n                this.echoDelayLineL = new Float32Array(safeEchoDelayBufferSize);\r\n                this.echoDelayLineR = new Float32Array(safeEchoDelayBufferSize);\r\n            } else if (this.echoDelayLineL.length < safeEchoDelayBufferSize || this.echoDelayLineR.length < safeEchoDelayBufferSize) {\r\n                // The echo delay length may change whlie the song is playing if tempo changes,\r\n                // so buffers may need to be reallocated, but we don't want to lose any echoes\r\n                // so we need to copy the contents of the old buffer to the new one.\r\n                const newDelayLineL: Float32Array = new Float32Array(safeEchoDelayBufferSize);\r\n                const newDelayLineR: Float32Array = new Float32Array(safeEchoDelayBufferSize);\r\n                const oldMask: number = this.echoDelayLineL.length - 1;\r\n\r\n                for (let i = 0; i < this.echoDelayLineL.length; i++) {\r\n                    newDelayLineL[i] = this.echoDelayLineL[(this.echoDelayPos + i) & oldMask];\r\n                    newDelayLineR[i] = this.echoDelayLineL[(this.echoDelayPos + i) & oldMask];\r\n                }\r\n\r\n                this.echoDelayPos = this.echoDelayLineL.length;\r\n                this.echoDelayLineL = newDelayLineL;\r\n                this.echoDelayLineR = newDelayLineR;\r\n            }\r\n        }\r\n        if (effectsIncludeReverb(instrument.effects)) {\r\n            // TODO: Make reverb delay line sample rate agnostic. Maybe just double buffer size for 96KHz? Adjust attenuation and shelf cutoff appropriately?\r\n            if (this.reverbDelayLine == null) {\r\n                this.reverbDelayLine = new Float32Array(Config.reverbDelayBufferSize);\r\n            }\r\n        }\r\n    }\r\n\r\n    public deactivate(): void {\r\n        this.bitcrusherPrevInput = 0.0;\r\n        this.bitcrusherCurrentOutput = 0.0;\r\n        this.bitcrusherPhase = 1.0;\r\n        for (let i: number = 0; i < this.eqFilterCount; i++) {\r\n            this.eqFilters[i].resetOutput();\r\n        }\r\n        this.eqFilterCount = 0;\r\n        this.initialEqFilterInput1 = 0.0;\r\n        this.initialEqFilterInput2 = 0.0;\r\n        this.distortionFractionalInput1 = 0.0;\r\n        this.distortionFractionalInput2 = 0.0;\r\n        this.distortionFractionalInput3 = 0.0;\r\n        this.distortionPrevInput = 0.0;\r\n        this.distortionNextOutput = 0.0;\r\n        this.panningDelayPos = 0;\r\n        if (this.panningDelayLine != null) for (let i: number = 0; i < this.panningDelayLine.length; i++) this.panningDelayLine[i] = 0.0;\r\n        this.echoDelayOffsetEnd = null;\r\n        this.echoShelfSampleL = 0.0;\r\n        this.echoShelfSampleR = 0.0;\r\n        this.echoShelfPrevInputL = 0.0;\r\n        this.echoShelfPrevInputR = 0.0;\r\n        this.reverbShelfSample0 = 0.0;\r\n        this.reverbShelfSample1 = 0.0;\r\n        this.reverbShelfSample2 = 0.0;\r\n        this.reverbShelfSample3 = 0.0;\r\n        this.reverbShelfPrevInput0 = 0.0;\r\n        this.reverbShelfPrevInput1 = 0.0;\r\n        this.reverbShelfPrevInput2 = 0.0;\r\n        this.reverbShelfPrevInput3 = 0.0;\r\n\r\n        this.volumeScale = 1.0;\r\n        this.aliases = false;\r\n\r\n        this.awake = false;\r\n        this.flushingDelayLines = false;\r\n        this.deactivateAfterThisTick = false;\r\n        this.attentuationProgress = 0.0;\r\n        this.flushedSamples = 0;\r\n    }\r\n\r\n    public resetAllEffects(): void {\r\n        this.deactivate();\r\n\r\n        if (this.chorusDelayLineDirty) {\r\n            for (let i: number = 0; i < this.chorusDelayLineL!.length; i++) this.chorusDelayLineL![i] = 0.0;\r\n            for (let i: number = 0; i < this.chorusDelayLineR!.length; i++) this.chorusDelayLineR![i] = 0.0;\r\n        }\r\n        if (this.echoDelayLineDirty) {\r\n            for (let i: number = 0; i < this.echoDelayLineL!.length; i++) this.echoDelayLineL![i] = 0.0;\r\n            for (let i: number = 0; i < this.echoDelayLineR!.length; i++) this.echoDelayLineR![i] = 0.0;\r\n        }\r\n        if (this.reverbDelayLineDirty) {\r\n            for (let i: number = 0; i < this.reverbDelayLine!.length; i++) this.reverbDelayLine![i] = 0.0;\r\n        }\r\n\r\n        this.chorusPhase = 0.0;\r\n    }\r\n\r\n    public compute(synth: Synth, instrument: Instrument, samplesPerTick: number, roundedSamplesPerTick: number, tone: Tone | null, channelIndex: number, instrumentIndex: number): void {\r\n        this.computed = true;\r\n\r\n        this.invertWave = instrument.invertWave;\r\n\r\n        this.type = instrument.type;\r\n        this.synthesizer = Synth.getInstrumentSynthFunction(instrument);\r\n        this.unison = Config.unisons[instrument.unison];\r\n        this.chord = instrument.getChord();\r\n        this.noisePitchFilterMult = Config.chipNoises[instrument.chipNoise].pitchFilterMult;\r\n        this.effects = instrument.effects;\r\n\r\n        this.aliases = instrument.aliases;\r\n        this.volumeScale = 1.0;\r\n\r\n        this.allocateNecessaryBuffers(synth, instrument, samplesPerTick);\r\n\r\n        const samplesPerSecond: number = synth.samplesPerSecond;\r\n        this.updateWaves(instrument, samplesPerSecond);\r\n\r\n        //const ticksIntoBar: number = synth.getTicksIntoBar();\r\n        //const tickTimeStart: number = ticksIntoBar;\r\n        //const tickTimeEnd:   number = ticksIntoBar + 1.0;\r\n        //const secondsPerTick: number = samplesPerTick / synth.samplesPerSecond;\r\n        //const currentPart: number = synth.getCurrentPart();\r\n        //this.envelopeComputer.computeEnvelopes(instrument, currentPart, tickTimeStart, secondsPerTick, tone);\r\n        //const envelopeStarts: number[] = this.envelopeComputer.envelopeStarts;\r\n        //const envelopeEnds: number[] = this.envelopeComputer.envelopeEnds;\r\n\r\n        const usesDistortion: boolean = effectsIncludeDistortion(this.effects);\r\n        const usesBitcrusher: boolean = effectsIncludeBitcrusher(this.effects);\r\n        const usesPanning: boolean = effectsIncludePanning(this.effects);\r\n        const usesChorus: boolean = effectsIncludeChorus(this.effects);\r\n        const usesEcho: boolean = effectsIncludeEcho(this.effects);\r\n        const usesReverb: boolean = effectsIncludeReverb(this.effects);\r\n\r\n        if (usesDistortion) {\r\n            let useDistortionStart: number = instrument.distortion;\r\n            let useDistortionEnd: number = instrument.distortion;\r\n\r\n            // Check for distortion mods\r\n            if (synth.isModActive(Config.modulators.dictionary[\"distortion\"].index, channelIndex, instrumentIndex)) {\r\n                useDistortionStart = synth.getModValue(Config.modulators.dictionary[\"distortion\"].index, channelIndex, instrumentIndex, false);\r\n                useDistortionEnd = synth.getModValue(Config.modulators.dictionary[\"distortion\"].index, channelIndex, instrumentIndex, true);\r\n            }\r\n\r\n            const distortionSliderStart = Math.min(1.0, /*envelopeStarts[InstrumentAutomationIndex.distortion] **/ useDistortionStart / (Config.distortionRange - 1));\r\n            const distortionSliderEnd = Math.min(1.0, /*envelopeEnds[  InstrumentAutomationIndex.distortion] **/ useDistortionEnd / (Config.distortionRange - 1));\r\n            const distortionStart: number = Math.pow(1.0 - 0.895 * (Math.pow(20.0, distortionSliderStart) - 1.0) / 19.0, 2.0);\r\n            const distortionEnd: number = Math.pow(1.0 - 0.895 * (Math.pow(20.0, distortionSliderEnd) - 1.0) / 19.0, 2.0);\r\n            const distortionDriveStart: number = (1.0 + 2.0 * distortionSliderStart) / Config.distortionBaseVolume;\r\n            const distortionDriveEnd: number = (1.0 + 2.0 * distortionSliderEnd) / Config.distortionBaseVolume;\r\n            this.distortion = distortionStart;\r\n            this.distortionDelta = (distortionEnd - distortionStart) / roundedSamplesPerTick;\r\n            this.distortionDrive = distortionDriveStart;\r\n            this.distortionDriveDelta = (distortionDriveEnd - distortionDriveStart) / roundedSamplesPerTick;\r\n        }\r\n\r\n        if (usesBitcrusher) {\r\n            let freqSettingStart: number = instrument.bitcrusherFreq /** Math.sqrt(envelopeStarts[InstrumentAutomationIndex.bitcrusherFrequency])*/;\r\n            let freqSettingEnd: number = instrument.bitcrusherFreq /** Math.sqrt(envelopeEnds[  InstrumentAutomationIndex.bitcrusherFrequency])*/;\r\n\r\n            // Check for freq crush mods\r\n            if (synth.isModActive(Config.modulators.dictionary[\"freq crush\"].index, channelIndex, instrumentIndex)) {\r\n                freqSettingStart = synth.getModValue(Config.modulators.dictionary[\"freq crush\"].index, channelIndex, instrumentIndex, false);\r\n                freqSettingEnd = synth.getModValue(Config.modulators.dictionary[\"freq crush\"].index, channelIndex, instrumentIndex, true);\r\n            }\r\n\r\n            let quantizationSettingStart: number = instrument.bitcrusherQuantization /** Math.sqrt(envelopeStarts[InstrumentAutomationIndex.bitcrusherQuantization])*/;\r\n            let quantizationSettingEnd: number = instrument.bitcrusherQuantization /** Math.sqrt(envelopeEnds[  InstrumentAutomationIndex.bitcrusherQuantization])*/;\r\n\r\n            // Check for bitcrush mods\r\n            if (synth.isModActive(Config.modulators.dictionary[\"bit crush\"].index, channelIndex, instrumentIndex)) {\r\n                quantizationSettingStart = synth.getModValue(Config.modulators.dictionary[\"bit crush\"].index, channelIndex, instrumentIndex, false);\r\n                quantizationSettingEnd = synth.getModValue(Config.modulators.dictionary[\"bit crush\"].index, channelIndex, instrumentIndex, true);\r\n            }\r\n\r\n            const basePitch: number = Config.keys[synth.song!.key].basePitch; // TODO: What if there's a key change mid-song?\r\n            const freqStart: number = Instrument.frequencyFromPitch(basePitch + 60) * Math.pow(2.0, (Config.bitcrusherFreqRange - 1 - freqSettingStart) * Config.bitcrusherOctaveStep);\r\n            const freqEnd: number = Instrument.frequencyFromPitch(basePitch + 60) * Math.pow(2.0, (Config.bitcrusherFreqRange - 1 - freqSettingEnd) * Config.bitcrusherOctaveStep);\r\n            const phaseDeltaStart: number = Math.min(1.0, freqStart / samplesPerSecond);\r\n            const phaseDeltaEnd: number = Math.min(1.0, freqEnd / samplesPerSecond);\r\n            this.bitcrusherPhaseDelta = phaseDeltaStart;\r\n            this.bitcrusherPhaseDeltaScale = Math.pow(phaseDeltaEnd / phaseDeltaStart, 1.0 / roundedSamplesPerTick);\r\n\r\n            const scaleStart: number = 2.0 * Config.bitcrusherBaseVolume * Math.pow(2.0, 1.0 - Math.pow(2.0, (Config.bitcrusherQuantizationRange - 1 - quantizationSettingStart) * 0.5));\r\n            const scaleEnd: number = 2.0 * Config.bitcrusherBaseVolume * Math.pow(2.0, 1.0 - Math.pow(2.0, (Config.bitcrusherQuantizationRange - 1 - quantizationSettingEnd) * 0.5));\r\n            this.bitcrusherScale = scaleStart;\r\n            this.bitcrusherScaleScale = Math.pow(scaleEnd / scaleStart, 1.0 / roundedSamplesPerTick);\r\n\r\n            const foldLevelStart: number = 2.0 * Config.bitcrusherBaseVolume * Math.pow(1.5, Config.bitcrusherQuantizationRange - 1 - quantizationSettingStart);\r\n            const foldLevelEnd: number = 2.0 * Config.bitcrusherBaseVolume * Math.pow(1.5, Config.bitcrusherQuantizationRange - 1 - quantizationSettingEnd);\r\n            this.bitcrusherFoldLevel = foldLevelStart;\r\n            this.bitcrusherFoldLevelScale = Math.pow(foldLevelEnd / foldLevelStart, 1.0 / roundedSamplesPerTick);\r\n        }\r\n\r\n        let eqFilterVolume: number = 1.0; //this.envelopeComputer.lowpassCutoffDecayVolumeCompensation;\r\n        if (instrument.eqFilterType) {\r\n            // Simple EQ filter (old style). For analysis, using random filters from normal style since they are N/A in this context.\r\n            const eqFilterSettingsStart: FilterSettings = instrument.eqFilter;\r\n            if (instrument.eqSubFilters[1] == null)\r\n                instrument.eqSubFilters[1] = new FilterSettings();\r\n            const eqFilterSettingsEnd: FilterSettings = instrument.eqSubFilters[1];\r\n\r\n            // Change location based on slider values\r\n            let startSimpleFreq: number = instrument.eqFilterSimpleCut;\r\n            let startSimpleGain: number = instrument.eqFilterSimplePeak;\r\n            let endSimpleFreq: number = instrument.eqFilterSimpleCut;\r\n            let endSimpleGain: number = instrument.eqFilterSimplePeak;\r\n\r\n            let filterChanges: boolean = false;\r\n\r\n            if (synth.isModActive(Config.modulators.dictionary[\"eq filt cut\"].index, channelIndex, instrumentIndex)) {\r\n                startSimpleFreq = synth.getModValue(Config.modulators.dictionary[\"eq filt cut\"].index, channelIndex, instrumentIndex, false);\r\n                endSimpleFreq = synth.getModValue(Config.modulators.dictionary[\"eq filt cut\"].index, channelIndex, instrumentIndex, true);\r\n                filterChanges = true;\r\n            }\r\n            if (synth.isModActive(Config.modulators.dictionary[\"eq filt peak\"].index, channelIndex, instrumentIndex)) {\r\n                startSimpleGain = synth.getModValue(Config.modulators.dictionary[\"eq filt peak\"].index, channelIndex, instrumentIndex, false);\r\n                endSimpleGain = synth.getModValue(Config.modulators.dictionary[\"eq filt peak\"].index, channelIndex, instrumentIndex, true);\r\n                filterChanges = true;\r\n            }\r\n\r\n            let startPoint: FilterControlPoint;\r\n\r\n            if (filterChanges) {\r\n                eqFilterSettingsStart.convertLegacySettingsForSynth(startSimpleFreq, startSimpleGain);\r\n                eqFilterSettingsEnd.convertLegacySettingsForSynth(endSimpleFreq, endSimpleGain);\r\n\r\n                startPoint = eqFilterSettingsStart.controlPoints[0];\r\n                let endPoint: FilterControlPoint = eqFilterSettingsEnd.controlPoints[0];\r\n\r\n                startPoint.toCoefficients(Synth.tempFilterStartCoefficients, samplesPerSecond, 1.0, 1.0);\r\n                endPoint.toCoefficients(Synth.tempFilterEndCoefficients, samplesPerSecond, 1.0, 1.0);\r\n\r\n                if (this.eqFilters.length < 1) this.eqFilters[0] = new DynamicBiquadFilter();\r\n                this.eqFilters[0].loadCoefficientsWithGradient(Synth.tempFilterStartCoefficients, Synth.tempFilterEndCoefficients, 1.0 / roundedSamplesPerTick, startPoint.type == FilterType.lowPass);\r\n\r\n            } else {\r\n                eqFilterSettingsStart.convertLegacySettingsForSynth(startSimpleFreq, startSimpleGain, true);\r\n\r\n                startPoint = eqFilterSettingsStart.controlPoints[0];\r\n\r\n                startPoint.toCoefficients(Synth.tempFilterStartCoefficients, samplesPerSecond, 1.0, 1.0);\r\n\r\n                if (this.eqFilters.length < 1) this.eqFilters[0] = new DynamicBiquadFilter();\r\n                this.eqFilters[0].loadCoefficientsWithGradient(Synth.tempFilterStartCoefficients, Synth.tempFilterStartCoefficients, 1.0 / roundedSamplesPerTick, startPoint.type == FilterType.lowPass);\r\n\r\n            }\r\n\r\n            eqFilterVolume *= startPoint.getVolumeCompensationMult();\r\n\r\n            this.eqFilterCount = 1;\r\n            eqFilterVolume = Math.min(3.0, eqFilterVolume);\r\n        }\r\n        else {\r\n            const eqFilterSettings: FilterSettings = (instrument.tmpEqFilterStart != null) ? instrument.tmpEqFilterStart : instrument.eqFilter;\r\n            //const eqAllFreqsEnvelopeStart: number = envelopeStarts[InstrumentAutomationIndex.eqFilterAllFreqs];\r\n            //const eqAllFreqsEnvelopeEnd:   number = envelopeEnds[  InstrumentAutomationIndex.eqFilterAllFreqs];\r\n            for (let i: number = 0; i < eqFilterSettings.controlPointCount; i++) {\r\n                //const eqFreqEnvelopeStart: number = envelopeStarts[InstrumentAutomationIndex.eqFilterFreq0 + i];\r\n                //const eqFreqEnvelopeEnd:   number = envelopeEnds[  InstrumentAutomationIndex.eqFilterFreq0 + i];\r\n                //const eqPeakEnvelopeStart: number = envelopeStarts[InstrumentAutomationIndex.eqFilterGain0 + i];\r\n                //const eqPeakEnvelopeEnd:   number = envelopeEnds[  InstrumentAutomationIndex.eqFilterGain0 + i];\r\n                let startPoint: FilterControlPoint = eqFilterSettings.controlPoints[i];\r\n                let endPoint: FilterControlPoint = (instrument.tmpEqFilterEnd != null && instrument.tmpEqFilterEnd.controlPoints[i] != null) ? instrument.tmpEqFilterEnd.controlPoints[i] : eqFilterSettings.controlPoints[i];\r\n\r\n                // If switching dot type, do it all at once and do not try to interpolate since no valid interpolation exists.\r\n                if (startPoint.type != endPoint.type) {\r\n                    startPoint = endPoint;\r\n                }\r\n\r\n                startPoint.toCoefficients(Synth.tempFilterStartCoefficients, samplesPerSecond, /*eqAllFreqsEnvelopeStart * eqFreqEnvelopeStart*/ 1.0, /*eqPeakEnvelopeStart*/ 1.0);\r\n                endPoint.toCoefficients(Synth.tempFilterEndCoefficients, samplesPerSecond, /*eqAllFreqsEnvelopeEnd   * eqFreqEnvelopeEnd*/   1.0, /*eqPeakEnvelopeEnd*/   1.0);\r\n                if (this.eqFilters.length <= i) this.eqFilters[i] = new DynamicBiquadFilter();\r\n                this.eqFilters[i].loadCoefficientsWithGradient(Synth.tempFilterStartCoefficients, Synth.tempFilterEndCoefficients, 1.0 / roundedSamplesPerTick, startPoint.type == FilterType.lowPass);\r\n                eqFilterVolume *= startPoint.getVolumeCompensationMult();\r\n\r\n            }\r\n            this.eqFilterCount = eqFilterSettings.controlPointCount;\r\n            eqFilterVolume = Math.min(3.0, eqFilterVolume);\r\n        }\r\n\r\n        const mainInstrumentVolume: number = Synth.instrumentVolumeToVolumeMult(instrument.volume);\r\n        this.mixVolume = mainInstrumentVolume /** envelopeStarts[InstrumentAutomationIndex.mixVolume]*/;\r\n        let mixVolumeEnd: number = mainInstrumentVolume /** envelopeEnds[  InstrumentAutomationIndex.mixVolume]*/;\r\n\r\n        // Check for mod-related volume delta\r\n        if (synth.isModActive(Config.modulators.dictionary[\"mix volume\"].index, channelIndex, instrumentIndex)) {\r\n            // Linear falloff below 0, normal volume formula above 0. Seems to work best for scaling since the normal volume mult formula has a big gap from -25 to -24.\r\n            const startVal: number = synth.getModValue(Config.modulators.dictionary[\"mix volume\"].index, channelIndex, instrumentIndex, false);\r\n            const endVal: number = synth.getModValue(Config.modulators.dictionary[\"mix volume\"].index, channelIndex, instrumentIndex, true)\r\n            this.mixVolume *= ((startVal <= 0) ? ((startVal + Config.volumeRange / 2) / (Config.volumeRange / 2)) : Synth.instrumentVolumeToVolumeMult(startVal));\r\n            mixVolumeEnd *= ((endVal <= 0) ? ((endVal + Config.volumeRange / 2) / (Config.volumeRange / 2)) : Synth.instrumentVolumeToVolumeMult(endVal));\r\n        }\r\n\r\n        // Check for SONG mod-related volume delta\r\n        if (synth.isModActive(Config.modulators.dictionary[\"song volume\"].index)) {\r\n            this.mixVolume *= (synth.getModValue(Config.modulators.dictionary[\"song volume\"].index, undefined, undefined, false)) / 100.0;\r\n            mixVolumeEnd *= (synth.getModValue(Config.modulators.dictionary[\"song volume\"].index, undefined, undefined, true)) / 100.0;\r\n        }\r\n\r\n        this.mixVolumeDelta = (mixVolumeEnd - this.mixVolume) / roundedSamplesPerTick;\r\n\r\n        let eqFilterVolumeStart: number = eqFilterVolume;\r\n        let eqFilterVolumeEnd: number = eqFilterVolume;\r\n        let delayInputMultStart: number = 1.0;\r\n        let delayInputMultEnd: number = 1.0;\r\n\r\n        if (usesPanning) {\r\n            //const panEnvelopeStart: number = envelopeStarts[InstrumentAutomationIndex.panning] * 2.0 - 1.0;\r\n            //const panEnvelopeEnd:   number = envelopeEnds[  InstrumentAutomationIndex.panning] * 2.0 - 1.0;\r\n\r\n            let usePanStart: number = instrument.pan;\r\n            let usePanEnd: number = instrument.pan;\r\n            // Check for pan mods\r\n            if (synth.isModActive(Config.modulators.dictionary[\"pan\"].index, channelIndex, instrumentIndex)) {\r\n                usePanStart = synth.getModValue(Config.modulators.dictionary[\"pan\"].index, channelIndex, instrumentIndex, false);\r\n                usePanEnd = synth.getModValue(Config.modulators.dictionary[\"pan\"].index, channelIndex, instrumentIndex, true);\r\n            }\r\n\r\n            let panStart: number = Math.max(-1.0, Math.min(1.0, (usePanStart - Config.panCenter) / Config.panCenter /** panEnvelopeStart*/));\r\n            let panEnd: number = Math.max(-1.0, Math.min(1.0, (usePanEnd - Config.panCenter) / Config.panCenter /** panEnvelopeEnd  */));\r\n\r\n            const volumeStartL: number = Math.cos((1 + panStart) * Math.PI * 0.25) * 1.414;\r\n            const volumeStartR: number = Math.cos((1 - panStart) * Math.PI * 0.25) * 1.414;\r\n            const volumeEndL: number = Math.cos((1 + panEnd) * Math.PI * 0.25) * 1.414;\r\n            const volumeEndR: number = Math.cos((1 - panEnd) * Math.PI * 0.25) * 1.414;\r\n            const maxDelaySamples: number = samplesPerSecond * Config.panDelaySecondsMax;\r\n\r\n            let usePanDelayStart: number = instrument.panDelay;\r\n            let usePanDelayEnd: number = instrument.panDelay;\r\n            // Check for pan delay mods\r\n            if (synth.isModActive(Config.modulators.dictionary[\"pan delay\"].index, channelIndex, instrumentIndex)) {\r\n                usePanDelayStart = synth.getModValue(Config.modulators.dictionary[\"pan delay\"].index, channelIndex, instrumentIndex, false);\r\n                usePanDelayEnd = synth.getModValue(Config.modulators.dictionary[\"pan delay\"].index, channelIndex, instrumentIndex, true);\r\n            }\r\n\r\n            const delayStart: number = panStart * usePanDelayStart * maxDelaySamples / 10;\r\n            const delayEnd: number = panEnd * usePanDelayEnd * maxDelaySamples / 10;\r\n            const delayStartL: number = Math.max(0.0, delayStart);\r\n            const delayStartR: number = Math.max(0.0, -delayStart);\r\n            const delayEndL: number = Math.max(0.0, delayEnd);\r\n            const delayEndR: number = Math.max(0.0, -delayEnd);\r\n\r\n            this.panningVolumeL = volumeStartL;\r\n            this.panningVolumeR = volumeStartR;\r\n            this.panningVolumeDeltaL = (volumeEndL - volumeStartL) / roundedSamplesPerTick;\r\n            this.panningVolumeDeltaR = (volumeEndR - volumeStartR) / roundedSamplesPerTick;\r\n            this.panningOffsetL = this.panningDelayPos - delayStartL + synth.panningDelayBufferSize;\r\n            this.panningOffsetR = this.panningDelayPos - delayStartR + synth.panningDelayBufferSize;\r\n            this.panningOffsetDeltaL = (delayEndL - delayStartL) / roundedSamplesPerTick;\r\n            this.panningOffsetDeltaR = (delayEndR - delayStartR) / roundedSamplesPerTick;\r\n        }\r\n\r\n        if (usesChorus) {\r\n            //const chorusEnvelopeStart: number = envelopeStarts[InstrumentAutomationIndex.chorus];\r\n            //const chorusEnvelopeEnd:   number = envelopeEnds[  InstrumentAutomationIndex.chorus];\r\n            let useChorusStart: number = instrument.chorus;\r\n            let useChorusEnd: number = instrument.chorus;\r\n            // Check for chorus mods\r\n            if (synth.isModActive(Config.modulators.dictionary[\"chorus\"].index, channelIndex, instrumentIndex)) {\r\n                useChorusStart = synth.getModValue(Config.modulators.dictionary[\"chorus\"].index, channelIndex, instrumentIndex, false);\r\n                useChorusEnd = synth.getModValue(Config.modulators.dictionary[\"chorus\"].index, channelIndex, instrumentIndex, true);\r\n            }\r\n\r\n            let chorusStart: number = Math.min(1.0, /*chorusEnvelopeStart **/ useChorusStart / (Config.chorusRange - 1));\r\n            let chorusEnd: number = Math.min(1.0, /*chorusEnvelopeEnd   **/ useChorusEnd / (Config.chorusRange - 1));\r\n            chorusStart = chorusStart * 0.6 + (Math.pow(chorusStart, 6.0)) * 0.4;\r\n            chorusEnd = chorusEnd * 0.6 + (Math.pow(chorusEnd, 6.0)) * 0.4;\r\n            const chorusCombinedMultStart = 1.0 / Math.sqrt(3.0 * chorusStart * chorusStart + 1.0);\r\n            const chorusCombinedMultEnd = 1.0 / Math.sqrt(3.0 * chorusEnd * chorusEnd + 1.0);\r\n            this.chorusVoiceMult = chorusStart;\r\n            this.chorusVoiceMultDelta = (chorusEnd - chorusStart) / roundedSamplesPerTick;\r\n            this.chorusCombinedMult = chorusCombinedMultStart;\r\n            this.chorusCombinedMultDelta = (chorusCombinedMultEnd - chorusCombinedMultStart) / roundedSamplesPerTick;\r\n        }\r\n\r\n        let maxEchoMult = 0.0;\r\n        let averageEchoDelaySeconds: number = 0.0;\r\n        if (usesEcho) {\r\n            //const echoSustainEnvelopeStart: number = envelopeStarts[InstrumentAutomationIndex.echoSustain];\r\n            //const echoSustainEnvelopeEnd:   number = envelopeEnds[  InstrumentAutomationIndex.echoSustain];\r\n            let useEchoSustainStart: number = instrument.echoSustain;\r\n            let useEchoSustainEnd: number = instrument.echoSustain;\r\n            // Check for echo mods\r\n            if (synth.isModActive(Config.modulators.dictionary[\"echo\"].index, channelIndex, instrumentIndex)) {\r\n                useEchoSustainStart = Math.max( 0.0, synth.getModValue(Config.modulators.dictionary[\"echo\"].index, channelIndex, instrumentIndex, false) );\r\n                useEchoSustainEnd = Math.max( 0.0, synth.getModValue(Config.modulators.dictionary[\"echo\"].index, channelIndex, instrumentIndex, true) );\r\n            }\r\n            const echoMultStart: number = Math.min(1.0, Math.pow(/*echoSustainEnvelopeStart **/ useEchoSustainStart / Config.echoSustainRange, 1.1)) * 0.9;\r\n            const echoMultEnd: number = Math.min(1.0, Math.pow(/*echoSustainEnvelopeEnd   **/ useEchoSustainEnd / Config.echoSustainRange, 1.1)) * 0.9;\r\n            this.echoMult = echoMultStart;\r\n            this.echoMultDelta = Math.max(0.0, (echoMultEnd - echoMultStart) / roundedSamplesPerTick);\r\n            maxEchoMult = Math.max(echoMultStart, echoMultEnd);\r\n\r\n            // TODO: After computing a tick's settings once for multiple run lengths (which is\r\n            // good for audio worklet threads), compute the echo delay envelopes at tick (or\r\n            // part) boundaries to interpolate between two delay taps.\r\n            //const echoDelayEnvelopeStart:   number = envelopeStarts[InstrumentAutomationIndex.echoDelay];\r\n            //const echoDelayEnvelopeEnd:     number = envelopeEnds[  InstrumentAutomationIndex.echoDelay];\r\n            let useEchoDelayStart: number = instrument.echoDelay;\r\n            let useEchoDelayEnd: number = instrument.echoDelay;\r\n            let ignoreTicks: boolean = false;\r\n            // Check for pan delay mods\r\n            if (synth.isModActive(Config.modulators.dictionary[\"echo delay\"].index, channelIndex, instrumentIndex)) {\r\n                useEchoDelayStart = synth.getModValue(Config.modulators.dictionary[\"echo delay\"].index, channelIndex, instrumentIndex, false);\r\n                useEchoDelayEnd = synth.getModValue(Config.modulators.dictionary[\"echo delay\"].index, channelIndex, instrumentIndex, true);\r\n                ignoreTicks = true;\r\n            }\r\n\r\n            const tmpEchoDelayOffsetStart: number = Math.round((useEchoDelayStart + 1) * Config.echoDelayStepTicks * samplesPerTick);\r\n            const tmpEchoDelayOffsetEnd: number = Math.round((useEchoDelayEnd + 1) * Config.echoDelayStepTicks * samplesPerTick);\r\n            if (this.echoDelayOffsetEnd != null && !ignoreTicks) {\r\n                this.echoDelayOffsetStart = this.echoDelayOffsetEnd;\r\n            } else {\r\n                this.echoDelayOffsetStart = tmpEchoDelayOffsetStart;\r\n            }\r\n\r\n            this.echoDelayOffsetEnd = tmpEchoDelayOffsetEnd;\r\n            averageEchoDelaySeconds = (this.echoDelayOffsetStart + this.echoDelayOffsetEnd) * 0.5 / samplesPerSecond;\r\n\r\n            this.echoDelayOffsetRatio = 0.0;\r\n            this.echoDelayOffsetRatioDelta = 1.0 / roundedSamplesPerTick;\r\n\r\n            const shelfRadians: number = 2.0 * Math.PI * Config.echoShelfHz / synth.samplesPerSecond;\r\n            Synth.tempFilterStartCoefficients.highShelf1stOrder(shelfRadians, Config.echoShelfGain);\r\n            this.echoShelfA1 = Synth.tempFilterStartCoefficients.a[1];\r\n            this.echoShelfB0 = Synth.tempFilterStartCoefficients.b[0];\r\n            this.echoShelfB1 = Synth.tempFilterStartCoefficients.b[1];\r\n        }\r\n\r\n        let maxReverbMult = 0.0;\r\n        if (usesReverb) {\r\n            //const reverbEnvelopeStart: number = envelopeStarts[InstrumentAutomationIndex.reverb];\r\n            //const reverbEnvelopeEnd:   number = envelopeEnds[  InstrumentAutomationIndex.reverb];\r\n\r\n            let useReverbStart: number = instrument.reverb;\r\n            let useReverbEnd: number = instrument.reverb;\r\n\r\n            // Check for mod reverb, instrument level\r\n            if (synth.isModActive(Config.modulators.dictionary[\"reverb\"].index, channelIndex, instrumentIndex)) {\r\n                useReverbStart = synth.getModValue(Config.modulators.dictionary[\"reverb\"].index, channelIndex, instrumentIndex, false);\r\n                useReverbEnd = synth.getModValue(Config.modulators.dictionary[\"reverb\"].index, channelIndex, instrumentIndex, true);\r\n            }\r\n            // Check for mod reverb, song scalar\r\n            if (synth.isModActive(Config.modulators.dictionary[\"song reverb\"].index, channelIndex, instrumentIndex)) {\r\n                useReverbStart *= (synth.getModValue(Config.modulators.dictionary[\"song reverb\"].index, undefined, undefined, false) - Config.modulators.dictionary[\"song reverb\"].convertRealFactor) / Config.reverbRange;\r\n                useReverbEnd *= (synth.getModValue(Config.modulators.dictionary[\"song reverb\"].index, undefined, undefined, true) - Config.modulators.dictionary[\"song reverb\"].convertRealFactor) / Config.reverbRange;\r\n            }\r\n\r\n            const reverbStart: number = Math.min(1.0, Math.pow(/*reverbEnvelopeStart **/ useReverbStart / Config.reverbRange, 0.667)) * 0.425;\r\n            const reverbEnd: number = Math.min(1.0, Math.pow(/*reverbEnvelopeEnd   **/ useReverbEnd / Config.reverbRange, 0.667)) * 0.425;\r\n\r\n            this.reverbMult = reverbStart;\r\n            this.reverbMultDelta = (reverbEnd - reverbStart) / roundedSamplesPerTick;\r\n            maxReverbMult = Math.max(reverbStart, reverbEnd);\r\n\r\n            const shelfRadians: number = 2.0 * Math.PI * Config.reverbShelfHz / synth.samplesPerSecond;\r\n            Synth.tempFilterStartCoefficients.highShelf1stOrder(shelfRadians, Config.reverbShelfGain);\r\n            this.reverbShelfA1 = Synth.tempFilterStartCoefficients.a[1];\r\n            this.reverbShelfB0 = Synth.tempFilterStartCoefficients.b[0];\r\n            this.reverbShelfB1 = Synth.tempFilterStartCoefficients.b[1];\r\n        }\r\n\r\n        if (this.tonesAddedInThisTick) {\r\n            this.attentuationProgress = 0.0;\r\n            this.flushedSamples = 0;\r\n            this.flushingDelayLines = false;\r\n        } else if (!this.flushingDelayLines) {\r\n            // If this instrument isn't playing tones anymore, the volume can fade out by the\r\n            // end of the first tick. It's possible for filters and the panning delay line to\r\n            // continue past the end of the tone but they should have mostly dissipated by the\r\n            // end of the tick anyway.\r\n            if (this.attentuationProgress == 0.0) {\r\n                eqFilterVolumeEnd = 0.0;\r\n            } else {\r\n                eqFilterVolumeStart = 0.0;\r\n                eqFilterVolumeEnd = 0.0;\r\n            }\r\n\r\n            const attenuationThreshold: number = 1.0 / 256.0; // when the delay line signal has attenuated this much, it should be inaudible and should be flushed to zero.\r\n            const halfLifeMult: number = -Math.log2(attenuationThreshold);\r\n            let delayDuration: number = 0.0;\r\n\r\n            if (usesChorus) {\r\n                delayDuration += Config.chorusMaxDelay;\r\n            }\r\n\r\n            if (usesEcho) {\r\n                const attenuationPerSecond: number = Math.pow(maxEchoMult, 1.0 / averageEchoDelaySeconds);\r\n                const halfLife: number = -1.0 / Math.log2(attenuationPerSecond);\r\n                const echoDuration: number = halfLife * halfLifeMult;\r\n                delayDuration += echoDuration;\r\n            }\r\n\r\n            if (usesReverb) {\r\n                const averageMult: number = maxReverbMult * 2.0;\r\n                const averageReverbDelaySeconds: number = (Config.reverbDelayBufferSize / 4.0) / samplesPerSecond;\r\n                const attenuationPerSecond: number = Math.pow(averageMult, 1.0 / averageReverbDelaySeconds);\r\n                const halfLife: number = -1.0 / Math.log2(attenuationPerSecond);\r\n                const reverbDuration: number = halfLife * halfLifeMult;\r\n                delayDuration += reverbDuration;\r\n            }\r\n\r\n            const secondsInTick: number = samplesPerTick / samplesPerSecond;\r\n            const progressInTick: number = secondsInTick / delayDuration;\r\n            const progressAtEndOfTick: number = this.attentuationProgress + progressInTick;\r\n            if (progressAtEndOfTick >= 1.0) {\r\n                delayInputMultEnd = 0.0;\r\n            }\r\n\r\n            this.attentuationProgress = progressAtEndOfTick;\r\n            if (this.attentuationProgress >= 1.0) {\r\n                this.flushingDelayLines = true;\r\n            }\r\n        } else {\r\n            // Flushing delay lines to zero since the signal has mostly dissipated.\r\n            eqFilterVolumeStart = 0.0;\r\n            eqFilterVolumeEnd = 0.0;\r\n            delayInputMultStart = 0.0;\r\n            delayInputMultEnd = 0.0;\r\n\r\n            let totalDelaySamples: number = 0;\r\n            if (usesChorus) totalDelaySamples += synth.chorusDelayBufferSize;\r\n            if (usesEcho) totalDelaySamples += this.echoDelayLineL!.length;\r\n            if (usesReverb) totalDelaySamples += Config.reverbDelayBufferSize;\r\n\r\n            this.flushedSamples += roundedSamplesPerTick;\r\n            if (this.flushedSamples >= totalDelaySamples) {\r\n                this.deactivateAfterThisTick = true;\r\n            }\r\n        }\r\n\r\n        this.eqFilterVolume = eqFilterVolumeStart;\r\n        this.eqFilterVolumeDelta = (eqFilterVolumeEnd - eqFilterVolumeStart) / roundedSamplesPerTick;\r\n        this.delayInputMult = delayInputMultStart;\r\n        this.delayInputMultDelta = (delayInputMultEnd - delayInputMultStart) / roundedSamplesPerTick;\r\n    }\r\n\r\n    public updateWaves(instrument: Instrument, samplesPerSecond: number): void {\r\n        this.volumeScale = 1.0;\r\n        if (instrument.type == InstrumentType.chip) {\r\n            this.wave = (this.aliases) ? Config.rawChipWaves[instrument.chipWave].samples : Config.chipWaves[instrument.chipWave].samples;\r\n        } else if (instrument.type == InstrumentType.customChipWave) {\r\n            this.wave = (this.aliases) ? instrument.customChipWave! : instrument.customChipWaveIntegral!;\r\n            this.volumeScale = 0.05;\r\n        } else if (instrument.type == InstrumentType.noise) {\r\n            this.wave = getDrumWave(instrument.chipNoise, inverseRealFourierTransform, scaleElementsByFactor);\r\n        } else if (instrument.type == InstrumentType.harmonics) {\r\n            this.wave = this.harmonicsWave.getCustomWave(instrument.harmonicsWave, instrument.type);\r\n        } else if (instrument.type == InstrumentType.pickedString) {\r\n            this.wave = this.harmonicsWave.getCustomWave(instrument.harmonicsWave, instrument.type);\r\n        } else if (instrument.type == InstrumentType.spectrum) {\r\n            this.wave = this.spectrumWave.getCustomWave(instrument.spectrumWave, 8);\r\n        } else if (instrument.type == InstrumentType.drumset) {\r\n            for (let i: number = 0; i < Config.drumCount; i++) {\r\n                this.drumsetSpectrumWaves[i].getCustomWave(instrument.drumsetSpectrumWaves[i], InstrumentState._drumsetIndexToSpectrumOctave(i));\r\n            }\r\n            this.wave = null;\r\n        } else {\r\n            this.wave = null;\r\n        }\r\n    }\r\n\r\n    public getDrumsetWave(pitch: number): Float32Array {\r\n        if (this.type == InstrumentType.drumset) {\r\n            return this.drumsetSpectrumWaves[pitch].wave!;\r\n        } else {\r\n            throw new Error(\"Unhandled instrument type in getDrumsetWave\");\r\n        }\r\n    }\r\n\r\n    public static drumsetIndexReferenceDelta(index: number): number {\r\n        return Instrument.frequencyFromPitch(Config.spectrumBasePitch + index * 6) / 44100;\r\n    }\r\n\r\n    private static _drumsetIndexToSpectrumOctave(index: number): number {\r\n        return 15 + Math.log2(InstrumentState.drumsetIndexReferenceDelta(index));\r\n    }\r\n}\r\n\r\nclass ChannelState {\r\n    public readonly instruments: InstrumentState[] = [];\r\n    public muted: boolean = false;\r\n    public singleSeamlessInstrument: number | null = null; // Seamless tones from a pattern with a single instrument can be transferred to a different single seamless instrument in the next pattern.\r\n}\r\n\r\nexport class Synth {\r\n\r\n    private syncSongState(): void {\r\n        const channelCount: number = this.song!.getChannelCount();\r\n        for (let i: number = this.channels.length; i < channelCount; i++) {\r\n            this.channels[i] = new ChannelState();\r\n        }\r\n        this.channels.length = channelCount;\r\n        for (let i: number = 0; i < channelCount; i++) {\r\n            const channel: Channel = this.song!.channels[i];\r\n            const channelState: ChannelState = this.channels[i];\r\n            for (let j: number = channelState.instruments.length; j < channel.instruments.length; j++) {\r\n                channelState.instruments[j] = new InstrumentState();\r\n            }\r\n            channelState.instruments.length = channel.instruments.length;\r\n\r\n            if (channelState.muted != channel.muted) {\r\n                channelState.muted = channel.muted;\r\n                if (channelState.muted) {\r\n                    for (const instrumentState of channelState.instruments) {\r\n                        instrumentState.resetAllEffects();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public warmUpSynthesizer(song: Song | null): void {\r\n        // Don't bother to generate the drum waves unless the song actually\r\n        // uses them, since they may require a lot of computation.\r\n        if (song != null) {\r\n            this.syncSongState();\r\n            const samplesPerTick: number = this.getSamplesPerTick();\r\n            for (let channelIndex: number = 0; channelIndex < song.getChannelCount(); channelIndex++) {\r\n                for (let instrumentIndex: number = 0; instrumentIndex < song.channels[channelIndex].instruments.length; instrumentIndex++) {\r\n                    const instrument: Instrument = song.channels[channelIndex].instruments[instrumentIndex];\r\n                    const instrumentState: InstrumentState = this.channels[channelIndex].instruments[instrumentIndex];\r\n                    Synth.getInstrumentSynthFunction(instrument);\r\n                    instrument.LFOtime = 0;\r\n                    instrument.nextLFOtime = 0;\r\n                    instrument.arpTime = 0;\r\n                    instrument.tmpEqFilterStart = instrument.eqFilter;\r\n                    instrument.tmpEqFilterEnd = null;\r\n                    instrument.tmpNoteFilterStart = instrument.noteFilter;\r\n                    instrument.tmpNoteFilterEnd = null;\r\n                    instrumentState.updateWaves(instrument, this.samplesPerSecond);\r\n                    instrumentState.allocateNecessaryBuffers(this, instrument, samplesPerTick);\r\n                }\r\n\r\n            }\r\n        }\r\n        var dummyArray = new Float32Array(1);\r\n        this.isPlayingSong = true;\r\n        this.synthesize(dummyArray, dummyArray, 1, true);\r\n        this.isPlayingSong = false;\r\n    }\r\n\r\n    public computeLatestModValues(): void {\r\n\r\n        if (this.song != null && this.song.modChannelCount > 0) {\r\n\r\n            // Clear all mod values, and set up temp variables for the time a mod would be set at.\r\n            let latestModTimes: (number | null)[] = [];\r\n            let latestModInsTimes: (number | null)[][][] = [];\r\n            this.modValues = [];\r\n            this.nextModValues = [];\r\n            this.modInsValues = [];\r\n            this.nextModInsValues = [];\r\n            for (let channel: number = 0; channel < this.song.pitchChannelCount + this.song.noiseChannelCount; channel++) {\r\n                latestModInsTimes[channel] = [];\r\n                this.modInsValues[channel] = [];\r\n                this.nextModInsValues[channel] = [];\r\n\r\n                for (let instrument: number = 0; instrument < this.song.channels[channel].instruments.length; instrument++) {\r\n                    this.modInsValues[channel][instrument] = [];\r\n                    this.nextModInsValues[channel][instrument] = [];\r\n                    latestModInsTimes[channel][instrument] = [];\r\n                }\r\n            }\r\n\r\n            // Find out where we're at in the fraction of the current bar.\r\n            let currentPart: number = this.beat * Config.partsPerBeat + this.part;\r\n\r\n            // For mod channels, calculate last set value for each mod\r\n            for (let channelIndex: number = this.song.pitchChannelCount + this.song.noiseChannelCount; channelIndex < this.song.getChannelCount(); channelIndex++) {\r\n                if (!(this.song.channels[channelIndex].muted)) {\r\n\r\n                    let pattern: Pattern | null;\r\n\r\n                    for (let currentBar: number = this.bar; currentBar >= 0; currentBar--) {\r\n                        pattern = this.song.getPattern(channelIndex, currentBar);\r\n\r\n                        if (pattern != null) {\r\n                            let instrumentIdx: number = pattern.instruments[0];\r\n                            let instrument: Instrument = this.song.channels[channelIndex].instruments[instrumentIdx];\r\n                            let latestPinParts: number[] = [];\r\n                            let latestPinValues: number[] = [];\r\n\r\n                            let partsInBar: number = (currentBar == this.bar)\r\n                                ? currentPart\r\n                                : this.findPartsInBar(currentBar);\r\n\r\n                            for (const note of pattern.notes) {\r\n                                if (note.start < partsInBar && (latestPinParts[Config.modCount - 1 - note.pitches[0]] == null || note.end > latestPinParts[Config.modCount - 1 - note.pitches[0]])) {\r\n                                    if (note.end <= partsInBar) {\r\n                                        latestPinParts[Config.modCount - 1 - note.pitches[0]] = note.end;\r\n                                        latestPinValues[Config.modCount - 1 - note.pitches[0]] = note.pins[note.pins.length - 1].size;\r\n                                    }\r\n                                    else {\r\n                                        latestPinParts[Config.modCount - 1 - note.pitches[0]] = partsInBar;\r\n                                        // Find the pin where bar change happens, and compute where pin volume would be at that time\r\n                                        for (let pinIdx = 0; pinIdx < note.pins.length; pinIdx++) {\r\n                                            if (note.pins[pinIdx].time + note.start > partsInBar) {\r\n                                                const transitionLength: number = note.pins[pinIdx].time - note.pins[pinIdx - 1].time;\r\n                                                const toNextBarLength: number = partsInBar - note.start - note.pins[pinIdx - 1].time;\r\n                                                const deltaVolume: number = note.pins[pinIdx].size - note.pins[pinIdx - 1].size;\r\n\r\n                                                latestPinValues[Config.modCount - 1 - note.pitches[0]] = Math.round(note.pins[pinIdx - 1].size + deltaVolume * toNextBarLength / transitionLength);\r\n                                                pinIdx = note.pins.length;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            // Set modulator value, if it wasn't set in another pattern already scanned\r\n                            for (let mod: number = 0; mod < Config.modCount; mod++) {\r\n                                if (latestPinParts[mod] != null) {\r\n                                    if (Config.modulators[instrument.modulators[mod]].forSong) {\r\n                                        if (latestModTimes[instrument.modulators[mod]] == null || currentBar * Config.partsPerBeat * this.song.beatsPerBar + latestPinParts[mod] > (latestModTimes[instrument.modulators[mod]] as number)) {\r\n                                            this.setModValue(latestPinValues[mod], latestPinValues[mod], mod, instrument.modChannels[mod], instrument.modInstruments[mod], instrument.modulators[mod]);\r\n                                            latestModTimes[instrument.modulators[mod]] = currentBar * Config.partsPerBeat * this.song.beatsPerBar + latestPinParts[mod];\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        // Generate list of used instruments\r\n                                        let usedInstruments: number[] = [];\r\n                                        // All\r\n                                        if (instrument.modInstruments[mod] == this.song.channels[instrument.modChannels[mod]].instruments.length) {\r\n                                            for (let i: number = 0; i < this.song.channels[instrument.modChannels[mod]].instruments.length; i++) {\r\n                                                usedInstruments.push(i);\r\n                                            }\r\n                                        }\r\n                                        // Active\r\n                                        else if (instrument.modInstruments[mod] > this.song.channels[instrument.modChannels[mod]].instruments.length) {\r\n                                            const tgtPattern: Pattern | null = this.song.getPattern(instrument.modChannels[mod], currentBar);\r\n                                            if (tgtPattern != null)\r\n                                                usedInstruments = tgtPattern.instruments;\r\n                                        } else {\r\n                                            usedInstruments.push(instrument.modInstruments[mod]);\r\n                                        }\r\n                                        for (let instrumentIndex: number = 0; instrumentIndex < usedInstruments.length; instrumentIndex++) {\r\n                                            // Iterate through all used instruments by this modulator\r\n                                            // Special indices for mod filter targets, since they control multiple things.\r\n                                            const eqFilterParam: boolean = instrument.modulators[mod] == Config.modulators.dictionary[\"eq filter\"].index;\r\n                                            const noteFilterParam: boolean = instrument.modulators[mod] == Config.modulators.dictionary[\"note filter\"].index\r\n                                            let modulatorAdjust: number = instrument.modulators[mod];\r\n                                            if (eqFilterParam) {\r\n                                                modulatorAdjust = Config.modulators.length + instrument.modFilterTypes[mod];\r\n                                            } else if (noteFilterParam) {\r\n                                                // Skip all possible indices for eq filter\r\n                                                modulatorAdjust = Config.modulators.length + 1 + (2 * Config.filterMaxPoints) + instrument.modFilterTypes[mod];\r\n                                            }\r\n\r\n                                            if (latestModInsTimes[instrument.modChannels[mod]][usedInstruments[instrumentIndex]][modulatorAdjust] == null\r\n                                                || currentBar * Config.partsPerBeat * this.song.beatsPerBar + latestPinParts[mod] > latestModInsTimes[instrument.modChannels[mod]][usedInstruments[instrumentIndex]][modulatorAdjust]!) {\r\n\r\n                                                if (eqFilterParam) {\r\n                                                    let tgtInstrument: Instrument = this.song.channels[instrument.modChannels[mod]].instruments[usedInstruments[instrumentIndex]];\r\n                                                    if (instrument.modFilterTypes[mod] == 0) {\r\n                                                        tgtInstrument.tmpEqFilterStart = tgtInstrument.eqSubFilters[latestPinValues[mod]];\r\n                                                    } else {\r\n                                                        for (let i: number = 0; i < Config.filterMorphCount; i++) {\r\n                                                            if (tgtInstrument.tmpEqFilterStart == tgtInstrument.eqSubFilters[i]) {\r\n                                                                tgtInstrument.tmpEqFilterStart = new FilterSettings();\r\n                                                                tgtInstrument.tmpEqFilterStart.fromJsonObject(tgtInstrument.eqSubFilters[i]!.toJsonObject());\r\n                                                                i = Config.filterMorphCount;\r\n                                                            }\r\n                                                        }\r\n                                                        if (Math.floor((instrument.modFilterTypes[mod] - 1) / 2) < tgtInstrument.tmpEqFilterStart!.controlPointCount) {\r\n                                                            if (instrument.modFilterTypes[mod] % 2)\r\n                                                                tgtInstrument.tmpEqFilterStart!.controlPoints[Math.floor((instrument.modFilterTypes[mod] - 1) / 2)].freq = latestPinValues[mod];\r\n                                                            else\r\n                                                                tgtInstrument.tmpEqFilterStart!.controlPoints[Math.floor((instrument.modFilterTypes[mod] - 1) / 2)].gain = latestPinValues[mod];\r\n                                                        }\r\n                                                    }\r\n                                                    tgtInstrument.tmpEqFilterEnd = tgtInstrument.tmpEqFilterStart;\r\n                                                } else if (noteFilterParam) {\r\n                                                    let tgtInstrument: Instrument = this.song.channels[instrument.modChannels[mod]].instruments[usedInstruments[instrumentIndex]];\r\n                                                    if (instrument.modFilterTypes[mod] == 0) {\r\n                                                        tgtInstrument.tmpNoteFilterStart = tgtInstrument.noteSubFilters[latestPinValues[mod]];\r\n                                                    } else {\r\n                                                        for (let i: number = 0; i < Config.filterMorphCount; i++) {\r\n                                                            if (tgtInstrument.tmpNoteFilterStart == tgtInstrument.noteSubFilters[i]) {\r\n                                                                tgtInstrument.tmpNoteFilterStart = new FilterSettings();\r\n                                                                tgtInstrument.tmpNoteFilterStart.fromJsonObject(tgtInstrument.noteSubFilters[i]!.toJsonObject());\r\n                                                                i = Config.filterMorphCount;\r\n                                                            }\r\n                                                        }\r\n                                                        if (Math.floor((instrument.modFilterTypes[mod] - 1) / 2) < tgtInstrument.tmpNoteFilterStart!.controlPointCount) {\r\n                                                            if (instrument.modFilterTypes[mod] % 2)\r\n                                                                tgtInstrument.tmpNoteFilterStart!.controlPoints[Math.floor((instrument.modFilterTypes[mod] - 1) / 2)].freq = latestPinValues[mod];\r\n                                                            else\r\n                                                                tgtInstrument.tmpNoteFilterStart!.controlPoints[Math.floor((instrument.modFilterTypes[mod] - 1) / 2)].gain = latestPinValues[mod];\r\n                                                        }\r\n                                                    }\r\n                                                    tgtInstrument.tmpNoteFilterEnd = tgtInstrument.tmpNoteFilterStart;\r\n                                                }\r\n                                                else this.setModValue(latestPinValues[mod], latestPinValues[mod], mod, instrument.modChannels[mod], usedInstruments[instrumentIndex], modulatorAdjust);\r\n\r\n                                                latestModInsTimes[instrument.modChannels[mod]][usedInstruments[instrumentIndex]][modulatorAdjust] = currentBar * Config.partsPerBeat * this.song.beatsPerBar + latestPinParts[mod];\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Detects if a modulator is set, but not valid for the current effects/instrument type/filter type\r\n    // Note, setting 'none' or the intermediary steps when clicking to add a mod, like an unset channel/unset instrument, counts as valid.\r\n    // TODO: This kind of check is mirrored in SongEditor.ts' whenUpdated. Creates a lot of redundancy for adding new mods. Can be moved into new properties for mods, to avoid this later.\r\n    public determineInvalidModulators(instrument: Instrument): void {\r\n        if (this.song == null)\r\n            return;\r\n        for (let mod: number = 0; mod < Config.modCount; mod++) {\r\n            instrument.invalidModulators[mod] = true;\r\n            // For song modulator, valid if any setting used\r\n            if (instrument.modChannels[mod] == -1) {\r\n                if (instrument.modulators[mod] != 0)\r\n                    instrument.invalidModulators[mod] = false;\r\n                continue;\r\n            }\r\n            const channel: Channel | null = this.song.channels[instrument.modChannels[mod]];\r\n            if (channel == null) continue;\r\n            let tgtInstrumentList: Instrument[] = [];\r\n            if (instrument.modInstruments[mod] >= channel.instruments.length) { // All or active\r\n                tgtInstrumentList = channel.instruments;\r\n            } else {\r\n                tgtInstrumentList = [channel.instruments[instrument.modInstruments[mod]]];\r\n            }\r\n            for (let i: number = 0; i < tgtInstrumentList.length; i++) {\r\n                const tgtInstrument: Instrument | null = tgtInstrumentList[i];\r\n                if (tgtInstrument == null) continue;\r\n                const str: string = Config.modulators[instrument.modulators[mod]].name;\r\n                // Check effects\r\n                if (!((Config.modulators[instrument.modulators[mod]].associatedEffect != EffectType.length && !(tgtInstrument.effects & (1 << Config.modulators[instrument.modulators[mod]].associatedEffect)))\r\n                    // Instrument type specific\r\n                    || (tgtInstrument.type != InstrumentType.fm && (str == \"fm slider 1\" || str == \"fm slider 2\" || str == \"fm slider 3\" || str == \"fm slider 4\" || str == \"fm feedback\"))\r\n                    || (tgtInstrument.type != InstrumentType.pwm && (str == \"pulse width\"))\r\n                    // Arp check\r\n                    || (!tgtInstrument.getChord().arpeggiates && (str == \"arp speed\" || str == \"reset arp\"))\r\n                    // EQ Filter check\r\n                    || (tgtInstrument.eqFilterType && str == \"eq filter\")\r\n                    || (!tgtInstrument.eqFilterType && (str == \"eq filt cut\" || str == \"eq filt peak\"))\r\n                    || (str == \"eq filter\" && Math.floor((instrument.modFilterTypes[mod] + 1) / 2) > tgtInstrument.eqFilter.controlPointCount)\r\n                    // Note Filter check\r\n                    || (tgtInstrument.noteFilterType && str == \"note filter\")\r\n                    || (!tgtInstrument.noteFilterType && (str == \"note filt cut\" || str == \"note filt peak\"))\r\n                    || (str == \"note filter\" && Math.floor((instrument.modFilterTypes[mod] + 1) / 2) > tgtInstrument.noteFilter.controlPointCount))) {\r\n\r\n                    instrument.invalidModulators[mod] = false;\r\n                    i = tgtInstrumentList.length;\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    private static operatorAmplitudeCurve(amplitude: number): number {\r\n        return (Math.pow(16.0, amplitude / 15.0) - 1.0) / 15.0;\r\n    }\r\n\r\n    public samplesPerSecond: number = 44100;\r\n    public panningDelayBufferSize: number;\r\n    public panningDelayBufferMask: number;\r\n    public chorusDelayBufferSize: number;\r\n    public chorusDelayBufferMask: number;\r\n    // TODO: reverb\r\n\r\n    public song: Song | null = null;\r\n    public preferLowerLatency: boolean = false; // enable when recording performances from keyboard or MIDI. Takes effect next time you activate audio.\r\n    public anticipatePoorPerformance: boolean = false; // enable on mobile devices to reduce audio stutter glitches. Takes effect next time you activate audio.\r\n    public liveInputDuration: number = 0;\r\n    public liveInputStarted: boolean = false;\r\n    public liveInputPitches: number[] = [];\r\n    public liveInputChannel: number = 0;\r\n    public liveInputInstruments: number[] = [];\r\n    public loopRepeatCount: number = -1;\r\n    public volume: number = 1.0;\r\n    public enableMetronome: boolean = false;\r\n    public countInMetronome: boolean = false;\r\n    public renderingSong: boolean = false;\r\n\r\n    private wantToSkip: boolean = false;\r\n    private playheadInternal: number = 0.0;\r\n    private bar: number = 0;\r\n    private prevBar: number | null = null;\r\n    private nextBar: number | null = null;\r\n    private beat: number = 0;\r\n    private part: number = 0;\r\n    private tick: number = 0;\r\n    public isAtStartOfTick: boolean = true;\r\n    public isAtEndOfTick: boolean = true;\r\n    public tickSampleCountdown: number = 0;\r\n    private modValues: (number | null)[] = [];\r\n    private modInsValues: (number | null)[][][] = [];\r\n    private nextModValues: (number | null)[] = [];\r\n    private nextModInsValues: (number | null)[][][] = [];\r\n    private isPlayingSong: boolean = false;\r\n    private isRecording: boolean = false;\r\n    private liveInputEndTime: number = 0.0;\r\n    private browserAutomaticallyClearsAudioBuffer: boolean = true; // Assume true until proven otherwise. Older Chrome does not clear the buffer so it needs to be cleared manually.\r\n\r\n    public static readonly tempFilterStartCoefficients: FilterCoefficients = new FilterCoefficients();\r\n    public static readonly tempFilterEndCoefficients: FilterCoefficients = new FilterCoefficients();\r\n    private tempDrumSetControlPoint: FilterControlPoint = new FilterControlPoint();\r\n    public tempFrequencyResponse: FrequencyResponse = new FrequencyResponse();\r\n\r\n    private static readonly fmSynthFunctionCache: Dictionary<Function> = {};\r\n    private static readonly effectsFunctionCache: Function[] = Array(1 << 7).fill(undefined); // keep in sync with the number of post-process effects.\r\n    private static readonly pickedStringFunctionCache: Function[] = Array(3).fill(undefined); // keep in sync with the number of unison voices.\r\n\r\n    private readonly channels: ChannelState[] = [];\r\n    private readonly tonePool: Deque<Tone> = new Deque<Tone>();\r\n    private readonly tempMatchedPitchTones: Array<Tone | null> = Array(Config.maxChordSize).fill(null);\r\n\r\n    private startedMetronome: boolean = false;\r\n    private metronomeSamplesRemaining: number = -1;\r\n    private metronomeAmplitude: number = 0.0;\r\n    private metronomePrevAmplitude: number = 0.0;\r\n    private metronomeFilter: number = 0.0;\r\n    private limit: number = 0.0;\r\n\r\n    private tempMonoInstrumentSampleBuffer: Float32Array | null = null;\r\n\r\n    private audioCtx: any | null = null;\r\n    private scriptNode: any | null = null;\r\n\r\n    public get playing(): boolean {\r\n        return this.isPlayingSong;\r\n    }\r\n\r\n    public get recording(): boolean {\r\n        return this.isRecording;\r\n    }\r\n\r\n    public get playhead(): number {\r\n        return this.playheadInternal;\r\n    }\r\n\r\n    public set playhead(value: number) {\r\n        if (this.song != null) {\r\n            this.playheadInternal = Math.max(0, Math.min(this.song.barCount, value));\r\n            let remainder: number = this.playheadInternal;\r\n            this.bar = Math.floor(remainder);\r\n            remainder = this.song.beatsPerBar * (remainder - this.bar);\r\n            this.beat = Math.floor(remainder);\r\n            remainder = Config.partsPerBeat * (remainder - this.beat);\r\n            this.part = Math.floor(remainder);\r\n            remainder = Config.ticksPerPart * (remainder - this.part);\r\n            this.tick = Math.floor(remainder);\r\n            this.tickSampleCountdown = 0;\r\n            this.isAtStartOfTick = true;\r\n            this.prevBar = null;\r\n        }\r\n    }\r\n\r\n    public getSamplesPerBar(): number {\r\n        if (this.song == null) throw new Error();\r\n        return this.getSamplesPerTick() * Config.ticksPerPart * Config.partsPerBeat * this.song.beatsPerBar;\r\n    }\r\n\r\n    public getTicksIntoBar(): number {\r\n        return (this.beat * Config.partsPerBeat + this.part) * Config.ticksPerPart + this.tick;\r\n    }\r\n    public getCurrentPart(): number {\r\n        return (this.beat * Config.partsPerBeat + this.part);\r\n    }\r\n\r\n    private findPartsInBar(bar: number): number {\r\n        if (this.song == null) return 0;\r\n        let partsInBar: number = Config.partsPerBeat * this.song.beatsPerBar;\r\n        for (let channel: number = this.song.pitchChannelCount + this.song.noiseChannelCount; channel < this.song.getChannelCount(); channel++) {\r\n            let pattern: Pattern | null = this.song.getPattern(channel, bar);\r\n            if (pattern != null) {\r\n                let instrument: Instrument = this.song.channels[channel].instruments[pattern.instruments[0]];\r\n                for (let mod: number = 0; mod < Config.modCount; mod++) {\r\n                    if (instrument.modulators[mod] == Config.modulators.dictionary[\"next bar\"].index) {\r\n                        for (const note of pattern.notes) {\r\n                            if (note.pitches[0] == (Config.modCount - 1 - mod)) {\r\n                                // Find the earliest next bar note.\r\n                                if (partsInBar > note.start)\r\n                                    partsInBar = note.start;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return partsInBar;\r\n    }\r\n\r\n    // Returns the total samples in the song\r\n    public getTotalSamples(enableIntro: boolean, enableOutro: boolean, loop: number): number {\r\n        if (this.song == null)\r\n            return -1;\r\n\r\n        // Compute the window to be checked (start bar to end bar)\r\n        let startBar: number = enableIntro ? 0 : this.song.loopStart;\r\n        let endBar: number = enableOutro ? this.song.barCount : (this.song.loopStart + this.song.loopLength);\r\n        let hasTempoMods: boolean = false;\r\n        let hasNextBarMods: boolean = false;\r\n        let prevTempo: number = this.song.tempo;\r\n\r\n        // Determine if any tempo or next bar mods happen anywhere in the window\r\n        for (let channel: number = this.song.pitchChannelCount + this.song.noiseChannelCount; channel < this.song.getChannelCount(); channel++) {\r\n            for (let bar: number = startBar; bar < endBar; bar++) {\r\n                let pattern: Pattern | null = this.song.getPattern(channel, bar);\r\n                if (pattern != null) {\r\n                    let instrument: Instrument = this.song.channels[channel].instruments[pattern.instruments[0]];\r\n                    for (let mod: number = 0; mod < Config.modCount; mod++) {\r\n                        if (instrument.modulators[mod] == Config.modulators.dictionary[\"tempo\"].index) {\r\n                            hasTempoMods = true;\r\n                        }\r\n                        if (instrument.modulators[mod] == Config.modulators.dictionary[\"next bar\"].index) {\r\n                            hasNextBarMods = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // If intro is not zero length, determine what the \"entry\" tempo is going into the start part, by looking at mods that came before...\r\n        if (startBar > 0) {\r\n            let latestTempoPin: number | null = null;\r\n            let latestTempoValue: number = 0;\r\n\r\n            for (let bar: number = startBar - 1; bar >= 0; bar--) {\r\n                for (let channel: number = this.song.pitchChannelCount + this.song.noiseChannelCount; channel < this.song.getChannelCount(); channel++) {\r\n                    let pattern = this.song.getPattern(channel, bar);\r\n\r\n                    if (pattern != null) {\r\n                        let instrumentIdx: number = pattern.instruments[0];\r\n                        let instrument: Instrument = this.song.channels[channel].instruments[instrumentIdx];\r\n\r\n                        let partsInBar: number = this.findPartsInBar(bar);\r\n\r\n                        for (const note of pattern.notes) {\r\n                            if (instrument.modulators[Config.modCount - 1 - note.pitches[0]] == Config.modulators.dictionary[\"tempo\"].index) {\r\n                                if (note.start < partsInBar && (latestTempoPin == null || note.end > latestTempoPin)) {\r\n                                    if (note.end <= partsInBar) {\r\n                                        latestTempoPin = note.end;\r\n                                        latestTempoValue = note.pins[note.pins.length - 1].size;\r\n                                    }\r\n                                    else {\r\n                                        latestTempoPin = partsInBar;\r\n                                        // Find the pin where bar change happens, and compute where pin volume would be at that time\r\n                                        for (let pinIdx = 0; pinIdx < note.pins.length; pinIdx++) {\r\n                                            if (note.pins[pinIdx].time + note.start > partsInBar) {\r\n                                                const transitionLength: number = note.pins[pinIdx].time - note.pins[pinIdx - 1].time;\r\n                                                const toNextBarLength: number = partsInBar - note.start - note.pins[pinIdx - 1].time;\r\n                                                const deltaVolume: number = note.pins[pinIdx].size - note.pins[pinIdx - 1].size;\r\n\r\n                                                latestTempoValue = Math.round(note.pins[pinIdx - 1].size + deltaVolume * toNextBarLength / transitionLength);\r\n                                                pinIdx = note.pins.length;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Done once you process a pattern where tempo mods happened, since the search happens backward\r\n                if (latestTempoPin != null) {\r\n                    prevTempo = latestTempoValue + Config.modulators.dictionary[\"tempo\"].convertRealFactor;\r\n                    bar = -1;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (hasTempoMods || hasNextBarMods) {\r\n            // Run from start bar to end bar and observe looping, computing average tempo across each bar\r\n            let bar: number = startBar;\r\n            let ended: boolean = false;\r\n            let totalSamples: number = 0;\r\n\r\n            while (!ended) {\r\n                // Compute the subsection of the pattern that will play\r\n                let partsInBar: number = Config.partsPerBeat * this.song.beatsPerBar;\r\n                let currentPart: number = 0;\r\n\r\n                if (hasNextBarMods) {\r\n                    partsInBar = this.findPartsInBar(bar);\r\n                }\r\n\r\n                // Compute average tempo in this tick window, or use last tempo if nothing happened\r\n                if (hasTempoMods) {\r\n                    let foundMod: boolean = false;\r\n                    for (let channel: number = this.song.pitchChannelCount + this.song.noiseChannelCount; channel < this.song.getChannelCount(); channel++) {\r\n                        if (foundMod == false) {\r\n                            let pattern: Pattern | null = this.song.getPattern(channel, bar);\r\n                            if (pattern != null) {\r\n                                let instrument: Instrument = this.song.channels[channel].instruments[pattern.instruments[0]];\r\n                                for (let mod: number = 0; mod < Config.modCount; mod++) {\r\n                                    if (foundMod == false && instrument.modulators[mod] == Config.modulators.dictionary[\"tempo\"].index\r\n                                        && pattern.notes.find(n => n.pitches[0] == (Config.modCount - 1 - mod))) {\r\n                                        // Only the first tempo mod instrument for this bar will be checked (well, the first with a note in this bar).\r\n                                        foundMod = true;\r\n                                        // Need to re-sort the notes by start time to make the next part much less painful.\r\n                                        pattern.notes.sort(function (a, b) { return (a.start == b.start) ? a.pitches[0] - b.pitches[0] : a.start - b.start; });\r\n                                        for (const note of pattern.notes) {\r\n                                            if (note.pitches[0] == (Config.modCount - 1 - mod)) {\r\n                                                // Compute samples up to this note\r\n                                                totalSamples += (Math.min(partsInBar - currentPart, note.start - currentPart)) * Config.ticksPerPart * this.getSamplesPerTickSpecificBPM(prevTempo);\r\n\r\n                                                if (note.start < partsInBar) {\r\n                                                    for (let pinIdx: number = 1; pinIdx < note.pins.length; pinIdx++) {\r\n                                                        // Compute samples up to this pin\r\n                                                        if (note.pins[pinIdx - 1].time + note.start <= partsInBar) {\r\n                                                            const tickLength: number = Config.ticksPerPart * Math.min(partsInBar - (note.start + note.pins[pinIdx - 1].time), note.pins[pinIdx].time - note.pins[pinIdx - 1].time);\r\n                                                            const prevPinTempo: number = note.pins[pinIdx - 1].size + Config.modulators.dictionary[\"tempo\"].convertRealFactor;\r\n                                                            let currPinTempo: number = note.pins[pinIdx].size + Config.modulators.dictionary[\"tempo\"].convertRealFactor;\r\n                                                            if (note.pins[pinIdx].time + note.start > partsInBar) {\r\n                                                                // Compute an intermediary tempo since bar changed over mid-pin. Maybe I'm deep in \"what if\" territory now!\r\n                                                                currPinTempo = note.pins[pinIdx - 1].size + (note.pins[pinIdx].size - note.pins[pinIdx - 1].size) * (partsInBar - (note.start + note.pins[pinIdx - 1].time)) / (note.pins[pinIdx].time - note.pins[pinIdx - 1].time) + Config.modulators.dictionary[\"tempo\"].convertRealFactor;\r\n                                                            }\r\n                                                            let bpmScalar: number = Config.partsPerBeat * Config.ticksPerPart / 60;\r\n\r\n                                                            if (currPinTempo != prevPinTempo) {\r\n\r\n                                                                // Definite integral of SamplesPerTick w/r/t beats to find total samples from start point to end point for a variable tempo\r\n                                                                // The starting formula is\r\n                                                                // SamplesPerTick = SamplesPerSec / ((PartsPerBeat * TicksPerPart) / SecPerMin) * BeatsPerMin )\r\n                                                                //\r\n                                                                // This is an expression of samples per tick \"instantaneously\", and it can be multiplied by a number of ticks to get a sample count.\r\n                                                                // But this isn't the full story. BeatsPerMin, e.g. tempo, changes throughout the interval so it has to be expressed in terms of ticks, \"t\"\r\n                                                                // ( Also from now on PartsPerBeat, TicksPerPart, and SecPerMin are combined into one scalar, called \"BPMScalar\" )\r\n                                                                // Substituting BPM for a step variable that moves with respect to the current tick, we get\r\n                                                                // SamplesPerTick = SamplesPerSec / (BPMScalar * ( (EndTempo - StartTempo / TickLength) * t + StartTempo ) )\r\n                                                                //\r\n                                                                // When this equation is integrated from 0 to TickLength with respect to t, we get the following expression:\r\n                                                                //   Samples = - SamplesPerSec * TickLength * ( log( BPMScalar * EndTempo * TickLength ) - log( BPMScalar * StartTempo * TickLength ) ) / BPMScalar * ( StartTempo - EndTempo )\r\n\r\n                                                                totalSamples += - this.samplesPerSecond * tickLength * (Math.log(bpmScalar * currPinTempo * tickLength) - Math.log(bpmScalar * prevPinTempo * tickLength)) / (bpmScalar * (prevPinTempo - currPinTempo));\r\n\r\n                                                            }\r\n                                                            else {\r\n\r\n                                                                // No tempo change between the two pins.\r\n                                                                totalSamples += tickLength * this.getSamplesPerTickSpecificBPM(currPinTempo);\r\n\r\n                                                            }\r\n                                                            prevTempo = currPinTempo;\r\n                                                        }\r\n                                                        currentPart = Math.min(note.start + note.pins[pinIdx].time, partsInBar);\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Compute samples for the rest of the bar\r\n                totalSamples += (partsInBar - currentPart) * Config.ticksPerPart * this.getSamplesPerTickSpecificBPM(prevTempo);\r\n\r\n                bar++;\r\n                if (loop != 0 && bar == this.song.loopStart + this.song.loopLength) {\r\n                    bar = this.song.loopStart;\r\n                    if (loop > 0) loop--;\r\n                }\r\n                if (bar >= endBar) {\r\n                    ended = true;\r\n                }\r\n            }\r\n\r\n            return Math.ceil(totalSamples);\r\n        }\r\n        else {\r\n            // No tempo or next bar mods... phew! Just calculate normally.\r\n            return this.getSamplesPerBar() * this.getTotalBars(enableIntro, enableOutro, loop);\r\n        }\r\n    }\r\n\r\n    public getTotalBars(enableIntro: boolean, enableOutro: boolean, useLoopCount: number = this.loopRepeatCount): number {\r\n        if (this.song == null) throw new Error();\r\n        let bars: number = this.song.loopLength * (useLoopCount + 1);\r\n        if (enableIntro) bars += this.song.loopStart;\r\n        if (enableOutro) bars += this.song.barCount - (this.song.loopStart + this.song.loopLength);\r\n        return bars;\r\n    }\r\n\r\n    constructor(song: Song | string | null = null) {\r\n        this.computeDelayBufferSizes();\r\n        if (song != null) this.setSong(song);\r\n    }\r\n\r\n    public setSong(song: Song | string): void {\r\n        if (typeof (song) == \"string\") {\r\n            this.song = new Song(song);\r\n        } else if (song instanceof Song) {\r\n            this.song = song;\r\n        }\r\n        this.prevBar = null;\r\n    }\r\n\r\n    private computeDelayBufferSizes(): void {\r\n        this.panningDelayBufferSize = Synth.fittingPowerOfTwo(this.samplesPerSecond * Config.panDelaySecondsMax);\r\n        this.panningDelayBufferMask = this.panningDelayBufferSize - 1;\r\n        this.chorusDelayBufferSize = Synth.fittingPowerOfTwo(this.samplesPerSecond * Config.chorusMaxDelay);\r\n        this.chorusDelayBufferMask = this.chorusDelayBufferSize - 1;\r\n    }\r\n\r\n    private activateAudio(): void {\r\n        const bufferSize: number = this.anticipatePoorPerformance ? (this.preferLowerLatency ? 2048 : 4096) : (this.preferLowerLatency ? 512 : 2048);\r\n        if (this.audioCtx == null || this.scriptNode == null || this.scriptNode.bufferSize != bufferSize) {\r\n            if (this.scriptNode != null) this.deactivateAudio();\r\n            const latencyHint: string = this.anticipatePoorPerformance ? (this.preferLowerLatency ? \"balanced\" : \"playback\") : (this.preferLowerLatency ? \"interactive\" : \"balanced\");\r\n            this.audioCtx = this.audioCtx || new (window.AudioContext || window.webkitAudioContext)({ latencyHint: latencyHint });\r\n            this.samplesPerSecond = this.audioCtx.sampleRate;\r\n            this.scriptNode = this.audioCtx.createScriptProcessor ? this.audioCtx.createScriptProcessor(bufferSize, 0, 2) : this.audioCtx.createJavaScriptNode(bufferSize, 0, 2); // bufferSize samples per callback buffer, 0 input channels, 2 output channels (left/right)\r\n            this.scriptNode.onaudioprocess = this.audioProcessCallback;\r\n            this.scriptNode.channelCountMode = 'explicit';\r\n            this.scriptNode.channelInterpretation = 'speakers';\r\n            this.scriptNode.connect(this.audioCtx.destination);\r\n\r\n            this.computeDelayBufferSizes();\r\n        }\r\n        this.audioCtx.resume();\r\n    }\r\n\r\n    private deactivateAudio(): void {\r\n        if (this.audioCtx != null && this.scriptNode != null) {\r\n            this.scriptNode.disconnect(this.audioCtx.destination);\r\n            this.scriptNode = null;\r\n            if (this.audioCtx.close) this.audioCtx.close(); // firefox is missing this function?\r\n            this.audioCtx = null;\r\n        }\r\n    }\r\n\r\n    public maintainLiveInput(): void {\r\n        this.activateAudio();\r\n        this.liveInputEndTime = performance.now() + 10000.0;\r\n    }\r\n\r\n    public play(): void {\r\n        if (this.isPlayingSong) return;\r\n        this.computeLatestModValues();\r\n        this.warmUpSynthesizer(this.song);\r\n        this.isPlayingSong = true;\r\n        this.activateAudio();\r\n    }\r\n\r\n    public pause(): void {\r\n        if (!this.isPlayingSong) return;\r\n        this.isPlayingSong = false;\r\n        this.isRecording = false;\r\n        this.modValues = [];\r\n        this.nextModValues = [];\r\n        if (this.song != null) {\r\n            this.song.inVolumeCap = 0.0;\r\n            this.song.outVolumeCap = 0.0;\r\n            for (let channelIndex: number = 0; channelIndex < this.song.pitchChannelCount + this.song.noiseChannelCount; channelIndex++) {\r\n                this.modInsValues[channelIndex] = [];\r\n                this.nextModInsValues[channelIndex] = [];\r\n            }\r\n        }\r\n    }\r\n\r\n    public startRecording(): void {\r\n        this.preferLowerLatency = true;\r\n        this.isRecording = true;\r\n        this.play();\r\n    }\r\n\r\n    public resetEffects(): void {\r\n        this.limit = 0.0;\r\n        this.freeAllTones();\r\n        if (this.song != null) {\r\n            for (const channelState of this.channels) {\r\n                for (const instrumentState of channelState.instruments) {\r\n                    instrumentState.resetAllEffects();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public setModValue(volumeStart: number, volumeEnd: number, mod: number, channelIndex: number, instrumentIndex: number, setting: number): number {\r\n        let val: number = volumeStart + Config.modulators[setting].convertRealFactor;\r\n        let nextVal: number = volumeEnd + Config.modulators[setting].convertRealFactor;\r\n        if (Config.modulators[setting].forSong) {\r\n            if (this.modValues[setting] == null || this.modValues[setting] != val || this.nextModValues[setting] != nextVal) {\r\n                this.modValues[setting] = val;\r\n                this.nextModValues[setting] = nextVal;\r\n            }\r\n        } else {\r\n            if (this.modInsValues[channelIndex][instrumentIndex][setting] == null\r\n                || this.modInsValues[channelIndex][instrumentIndex][setting] != val\r\n                || this.nextModInsValues[channelIndex][instrumentIndex][setting] != nextVal) {\r\n                this.modInsValues[channelIndex][instrumentIndex][setting] = val;\r\n                this.nextModInsValues[channelIndex][instrumentIndex][setting] = nextVal;\r\n            }\r\n        }\r\n\r\n        return val;\r\n    }\r\n\r\n    public getModValue(setting: number, channel?: number | null, instrument?: number | null, nextVal?: boolean): number {\r\n        const forSong: boolean = Config.modulators[setting].forSong;\r\n        if (forSong) {\r\n            if (this.modValues[setting] != null && this.nextModValues[setting] != null) {\r\n                return nextVal ? this.nextModValues[setting]! : this.modValues[setting]!;\r\n            }\r\n        } else if (channel != undefined && instrument != undefined) {\r\n            if (this.modInsValues[channel][instrument][setting] != null && this.nextModInsValues[channel][instrument][setting] != null) {\r\n                return nextVal ? this.nextModInsValues[channel][instrument][setting]! : this.modInsValues[channel][instrument][setting]!;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    // Checks if any mod is active for the given channel/instrument OR if any mod is active for the song scope. Could split the logic if needed later.\r\n    public isAnyModActive(channel: number, instrument: number): boolean {\r\n        for (let setting: number = 0; setting < Config.modulators.length; setting++) {\r\n            if ((this.modValues != undefined && this.modValues[setting] != null)\r\n                || (this.modInsValues != undefined && this.modInsValues[channel] != undefined && this.modInsValues[channel][instrument] != undefined && this.modInsValues[channel][instrument][setting] != null)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public unsetMod(setting: number, channel?: number, instrument?: number) {\r\n        if (this.isModActive(setting) || (channel != undefined && instrument != undefined && this.isModActive(setting, channel, instrument))) {\r\n            this.modValues[setting] = null;\r\n            this.nextModValues[setting] = null;\r\n            if (channel != undefined && instrument != undefined) {\r\n                this.modInsValues[channel][instrument][setting] = null;\r\n                this.nextModInsValues[channel][instrument][setting] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public isFilterModActive(forNoteFilter: boolean, channelIdx: number, instrumentIdx: number) {\r\n        const instrument: Instrument = this.song!.channels[channelIdx].instruments[instrumentIdx];\r\n\r\n        if (forNoteFilter) {\r\n            if (instrument.noteFilterType)\r\n                return false;\r\n            if (instrument.tmpNoteFilterEnd != null)\r\n                return true;\r\n        }\r\n        else {\r\n            if (instrument.eqFilterType)\r\n                return false;\r\n            if (instrument.tmpEqFilterEnd != null)\r\n                return true;\r\n        }\r\n        return false\r\n    }\r\n\r\n    public isModActive(setting: number, channel?: number, instrument?: number): boolean {\r\n        const forSong: boolean = Config.modulators[setting].forSong;\r\n        if (forSong) {\r\n            return (this.modValues != undefined && this.modValues[setting] != null);\r\n        } else if (channel != undefined && instrument != undefined && this.modInsValues != undefined && this.modInsValues[channel] != null && this.modInsValues[channel][instrument] != null) {\r\n            return (this.modInsValues[channel][instrument][setting] != null);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public snapToStart(): void {\r\n        this.bar = 0;\r\n        this.resetEffects();\r\n        this.snapToBar();\r\n    }\r\n\r\n    public goToBar(bar: number): void {\r\n        this.bar = bar;\r\n        this.resetEffects();\r\n        this.playheadInternal = this.bar;\r\n    }\r\n\r\n    public snapToBar(): void {\r\n        this.playheadInternal = this.bar;\r\n        this.beat = 0;\r\n        this.part = 0;\r\n        this.tick = 0;\r\n        this.tickSampleCountdown = 0;\r\n    }\r\n\r\n    public jumpIntoLoop(): void {\r\n        if (!this.song) return;\r\n        if (this.bar < this.song.loopStart || this.bar >= this.song.loopStart + this.song.loopLength) {\r\n            const oldBar: number = this.bar;\r\n            this.bar = this.song.loopStart;\r\n            this.playheadInternal += this.bar - oldBar;\r\n\r\n            if (this.playing)\r\n                this.computeLatestModValues();\r\n        }\r\n    }\r\n\r\n    public goToNextBar(): void {\r\n        if (!this.song) return;\r\n        this.prevBar = this.bar;\r\n        const oldBar: number = this.bar;\r\n        this.bar++;\r\n        if (this.bar >= this.song.barCount) {\r\n            this.bar = 0;\r\n        }\r\n        this.playheadInternal += this.bar - oldBar;\r\n\r\n        if (this.playing)\r\n            this.computeLatestModValues();\r\n    }\r\n\r\n    public goToPrevBar(): void {\r\n        if (!this.song) return;\r\n        this.prevBar = null;\r\n        const oldBar: number = this.bar;\r\n        this.bar--;\r\n        if (this.bar < 0 || this.bar >= this.song.barCount) {\r\n            this.bar = this.song.barCount - 1;\r\n        }\r\n        this.playheadInternal += this.bar - oldBar;\r\n\r\n        if (this.playing)\r\n            this.computeLatestModValues();\r\n    }\r\n\r\n    private getNextBar(): number {\r\n        let nextBar: number = this.bar + 1;\r\n        if (this.isRecording) {\r\n            if (nextBar >= this.song!.barCount) {\r\n                nextBar = this.song!.barCount - 1;\r\n            }\r\n        } else if (this.loopRepeatCount != 0 && nextBar == this.song!.loopStart + this.song!.loopLength) {\r\n            nextBar = this.song!.loopStart;\r\n        }\r\n        return nextBar;\r\n    }\r\n\r\n    public skipBar(): void {\r\n        if (!this.song) return;\r\n        const samplesPerTick: number = this.getSamplesPerTick();\r\n        this.bar++;\r\n        this.beat = 0;\r\n        this.part = 0;\r\n        this.tick = 0;\r\n        this.tickSampleCountdown = samplesPerTick;\r\n        this.isAtStartOfTick = true;\r\n\r\n        if (this.loopRepeatCount != 0 && this.bar == this.song.loopStart + this.song.loopLength) {\r\n            this.bar = this.song.loopStart;\r\n            if (this.loopRepeatCount > 0) this.loopRepeatCount--;\r\n        }\r\n\r\n    }\r\n\r\n    private audioProcessCallback = (audioProcessingEvent: any): void => {\r\n        const outputBuffer = audioProcessingEvent.outputBuffer;\r\n        const outputDataL: Float32Array = outputBuffer.getChannelData(0);\r\n        const outputDataR: Float32Array = outputBuffer.getChannelData(1);\r\n\r\n        if (this.browserAutomaticallyClearsAudioBuffer && (outputDataL[0] != 0.0 || outputDataR[0] != 0.0 || outputDataL[outputBuffer.length - 1] != 0.0 || outputDataR[outputBuffer.length - 1] != 0.0)) {\r\n            // If the buffer is ever initially nonzero, then this must be an older browser that doesn't automatically clear the audio buffer.\r\n            this.browserAutomaticallyClearsAudioBuffer = false;\r\n        }\r\n        if (!this.browserAutomaticallyClearsAudioBuffer) {\r\n            // If this browser does not clear the buffer automatically, do so manually before continuing.\r\n            const length: number = outputBuffer.length;\r\n            for (let i: number = 0; i < length; i++) {\r\n                outputDataL[i] = 0.0;\r\n                outputDataR[i] = 0.0;\r\n            }\r\n        }\r\n\r\n        if (!this.isPlayingSong && performance.now() >= this.liveInputEndTime) {\r\n            this.deactivateAudio();\r\n        } else {\r\n            this.synthesize(outputDataL, outputDataR, outputBuffer.length, this.isPlayingSong);\r\n        }\r\n    }\r\n\r\n    public synthesize(outputDataL: Float32Array, outputDataR: Float32Array, outputBufferLength: number, playSong: boolean = true): void {\r\n        if (this.song == null) {\r\n            for (let i: number = 0; i < outputBufferLength; i++) {\r\n                outputDataL[i] = 0.0;\r\n                outputDataR[i] = 0.0;\r\n            }\r\n            this.deactivateAudio();\r\n            return;\r\n        }\r\n\r\n        const song: Song = this.song;\r\n        this.song.inVolumeCap = 0.0 // Reset volume cap for this run\r\n        this.song.outVolumeCap = 0.0;\r\n\r\n        let samplesPerTick: number = this.getSamplesPerTick();\r\n        let ended: boolean = false;\r\n\r\n        // Check the bounds of the playhead:\r\n        if (this.tickSampleCountdown <= 0 || this.tickSampleCountdown > samplesPerTick) {\r\n            this.tickSampleCountdown = samplesPerTick;\r\n            this.isAtStartOfTick = true;\r\n        }\r\n        if (playSong) {\r\n            if (this.beat >= song.beatsPerBar) {\r\n                this.beat = 0;\r\n                this.part = 0;\r\n                this.tick = 0;\r\n                this.tickSampleCountdown = samplesPerTick;\r\n                this.isAtStartOfTick = true;\r\n\r\n                this.prevBar = this.bar;\r\n                this.bar = this.getNextBar();\r\n                if (this.bar <= this.prevBar && this.loopRepeatCount > 0) this.loopRepeatCount--;\r\n\r\n            }\r\n            if (this.bar >= song.barCount) {\r\n                this.bar = 0;\r\n                if (this.loopRepeatCount != -1) {\r\n                    ended = true;\r\n                    this.pause();\r\n                }\r\n            }\r\n        }\r\n\r\n        //const synthStartTime: number = performance.now();\r\n\r\n        this.syncSongState();\r\n\r\n        if (this.tempMonoInstrumentSampleBuffer == null || this.tempMonoInstrumentSampleBuffer.length < outputBufferLength) {\r\n            this.tempMonoInstrumentSampleBuffer = new Float32Array(outputBufferLength);\r\n        }\r\n\r\n        // Post processing parameters:\r\n        const volume: number = +this.volume;\r\n        const limitDecay: number = 1.0 - Math.pow(0.5, 4.0 / this.samplesPerSecond);\r\n        const limitRise: number = 1.0 - Math.pow(0.5, 4000.0 / this.samplesPerSecond);\r\n        let limit: number = +this.limit;\r\n        let skippedBars: number[] = [];\r\n        let firstSkippedBufferIndex: number = -1;\r\n\r\n        let bufferIndex: number = 0;\r\n        while (bufferIndex < outputBufferLength && !ended) {\r\n\r\n            this.nextBar = this.getNextBar();\r\n            if (this.nextBar >= song.barCount) this.nextBar = null;\r\n\r\n            const samplesLeftInBuffer: number = outputBufferLength - bufferIndex;\r\n            const samplesLeftInTick: number = Math.ceil(this.tickSampleCountdown);\r\n            const runLength: number = Math.min(samplesLeftInTick, samplesLeftInBuffer);\r\n            const runEnd: number = bufferIndex + runLength;\r\n\r\n            // Handle mod synth\r\n            if (this.isPlayingSong || this.renderingSong) {\r\n                for (let channelIndex: number = song.pitchChannelCount + song.noiseChannelCount; channelIndex < song.getChannelCount(); channelIndex++) {\r\n                    const channel: Channel = song.channels[channelIndex];\r\n                    const channelState: ChannelState = this.channels[channelIndex];\r\n\r\n                    this.determineCurrentActiveTones(song, channelIndex, samplesPerTick, playSong);\r\n\r\n                    for (let instrumentIndex: number = 0; instrumentIndex < channel.instruments.length; instrumentIndex++) {\r\n                        const instrumentState: InstrumentState = channelState.instruments[instrumentIndex];\r\n\r\n                        for (let i: number = 0; i < instrumentState.activeModTones.count(); i++) {\r\n                            const tone: Tone = instrumentState.activeModTones.get(i);\r\n                            this.playModTone(song, channelIndex, samplesPerTick, bufferIndex, runLength, tone, false, false);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Handle next bar mods if they were set\r\n            if (this.wantToSkip) {\r\n                // Unable to continue, as we have skipped back to a previously visited bar without generating new samples, which means we are infinitely skipping.\r\n                // In this case processing will return before the designated number of samples are processed. In other words, silence will be generated.\r\n                let barVisited: boolean = skippedBars.includes(this.bar);\r\n                if (barVisited && bufferIndex == firstSkippedBufferIndex)\r\n                    return;\r\n                if (firstSkippedBufferIndex == -1) {\r\n                    firstSkippedBufferIndex = bufferIndex;\r\n                }\r\n                if (!barVisited)\r\n                    skippedBars.push(this.bar);\r\n\r\n                this.wantToSkip = false;\r\n                this.skipBar();\r\n                continue;\r\n            }\r\n\r\n            for (let channelIndex: number = 0; channelIndex < song.pitchChannelCount + song.noiseChannelCount; channelIndex++) {\r\n                const channel: Channel = song.channels[channelIndex];\r\n                const channelState: ChannelState = this.channels[channelIndex];\r\n\r\n                if (this.isAtStartOfTick) {\r\n                    this.determineCurrentActiveTones(song, channelIndex, samplesPerTick, playSong && !this.countInMetronome);\r\n                    this.determineLiveInputTones(song, channelIndex, samplesPerTick);\r\n                }\r\n                for (let instrumentIndex: number = 0; instrumentIndex < channel.instruments.length; instrumentIndex++) {\r\n                    const instrument: Instrument = channel.instruments[instrumentIndex];\r\n                    const instrumentState: InstrumentState = channelState.instruments[instrumentIndex];\r\n\r\n                    if (this.isAtStartOfTick) {\r\n                        let tonesPlayedInThisInstrument: number = instrumentState.activeTones.count() + instrumentState.liveInputTones.count();\r\n\r\n                        for (let i: number = 0; i < instrumentState.releasedTones.count(); i++) {\r\n                            const tone: Tone = instrumentState.releasedTones.get(i);\r\n                            if (tone.ticksSinceReleased >= Math.abs(instrument.getFadeOutTicks())) {\r\n                                this.freeReleasedTone(instrumentState, i);\r\n                                i--;\r\n                                continue;\r\n                            }\r\n                            const shouldFadeOutFast: boolean = (tonesPlayedInThisInstrument >= Config.maximumTonesPerChannel);\r\n                            this.computeTone(song, channelIndex, samplesPerTick, tone, true, shouldFadeOutFast);\r\n                            tonesPlayedInThisInstrument++;\r\n                        }\r\n\r\n                        if (instrumentState.awake) {\r\n                            if (!instrumentState.computed) {\r\n                                instrumentState.compute(this, instrument, samplesPerTick, Math.ceil(samplesPerTick), null, channelIndex, instrumentIndex);\r\n                            }\r\n\r\n                            instrumentState.computed = false;\r\n                            //instrumentState.envelopeComputer.clearEnvelopes();\r\n                        }\r\n                    }\r\n\r\n                    for (let i: number = 0; i < instrumentState.activeTones.count(); i++) {\r\n                        const tone: Tone = instrumentState.activeTones.get(i);\r\n                        this.playTone(channelIndex, bufferIndex, runLength, tone);\r\n                    }\r\n\r\n                    for (let i: number = 0; i < instrumentState.liveInputTones.count(); i++) {\r\n                        const tone: Tone = instrumentState.liveInputTones.get(i);\r\n                        this.playTone(channelIndex, bufferIndex, runLength, tone);\r\n                    }\r\n\r\n                    for (let i: number = 0; i < instrumentState.releasedTones.count(); i++) {\r\n                        const tone: Tone = instrumentState.releasedTones.get(i);\r\n                        this.playTone(channelIndex, bufferIndex, runLength, tone);\r\n                    }\r\n\r\n                    if (instrumentState.awake) {\r\n                        Synth.effectsSynth(this, outputDataL, outputDataR, bufferIndex, runLength, instrumentState);\r\n                    }\r\n\r\n                    // Update LFO time for instruments (used to be deterministic based on bar position but now vibrato/arp speed messes that up!)\r\n\r\n                    const tickSampleCountdown: number = this.tickSampleCountdown;\r\n                    const startRatio: number = 1.0 - (tickSampleCountdown) / samplesPerTick;\r\n                    const endRatio: number = 1.0 - (tickSampleCountdown - runLength) / samplesPerTick;\r\n                    const ticksIntoBar: number = (this.beat * Config.partsPerBeat + this.part) * Config.ticksPerPart + this.tick;\r\n                    const partTimeTickStart: number = (ticksIntoBar) / Config.ticksPerPart;\r\n                    const partTimeTickEnd: number = (ticksIntoBar + 1) / Config.ticksPerPart;\r\n                    const partTimeStart: number = partTimeTickStart + (partTimeTickEnd - partTimeTickStart) * startRatio;\r\n                    const partTimeEnd: number = partTimeTickStart + (partTimeTickEnd - partTimeTickStart) * endRatio;\r\n                    let useVibratoSpeed: number = instrument.vibratoSpeed;\r\n\r\n                    instrument.LFOtime = instrument.nextLFOtime;\r\n\r\n                    if (this.isModActive(Config.modulators.dictionary[\"vibrato speed\"].index, channelIndex, instrumentIndex)) {\r\n                        useVibratoSpeed = this.getModValue(Config.modulators.dictionary[\"vibrato speed\"].index, channelIndex, instrumentIndex);\r\n                    }\r\n\r\n                    if (useVibratoSpeed == 0) {\r\n                        instrument.LFOtime = 0;\r\n                        instrument.nextLFOtime = 0;\r\n                    }\r\n                    else {\r\n                        instrument.nextLFOtime += useVibratoSpeed * 0.1 * (partTimeEnd - partTimeStart);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.enableMetronome || this.countInMetronome) {\r\n                if (this.part == 0) {\r\n                    if (!this.startedMetronome) {\r\n                        const midBeat: boolean = (song.beatsPerBar > 4 && (song.beatsPerBar % 2 == 0) && this.beat == song.beatsPerBar / 2);\r\n                        const periods: number = (this.beat == 0) ? 8 : midBeat ? 6 : 4;\r\n                        const hz: number = (this.beat == 0) ? 1600 : midBeat ? 1200 : 800;\r\n                        const amplitude: number = (this.beat == 0) ? 0.06 : midBeat ? 0.05 : 0.04;\r\n                        const samplesPerPeriod: number = this.samplesPerSecond / hz;\r\n                        const radiansPerSample: number = Math.PI * 2.0 / samplesPerPeriod;\r\n                        this.metronomeSamplesRemaining = Math.floor(samplesPerPeriod * periods);\r\n                        this.metronomeFilter = 2.0 * Math.cos(radiansPerSample);\r\n                        this.metronomeAmplitude = amplitude * Math.sin(radiansPerSample);\r\n                        this.metronomePrevAmplitude = 0.0;\r\n\r\n                        this.startedMetronome = true;\r\n                    }\r\n                    if (this.metronomeSamplesRemaining > 0) {\r\n                        const stopIndex: number = Math.min(runEnd, bufferIndex + this.metronomeSamplesRemaining);\r\n                        this.metronomeSamplesRemaining -= stopIndex - bufferIndex;\r\n                        for (let i: number = bufferIndex; i < stopIndex; i++) {\r\n                            outputDataL[i] += this.metronomeAmplitude;\r\n                            outputDataR[i] += this.metronomeAmplitude;\r\n                            const tempAmplitude: number = this.metronomeFilter * this.metronomeAmplitude - this.metronomePrevAmplitude;\r\n                            this.metronomePrevAmplitude = this.metronomeAmplitude;\r\n                            this.metronomeAmplitude = tempAmplitude;\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.startedMetronome = false;\r\n                }\r\n            }\r\n\r\n            // Post processing:\r\n            for (let i: number = bufferIndex; i < runEnd; i++) {\r\n                // A compressor/limiter.\r\n                const sampleL = outputDataL[i] * song.masterGain * song.masterGain;\r\n                const sampleR = outputDataR[i] * song.masterGain * song.masterGain;\r\n                const absL: number = sampleL < 0.0 ? -sampleL : sampleL;\r\n                const absR: number = sampleR < 0.0 ? -sampleR : sampleR;\r\n                const abs: number = absL > absR ? absL : absR;\r\n                this.song.inVolumeCap = (this.song.inVolumeCap > abs ? this.song.inVolumeCap : abs); // Analytics, spit out raw input volume\r\n                // Determines which formula to use. 0 when volume is between [0, compressionThreshold], 1 when between (compressionThreshold, limitThreshold], 2 above\r\n                const limitRange: number = (+(abs > song.compressionThreshold)) + (+(abs > song.limitThreshold));\r\n                // Determine the target amplification based on the range of the curve\r\n                const limitTarget: number =\r\n                    (+(limitRange == 0)) * (((abs + 1 - song.compressionThreshold) * 0.8 + 0.25) * song.compressionRatio + 1.05 * (1 - song.compressionRatio))\r\n                    + (+(limitRange == 1)) * (1.05)\r\n                    + (+(limitRange == 2)) * (1.05 * ((abs + 1 - song.limitThreshold) * song.limitRatio + (1 - song.limitThreshold)));\r\n                // Move the limit towards the target\r\n                limit += ((limitTarget - limit) * (limit < limitTarget ? limitRise : limitDecay));\r\n                const limitedVolume = volume / (limit >= 1 ? limit * 1.05 : limit * 0.8 + 0.25);\r\n                outputDataL[i] = sampleL * limitedVolume;\r\n                outputDataR[i] = sampleR * limitedVolume;\r\n\r\n                this.song.outVolumeCap = (this.song.outVolumeCap > abs * limitedVolume ? this.song.outVolumeCap : abs * limitedVolume); // Analytics, spit out limited output volume\r\n            }\r\n\r\n            bufferIndex += runLength;\r\n\r\n            this.isAtStartOfTick = false;\r\n            this.tickSampleCountdown -= runLength;\r\n            if (this.tickSampleCountdown <= 0) {\r\n                this.isAtStartOfTick = true;\r\n\r\n                // Track how long tones have been released, and free them if there are too many.\r\n                // Also reset awake InstrumentStates that didn't have any Tones during this tick.\r\n                for (const channelState of this.channels) {\r\n                    for (const instrumentState of channelState.instruments) {\r\n                        for (let i: number = 0; i < instrumentState.releasedTones.count(); i++) {\r\n                            const tone: Tone = instrumentState.releasedTones.get(i);\r\n                            if (tone.isOnLastTick) {\r\n                                this.freeReleasedTone(instrumentState, i);\r\n                                i--;\r\n                            } else {\r\n                                tone.ticksSinceReleased++;\r\n                            }\r\n                        }\r\n                        if (instrumentState.deactivateAfterThisTick) {\r\n                            instrumentState.deactivate();\r\n                        }\r\n                        instrumentState.tonesAddedInThisTick = false;\r\n                    }\r\n                }\r\n\r\n                // Update arpeggio time, which is used to calculate arpeggio position\r\n                for (let channel: number = 0; channel < this.song.pitchChannelCount + this.song.noiseChannelCount; channel++) {\r\n                    for (let instrumentIdx: number = 0; instrumentIdx < this.song.channels[channel].instruments.length; instrumentIdx++) {\r\n                        let instrument: Instrument = this.song.channels[channel].instruments[instrumentIdx];\r\n                        let useArpeggioSpeed: number = instrument.arpeggioSpeed;\r\n                        if (this.isModActive(Config.modulators.dictionary[\"arp speed\"].index, channel, instrumentIdx)) {\r\n                            useArpeggioSpeed = this.getModValue(Config.modulators.dictionary[\"arp speed\"].index, channel, instrumentIdx, false);\r\n                            if (Number.isInteger(useArpeggioSpeed)) {\r\n                                instrument.arpTime += Config.arpSpeedScale[useArpeggioSpeed];\r\n                            } else {\r\n                                // Linear interpolate arpeggio values\r\n                                instrument.arpTime += (1 - (useArpeggioSpeed % 1)) * Config.arpSpeedScale[Math.floor(useArpeggioSpeed)] + (useArpeggioSpeed % 1) * Config.arpSpeedScale[Math.ceil(useArpeggioSpeed)];\r\n                            }\r\n                        }\r\n                        else {\r\n                            instrument.arpTime += Config.arpSpeedScale[useArpeggioSpeed];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Update next-used filters after each run\r\n                for (let channel: number = 0; channel < this.song.pitchChannelCount + this.song.noiseChannelCount; channel++) {\r\n                    for (let instrumentIdx: number = 0; instrumentIdx < this.song.channels[channel].instruments.length; instrumentIdx++) {\r\n                        let instrument: Instrument = this.song.channels[channel].instruments[instrumentIdx];\r\n                        if (instrument.tmpEqFilterEnd != null) {\r\n                            instrument.tmpEqFilterStart = instrument.tmpEqFilterEnd;\r\n                        } else {\r\n                            instrument.tmpEqFilterStart = instrument.eqFilter;\r\n                        }\r\n                        if (instrument.tmpNoteFilterEnd != null) {\r\n                            instrument.tmpNoteFilterStart = instrument.tmpNoteFilterEnd;\r\n                        } else {\r\n                            instrument.tmpNoteFilterStart = instrument.noteFilter;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this.tick++;\r\n                this.tickSampleCountdown += samplesPerTick;\r\n                if (this.tick == Config.ticksPerPart) {\r\n                    this.tick = 0;\r\n                    this.part++;\r\n                    this.liveInputDuration--;\r\n\r\n                    if (this.part == Config.partsPerBeat) {\r\n                        this.part = 0;\r\n\r\n                        if (playSong) {\r\n                            this.beat++;\r\n                            if (this.beat == song.beatsPerBar) {\r\n                                // bar changed, reset for next bar:\r\n                                this.beat = 0;\r\n\r\n                                if (this.countInMetronome) {\r\n                                    this.countInMetronome = false;\r\n                                } else {\r\n                                    this.prevBar = this.bar;\r\n                                    this.bar = this.getNextBar();\r\n                                    if (this.bar <= this.prevBar && this.loopRepeatCount > 0) this.loopRepeatCount--;\r\n\r\n                                    if (this.bar >= song.barCount) {\r\n                                        this.bar = 0;\r\n                                        if (this.loopRepeatCount != -1) {\r\n                                            ended = true;\r\n                                            this.resetEffects();\r\n                                            this.pause();\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Update mod values so that next values copy to current values\r\n            for (let setting: number = 0; setting < Config.modulators.length; setting++) {\r\n                if (this.nextModValues != null && this.nextModValues[setting] != null)\r\n                    this.modValues[setting] = this.nextModValues[setting];\r\n            }\r\n\r\n            // Set samples per tick if song tempo mods changed it\r\n            if (this.isModActive(Config.modulators.dictionary[\"tempo\"].index)) {\r\n                samplesPerTick = this.getSamplesPerTick();\r\n                this.tickSampleCountdown = Math.min(this.tickSampleCountdown, samplesPerTick);\r\n            }\r\n\r\n            // Bound LFO times to be within their period (to keep values from getting large)\r\n            // I figured this modulo math probably doesn't have to happen every LFO tick.\r\n            for (let channel: number = 0; channel < this.song.pitchChannelCount; channel++) {\r\n                for (let instrument of this.song.channels[channel].instruments) {\r\n                    instrument.nextLFOtime = (instrument.nextLFOtime % (Config.vibratoTypes[instrument.vibratoType].period / (Config.ticksPerPart * samplesPerTick / this.samplesPerSecond)));\r\n                    instrument.arpTime = (instrument.arpTime % (2520 * Config.ticksPerArpeggio)); // 2520 = LCM of 4, 5, 6, 7, 8, 9 (arp sizes)\r\n                }\r\n            }\r\n\r\n            for (let setting: number = 0; setting < Config.modulators.length; setting++) {\r\n                for (let channel: number = 0; channel < this.song.pitchChannelCount + this.song.noiseChannelCount; channel++) {\r\n                    for (let instrument: number = 0; instrument < this.song.getMaxInstrumentsPerChannel(); instrument++) {\r\n                        if (this.nextModInsValues != null && this.nextModInsValues[channel] != null && this.nextModInsValues[channel][instrument] != null && this.nextModInsValues[channel][instrument][setting] != null) {\r\n                            this.modInsValues[channel][instrument][setting] = this.nextModInsValues[channel][instrument][setting];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Optimization: Avoid persistent reverb values in the float denormal range.\r\n        if (!Number.isFinite(limit) || Math.abs(limit) < epsilon) limit = 0.0;\r\n        this.limit = limit;\r\n\r\n        if (playSong && !this.countInMetronome) {\r\n            this.playheadInternal = (((this.tick + 1.0 - this.tickSampleCountdown / samplesPerTick) / 2.0 + this.part) / Config.partsPerBeat + this.beat) / song.beatsPerBar + this.bar;\r\n        }\r\n\r\n        /*\r\n        const synthDuration: number = performance.now() - synthStartTime;\r\n        // Performance measurements:\r\n        samplesAccumulated += outputBufferLength;\r\n        samplePerformance += synthDuration;\r\n\r\n        if (samplesAccumulated >= 44100 * 4) {\r\n            const secondsGenerated = samplesAccumulated / 44100;\r\n            const secondsRequired = samplePerformance / 1000;\r\n            const ratio = secondsRequired / secondsGenerated;\r\n            console.log(ratio);\r\n            samplePerformance = 0;\r\n            samplesAccumulated = 0;\r\n        }\r\n        */\r\n    }\r\n\r\n    private freeTone(tone: Tone): void {\r\n        this.tonePool.pushBack(tone);\r\n    }\r\n\r\n    private newTone(): Tone {\r\n        if (this.tonePool.count() > 0) {\r\n            const tone: Tone = this.tonePool.popBack();\r\n            tone.freshlyAllocated = true;\r\n            return tone;\r\n        }\r\n        return new Tone();\r\n    }\r\n\r\n    private releaseTone(instrumentState: InstrumentState, tone: Tone): void {\r\n        instrumentState.releasedTones.pushFront(tone);\r\n        tone.atNoteStart = false;\r\n        tone.passedEndOfNote = true;\r\n    }\r\n\r\n    private freeReleasedTone(instrumentState: InstrumentState, toneIndex: number): void {\r\n        this.freeTone(instrumentState.releasedTones.get(toneIndex));\r\n        instrumentState.releasedTones.remove(toneIndex);\r\n    }\r\n\r\n    public freeAllTones(): void {\r\n        for (const channelState of this.channels) {\r\n            for (const instrumentState of channelState.instruments) {\r\n                while (instrumentState.activeTones.count() > 0) this.freeTone(instrumentState.activeTones.popBack());\r\n                while (instrumentState.activeModTones.count() > 0) this.freeTone(instrumentState.activeModTones.popBack());\r\n                while (instrumentState.releasedTones.count() > 0) this.freeTone(instrumentState.releasedTones.popBack());\r\n                while (instrumentState.liveInputTones.count() > 0) this.freeTone(instrumentState.liveInputTones.popBack());\r\n            }\r\n        }\r\n    }\r\n\r\n    private determineLiveInputTones(song: Song, channelIndex: number, samplesPerTick: number): void {\r\n        const channel: Channel = song.channels[channelIndex];\r\n        const channelState: ChannelState = this.channels[channelIndex];\r\n        const pitches: number[] = this.liveInputPitches;\r\n\r\n        for (let instrumentIndex: number = 0; instrumentIndex < channel.instruments.length; instrumentIndex++) {\r\n            const instrumentState: InstrumentState = channelState.instruments[instrumentIndex];\r\n            const toneList: Deque<Tone> = instrumentState.liveInputTones;\r\n            let toneCount: number = 0;\r\n\r\n            const instrument: Instrument = channel.instruments[instrumentIndex];\r\n            const filteredPitches = pitches.filter(pitch => pitch >= instrument.lowerNoteLimit && pitch <= instrument.upperNoteLimit)\r\n\r\n            if (this.liveInputDuration > 0 && channelIndex == this.liveInputChannel && pitches.length > 0 && this.liveInputInstruments.indexOf(instrumentIndex) != -1) {\r\n                \r\n\r\n                if (instrument.getChord().singleTone) {\r\n                    let tone: Tone;\r\n                    if (toneList.count() <= toneCount) {\r\n                        tone = this.newTone();\r\n                        toneList.pushBack(tone);\r\n                    } else if (!instrument.getTransition().isSeamless && this.liveInputStarted) {\r\n                        this.releaseTone(instrumentState, toneList.get(toneCount));\r\n                        tone = this.newTone();\r\n                        toneList.set(toneCount, tone);\r\n                    } else {\r\n                        tone = toneList.get(toneCount);\r\n                    }\r\n                    toneCount++;\r\n\r\n                    for (let i: number = 0; i < filteredPitches.length; i++) {\r\n                        tone.pitches[i] = filteredPitches[i];\r\n                    }\r\n                    tone.pitchCount = filteredPitches.length;\r\n                    tone.chordSize = 1;\r\n                    tone.instrumentIndex = instrumentIndex;\r\n                    tone.note = tone.prevNote = tone.nextNote = null;\r\n                    tone.atNoteStart = this.liveInputStarted;\r\n                    tone.forceContinueAtStart = false;\r\n                    tone.forceContinueAtEnd = false;\r\n                    this.computeTone(song, channelIndex, samplesPerTick, tone, false, false);\r\n                } else {\r\n                    //const transition: Transition = instrument.getTransition();\r\n\r\n                    this.moveTonesIntoOrderedTempMatchedList(toneList, filteredPitches);\r\n\r\n                    for (let i: number = 0; i < filteredPitches.length; i++) {\r\n                        //const strumOffsetParts: number = i * instrument.getChord().strumParts;\r\n\r\n                        let tone: Tone;\r\n                        if (this.tempMatchedPitchTones[toneCount] != null) {\r\n                            tone = this.tempMatchedPitchTones[toneCount]!;\r\n                            this.tempMatchedPitchTones[toneCount] = null;\r\n                            if (tone.pitchCount != 1 || tone.pitches[0] != filteredPitches[i]) {\r\n                                this.releaseTone(instrumentState, tone);\r\n                                tone = this.newTone();\r\n                            }\r\n                            toneList.pushBack(tone);\r\n                        } else {\r\n                            tone = this.newTone();\r\n                            toneList.pushBack(tone);\r\n                        }\r\n                        toneCount++;\r\n\r\n                        tone.pitches[0] = filteredPitches[i];\r\n                        tone.pitchCount = 1;\r\n                        tone.chordSize = filteredPitches.length;\r\n                        tone.instrumentIndex = instrumentIndex;\r\n                        tone.note = tone.prevNote = tone.nextNote = null;\r\n                        tone.atNoteStart = this.liveInputStarted;\r\n                        tone.forceContinueAtStart = false;\r\n                        tone.forceContinueAtEnd = false;\r\n                        this.computeTone(song, channelIndex, samplesPerTick, tone, false, false);\r\n                    }\r\n                }\r\n            }\r\n\r\n            while (toneList.count() > toneCount) {\r\n                this.releaseTone(instrumentState, toneList.popBack());\r\n            }\r\n\r\n            this.clearTempMatchedPitchTones(toneCount, instrumentState);\r\n        }\r\n\r\n        this.liveInputStarted = false;\r\n    }\r\n\r\n    // Returns the chord type of the instrument in the adjacent pattern if it is compatible for a\r\n    // seamless transition across patterns, otherwise returns null.\r\n    private adjacentPatternHasCompatibleInstrumentTransition(song: Song, channel: Channel, pattern: Pattern, otherPattern: Pattern, instrumentIndex: number, transition: Transition, chord: Chord, note: Note, otherNote: Note, forceContinue: boolean): Chord | null {\r\n        if (song.patternInstruments && otherPattern.instruments.indexOf(instrumentIndex) == -1) {\r\n            // The adjacent pattern does not contain the same instrument as the current pattern.\r\n\r\n            if (pattern.instruments.length > 1 || otherPattern.instruments.length > 1) {\r\n                // The current or adjacent pattern contains more than one instrument, don't bother\r\n                // trying to connect them.\r\n                return null;\r\n            }\r\n            // Otherwise, the two patterns each contain one instrument, but not the same instrument.\r\n            // Try to connect them.\r\n            const otherInstrument: Instrument = channel.instruments[otherPattern.instruments[0]];\r\n\r\n            if (forceContinue) {\r\n                // Even non-seamless instruments can be connected across patterns if forced.\r\n                return otherInstrument.getChord();\r\n            }\r\n\r\n            // Otherwise, check that both instruments are seamless across patterns.\r\n            const otherTransition: Transition = otherInstrument.getTransition();\r\n            if (transition.includeAdjacentPatterns && otherTransition.includeAdjacentPatterns && otherTransition.slides == transition.slides) {\r\n                return otherInstrument.getChord();\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            // If both patterns contain the same instrument, check that it is seamless across patterns.\r\n            return (forceContinue || transition.includeAdjacentPatterns) ? chord : null;\r\n        }\r\n    }\r\n\r\n    public static adjacentNotesHaveMatchingPitches(firstNote: Note, secondNote: Note): boolean {\r\n        if (firstNote.pitches.length != secondNote.pitches.length) return false;\r\n        const firstNoteInterval: number = firstNote.pins[firstNote.pins.length - 1].interval;\r\n        for (const pitch of firstNote.pitches) {\r\n            if (secondNote.pitches.indexOf(pitch + firstNoteInterval) == -1) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private moveTonesIntoOrderedTempMatchedList(toneList: Deque<Tone>, notePitches: number[]): void {\r\n        // The tones are about to seamlessly transition to a new note. The pitches\r\n        // from the old note may or may not match any of the pitches in the new\r\n        // note, and not necessarily in order, but if any do match, they'll sound\r\n        // better if those tones continue to have the same pitch. Attempt to find\r\n        // the right spot for each old tone in the new chord if possible.\r\n\r\n        for (let i: number = 0; i < toneList.count(); i++) {\r\n            const tone: Tone = toneList.get(i);\r\n            const pitch: number = tone.pitches[0] + tone.lastInterval;\r\n            for (let j: number = 0; j < notePitches.length; j++) {\r\n                if (notePitches[j] == pitch) {\r\n                    this.tempMatchedPitchTones[j] = tone;\r\n                    toneList.remove(i);\r\n                    i--;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Any tones that didn't get matched should just fill in the gaps.\r\n        while (toneList.count() > 0) {\r\n            const tone: Tone = toneList.popFront();\r\n            for (let j: number = 0; j < this.tempMatchedPitchTones.length; j++) {\r\n                if (this.tempMatchedPitchTones[j] == null) {\r\n                    this.tempMatchedPitchTones[j] = tone;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private determineCurrentActiveTones(song: Song, channelIndex: number, samplesPerTick: number, playSong: boolean): void {\r\n        const channel: Channel = song.channels[channelIndex];\r\n        const channelState: ChannelState = this.channels[channelIndex];\r\n        const pattern: Pattern | null = song.getPattern(channelIndex, this.bar);\r\n        const currentPart: number = this.getCurrentPart();\r\n        const currentTick: number = this.tick + Config.ticksPerPart * currentPart;\r\n\r\n        if (playSong && song.getChannelIsMod(channelIndex)) {\r\n\r\n            // For mod channels, notes aren't strictly arranged chronologically. Also, each pitch value could play or not play at a given time. So... a bit more computation involved!\r\n            // The same transition logic should apply though, even though it isn't really used by mod channels.\r\n            let notes: (Note | null)[] = [];\r\n            let prevNotes: (Note | null)[] = [];\r\n            let nextNotes: (Note | null)[] = [];\r\n            let fillCount: number = Config.modCount;\r\n            while (fillCount--) {\r\n                notes.push(null);\r\n                prevNotes.push(null);\r\n                nextNotes.push(null);\r\n            }\r\n\r\n            if (pattern != null && !channel.muted) {\r\n                for (let i: number = 0; i < pattern.notes.length; i++) {\r\n                    if (pattern.notes[i].end <= currentPart) {\r\n                        // Actually need to check which note starts closer to the start of this note.\r\n                        if (prevNotes[pattern.notes[i].pitches[0]] == null || pattern.notes[i].end > (prevNotes[pattern.notes[i].pitches[0]] as Note).start) {\r\n                            prevNotes[pattern.notes[i].pitches[0]] = pattern.notes[i];\r\n                        }\r\n                    }\r\n                    else if (pattern.notes[i].start <= currentPart && pattern.notes[i].end > currentPart) {\r\n                        notes[pattern.notes[i].pitches[0]] = pattern.notes[i];\r\n                    }\r\n                    else if (pattern.notes[i].start > currentPart) {\r\n                        // Actually need to check which note starts closer to the end of this note.\r\n                        if (nextNotes[pattern.notes[i].pitches[0]] == null || pattern.notes[i].start < (nextNotes[pattern.notes[i].pitches[0]] as Note).start) {\r\n                            nextNotes[pattern.notes[i].pitches[0]] = pattern.notes[i];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            let modToneCount: number = 0;\r\n            const newInstrumentIndex: number = (song.patternInstruments && (pattern != null)) ? pattern!.instruments[0] : 0;\r\n            const instrumentState: InstrumentState = channelState.instruments[newInstrumentIndex];\r\n            const toneList: Deque<Tone> = instrumentState.activeModTones;\r\n            for (let mod: number = 0; mod < Config.modCount; mod++) {\r\n                if (notes[mod] != null) {\r\n                    if (prevNotes[mod] != null && (prevNotes[mod] as Note).end != (notes[mod] as Note).start) prevNotes[mod] = null;\r\n                    if (nextNotes[mod] != null && (nextNotes[mod] as Note).start != (notes[mod] as Note).end) nextNotes[mod] = null;\r\n\r\n                }\r\n\r\n                if (channelState.singleSeamlessInstrument != null && channelState.singleSeamlessInstrument != newInstrumentIndex && channelState.singleSeamlessInstrument < channelState.instruments.length) {\r\n                    const sourceInstrumentState: InstrumentState = channelState.instruments[channelState.singleSeamlessInstrument];\r\n                    const destInstrumentState: InstrumentState = channelState.instruments[newInstrumentIndex];\r\n                    while (sourceInstrumentState.activeModTones.count() > 0) {\r\n                        destInstrumentState.activeModTones.pushFront(sourceInstrumentState.activeModTones.popBack());\r\n                    }\r\n                }\r\n                channelState.singleSeamlessInstrument = newInstrumentIndex;\r\n\r\n                if (notes[mod] != null) {\r\n                    let prevNoteForThisInstrument: Note | null = prevNotes[mod];\r\n                    let nextNoteForThisInstrument: Note | null = nextNotes[mod];\r\n\r\n                    let forceContinueAtStart: boolean = false;\r\n                    let forceContinueAtEnd: boolean = false;\r\n                    const atNoteStart: boolean = (Config.ticksPerPart * notes[mod]!.start == currentTick) && this.isAtStartOfTick;\r\n                    let tone: Tone;\r\n                    if (toneList.count() <= modToneCount) {\r\n                        tone = this.newTone();\r\n                        toneList.pushBack(tone);\r\n                    } else if (atNoteStart && (prevNoteForThisInstrument == null)) {\r\n                        const oldTone: Tone = toneList.get(modToneCount);\r\n                        if (oldTone.isOnLastTick) {\r\n                            this.freeTone(oldTone);\r\n                        } else {\r\n                            this.releaseTone(instrumentState, oldTone);\r\n                        }\r\n                        tone = this.newTone();\r\n                        toneList.set(modToneCount, tone);\r\n                    } else {\r\n                        tone = toneList.get(modToneCount);\r\n                    }\r\n                    modToneCount++;\r\n\r\n                    for (let i: number = 0; i < notes[mod]!.pitches.length; i++) {\r\n                        tone.pitches[i] = notes[mod]!.pitches[i];\r\n                    }\r\n                    tone.pitchCount = notes[mod]!.pitches.length;\r\n                    tone.chordSize = 1;\r\n                    tone.instrumentIndex = newInstrumentIndex;\r\n                    tone.note = notes[mod];\r\n                    tone.noteStartPart = notes[mod]!.start;\r\n                    tone.noteEndPart = notes[mod]!.end;\r\n                    tone.prevNote = prevNoteForThisInstrument;\r\n                    tone.nextNote = nextNoteForThisInstrument;\r\n                    tone.prevNotePitchIndex = 0;\r\n                    tone.nextNotePitchIndex = 0;\r\n                    tone.atNoteStart = atNoteStart;\r\n                    tone.passedEndOfNote = false;\r\n                    tone.forceContinueAtStart = forceContinueAtStart;\r\n                    tone.forceContinueAtEnd = forceContinueAtEnd;\r\n                }\r\n            }\r\n            // Automatically free or release seamless tones if there's no new note to take over.\r\n            while (toneList.count() > modToneCount) {\r\n                const tone: Tone = toneList.popBack();\r\n                const channel: Channel = song.channels[channelIndex];\r\n                if (tone.instrumentIndex < channel.instruments.length && !tone.isOnLastTick) {\r\n                    const instrumentState: InstrumentState = this.channels[channelIndex].instruments[tone.instrumentIndex];\r\n                    this.releaseTone(instrumentState, tone);\r\n                } else {\r\n                    this.freeTone(tone);\r\n                }\r\n            }\r\n\r\n        }\r\n        else if (!song.getChannelIsMod(channelIndex)) {\r\n\r\n            let note: Note | null = null;\r\n            let prevNote: Note | null = null;\r\n            let nextNote: Note | null = null;\r\n\r\n            if (playSong && pattern != null && !channel.muted && (!this.isRecording || this.liveInputChannel != channelIndex)) {\r\n                for (let i: number = 0; i < pattern.notes.length; i++) {\r\n                    if (pattern.notes[i].end <= currentPart) {\r\n                        prevNote = pattern.notes[i];\r\n                    } else if (pattern.notes[i].start <= currentPart && pattern.notes[i].end > currentPart) {\r\n                        note = pattern.notes[i];\r\n                    } else if (pattern.notes[i].start > currentPart) {\r\n                        nextNote = pattern.notes[i];\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (note != null) {\r\n                    if (prevNote != null && prevNote.end != note.start) prevNote = null;\r\n                    if (nextNote != null && nextNote.start != note.end) nextNote = null;\r\n                }\r\n            }\r\n\r\n            // Seamless tones from a pattern with a single instrument can be transferred to a different single seamless instrument in the next pattern.\r\n            if (pattern != null && (!song.layeredInstruments || channel.instruments.length == 1 || (song.patternInstruments && pattern.instruments.length == 1))) {\r\n                const newInstrumentIndex: number = song.patternInstruments ? pattern.instruments[0] : 0;\r\n                if (channelState.singleSeamlessInstrument != null && channelState.singleSeamlessInstrument != newInstrumentIndex && channelState.singleSeamlessInstrument < channelState.instruments.length) {\r\n                    const sourceInstrumentState: InstrumentState = channelState.instruments[channelState.singleSeamlessInstrument];\r\n                    const destInstrumentState: InstrumentState = channelState.instruments[newInstrumentIndex];\r\n                    while (sourceInstrumentState.activeTones.count() > 0) {\r\n                        destInstrumentState.activeTones.pushFront(sourceInstrumentState.activeTones.popBack());\r\n                    }\r\n                }\r\n                channelState.singleSeamlessInstrument = newInstrumentIndex;\r\n            } else {\r\n                channelState.singleSeamlessInstrument = null;\r\n            }\r\n\r\n            for (let instrumentIndex: number = 0; instrumentIndex < channel.instruments.length; instrumentIndex++) {\r\n                const instrumentState: InstrumentState = channelState.instruments[instrumentIndex];\r\n                const toneList: Deque<Tone> = instrumentState.activeTones;\r\n                let toneCount: number = 0;\r\n                if ((note != null) && (!song.patternInstruments || (pattern!.instruments.indexOf(instrumentIndex) != -1))) {\r\n                    const instrument: Instrument = channel.instruments[instrumentIndex];\r\n                    let prevNoteForThisInstrument: Note | null = prevNote;\r\n                    let nextNoteForThisInstrument: Note | null = nextNote;\r\n\r\n                    const partsPerBar: Number = Config.partsPerBeat * song.beatsPerBar;\r\n                    const transition: Transition = instrument.getTransition();\r\n                    const chord: Chord = instrument.getChord();\r\n                    let forceContinueAtStart: boolean = false;\r\n                    let forceContinueAtEnd: boolean = false;\r\n                    let tonesInPrevNote: number = 0;\r\n                    let tonesInNextNote: number = 0;\r\n                    if (note.start == 0) {\r\n                        // If the beginning of the note coincides with the beginning of the pattern,\r\n                        let prevPattern: Pattern | null = (this.prevBar == null) ? null : song.getPattern(channelIndex, this.prevBar);\r\n                        if (prevPattern != null) {\r\n                            const lastNote: Note | null = (prevPattern.notes.length <= 0) ? null : prevPattern.notes[prevPattern.notes.length - 1];\r\n                            if (lastNote != null && lastNote.end == partsPerBar) {\r\n                                const patternForcesContinueAtStart: boolean = note.continuesLastPattern && Synth.adjacentNotesHaveMatchingPitches(lastNote, note);\r\n                                const chordOfCompatibleInstrument: Chord | null = this.adjacentPatternHasCompatibleInstrumentTransition(song, channel, pattern!, prevPattern, instrumentIndex, transition, chord, note, lastNote, patternForcesContinueAtStart);\r\n                                if (chordOfCompatibleInstrument != null) {\r\n                                    prevNoteForThisInstrument = lastNote;\r\n                                    tonesInPrevNote = chordOfCompatibleInstrument.singleTone ? 1 : prevNoteForThisInstrument.pitches.length\r\n                                    forceContinueAtStart = patternForcesContinueAtStart;\r\n                                }\r\n                            }\r\n                        }\r\n                    } else if (prevNoteForThisInstrument != null) {\r\n                        tonesInPrevNote = chord.singleTone ? 1 : prevNoteForThisInstrument.pitches.length\r\n                    }\r\n                    if (note.end == partsPerBar) {\r\n                        // If the end of the note coincides with the end of the pattern, look for an\r\n                        // adjacent note at the beginning of the next pattern.\r\n                        let nextPattern: Pattern | null = (this.nextBar == null) ? null : song.getPattern(channelIndex, this.nextBar);\r\n                        if (nextPattern != null) {\r\n                            const firstNote: Note | null = (nextPattern.notes.length <= 0) ? null : nextPattern.notes[0];\r\n                            if (firstNote != null && firstNote.start == 0) {\r\n                                const nextPatternForcesContinueAtStart: boolean = firstNote.continuesLastPattern && Synth.adjacentNotesHaveMatchingPitches(note, firstNote);\r\n                                const chordOfCompatibleInstrument: Chord | null = this.adjacentPatternHasCompatibleInstrumentTransition(song, channel, pattern!, nextPattern, instrumentIndex, transition, chord, note, firstNote, nextPatternForcesContinueAtStart);\r\n                                if (chordOfCompatibleInstrument != null) {\r\n                                    nextNoteForThisInstrument = firstNote;\r\n                                    tonesInNextNote = chordOfCompatibleInstrument.singleTone ? 1 : nextNoteForThisInstrument.pitches.length\r\n                                    forceContinueAtEnd = nextPatternForcesContinueAtStart;\r\n                                }\r\n                            }\r\n                        }\r\n                    } else if (nextNoteForThisInstrument != null) {\r\n                        tonesInNextNote = chord.singleTone ? 1 : nextNoteForThisInstrument.pitches.length\r\n                    }\r\n\r\n                    let filteredPitches: number[] = note.pitches.filter(pitch => pitch >= instrument.lowerNoteLimit && pitch <= instrument.upperNoteLimit)\r\n                    if (chord.singleTone && !(filteredPitches.length <= 0)) {\r\n                        const atNoteStart: boolean = (Config.ticksPerPart * note.start == currentTick);\r\n                        let tone: Tone;\r\n                        if (toneList.count() <= toneCount) {\r\n                            tone = this.newTone();\r\n                            toneList.pushBack(tone);\r\n                        } else if (atNoteStart && ((!(transition.isSeamless || instrument.clicklessTransition) && !forceContinueAtStart) || prevNoteForThisInstrument == null)) {\r\n                            const oldTone: Tone = toneList.get(toneCount);\r\n                            if (oldTone.isOnLastTick) {\r\n                                this.freeTone(oldTone);\r\n                            } else {\r\n                                this.releaseTone(instrumentState, oldTone);\r\n                            }\r\n                            tone = this.newTone();\r\n                            toneList.set(toneCount, tone);\r\n                        } else {\r\n                            tone = toneList.get(toneCount);\r\n                        }\r\n                        toneCount++;\r\n                        \r\n                        for (let i: number = 0; i < filteredPitches.length; i++) {\r\n                            tone.pitches[i] = filteredPitches[i];\r\n                        }\r\n                        tone.pitchCount = filteredPitches.length;\r\n                        tone.chordSize = 1;\r\n                        tone.instrumentIndex = instrumentIndex;\r\n                        tone.note = note;\r\n                        tone.noteStartPart = note.start;\r\n                        tone.noteEndPart = note.end;\r\n                        tone.prevNote = prevNoteForThisInstrument;\r\n                        tone.nextNote = nextNoteForThisInstrument;\r\n                        tone.prevNotePitchIndex = 0;\r\n                        tone.nextNotePitchIndex = 0;\r\n                        tone.atNoteStart = atNoteStart;\r\n                        tone.passedEndOfNote = false;\r\n                        tone.forceContinueAtStart = forceContinueAtStart;\r\n                        tone.forceContinueAtEnd = forceContinueAtEnd;\r\n                        this.computeTone(song, channelIndex, samplesPerTick, tone, false, false);\r\n                    } else {\r\n                        const transition: Transition = instrument.getTransition();\r\n\r\n                        if (((transition.isSeamless && !transition.slides && chord.strumParts == 0) || forceContinueAtStart) && (Config.ticksPerPart * note.start == currentTick) && prevNoteForThisInstrument != null) {\r\n                            this.moveTonesIntoOrderedTempMatchedList(toneList, filteredPitches);\r\n                        }\r\n\r\n                        let strumOffsetParts: number = 0;\r\n                        for (let i: number = 0; i < filteredPitches.length; i++) {\r\n\r\n                            let prevNoteForThisTone: Note | null = (tonesInPrevNote > i) ? prevNoteForThisInstrument : null;\r\n                            let noteForThisTone: Note = note;\r\n                            let nextNoteForThisTone: Note | null = (tonesInNextNote > i) ? nextNoteForThisInstrument : null;\r\n                            let noteStartPart: number = noteForThisTone.start + strumOffsetParts;\r\n                            let passedEndOfNote: boolean = false;\r\n\r\n                            // Strumming may mean that a note's actual start time may be after the\r\n                            // note's displayed start time. If the note start hasn't been reached yet,\r\n                            // carry over the previous tone if available and seamless, otherwise skip\r\n                            // the new tone until it is ready to start.\r\n                            if (noteStartPart > currentPart) {\r\n                                if (toneList.count() > i && (transition.isSeamless || forceContinueAtStart) && prevNoteForThisTone != null) {\r\n                                    // Continue the previous note's chord until the current one takes over.\r\n                                    nextNoteForThisTone = noteForThisTone;\r\n                                    noteForThisTone = prevNoteForThisTone;\r\n                                    prevNoteForThisTone = null;\r\n                                    noteStartPart = noteForThisTone.start + strumOffsetParts;\r\n                                    passedEndOfNote = true;\r\n                                } else {\r\n                                    // This and the rest of the tones in the chord shouldn't start yet.\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            let noteEndPart: number = noteForThisTone.end;\r\n                            if ((transition.isSeamless || forceContinueAtStart) && nextNoteForThisTone != null) {\r\n                                noteEndPart = Math.min(Config.partsPerBeat * this.song!.beatsPerBar, noteEndPart + strumOffsetParts);\r\n                            }\r\n                            if ((!transition.continues && !forceContinueAtStart) || prevNoteForThisTone == null) {\r\n                                strumOffsetParts += chord.strumParts;\r\n                            }\r\n\r\n                            const atNoteStart: boolean = (Config.ticksPerPart * noteStartPart == currentTick);\r\n                            let tone: Tone;\r\n                            if (this.tempMatchedPitchTones[toneCount] != null) {\r\n                                tone = this.tempMatchedPitchTones[toneCount]!;\r\n                                this.tempMatchedPitchTones[toneCount] = null;\r\n                                toneList.pushBack(tone);\r\n                            } else if (toneList.count() <= toneCount) {\r\n                                tone = this.newTone();\r\n                                toneList.pushBack(tone);\r\n                            } else if (atNoteStart && ((!transition.isSeamless && !forceContinueAtStart) || prevNoteForThisTone == null)) {\r\n                                const oldTone: Tone = toneList.get(toneCount);\r\n                                if (oldTone.isOnLastTick) {\r\n                                    this.freeTone(oldTone);\r\n                                } else {\r\n                                    this.releaseTone(instrumentState, oldTone);\r\n                                }\r\n                                tone = this.newTone();\r\n                                toneList.set(toneCount, tone);\r\n                            } else {\r\n                                tone = toneList.get(toneCount);\r\n                            }\r\n                            toneCount++;\r\n\r\n                            tone.pitches[0] = noteForThisTone.pitches[i];\r\n                            tone.pitchCount = 1;\r\n                            tone.chordSize = noteForThisTone.pitches.length;\r\n                            tone.instrumentIndex = instrumentIndex;\r\n                            tone.note = noteForThisTone;\r\n                            tone.noteStartPart = noteStartPart;\r\n                            tone.noteEndPart = noteEndPart;\r\n                            tone.prevNote = prevNoteForThisTone;\r\n                            tone.nextNote = nextNoteForThisTone;\r\n                            tone.prevNotePitchIndex = i;\r\n                            tone.nextNotePitchIndex = i;\r\n                            tone.atNoteStart = atNoteStart;\r\n                            tone.passedEndOfNote = passedEndOfNote;\r\n                            tone.forceContinueAtStart = forceContinueAtStart && prevNoteForThisTone != null;\r\n                            tone.forceContinueAtEnd = forceContinueAtEnd && nextNoteForThisTone != null;\r\n                            this.computeTone(song, channelIndex, samplesPerTick, tone, false, false);\r\n                        }\r\n                    }\r\n                }\r\n                // Automatically free or release seamless tones if there's no new note to take over.\r\n                while (toneList.count() > toneCount) {\r\n                    const tone: Tone = toneList.popBack();\r\n                    const channel: Channel = song.channels[channelIndex];\r\n                    if (tone.instrumentIndex < channel.instruments.length && !tone.isOnLastTick) {\r\n                        const instrumentState: InstrumentState = channelState.instruments[tone.instrumentIndex];\r\n                        this.releaseTone(instrumentState, tone);\r\n                    } else {\r\n                        this.freeTone(tone);\r\n                    }\r\n                }\r\n\r\n                this.clearTempMatchedPitchTones(toneCount, instrumentState);\r\n            }\r\n        }\r\n    }\r\n\r\n    private clearTempMatchedPitchTones(toneCount: number, instrumentState: InstrumentState): void {\r\n        for (let i: number = toneCount; i < this.tempMatchedPitchTones.length; i++) {\r\n            const oldTone: Tone | null = this.tempMatchedPitchTones[i];\r\n            if (oldTone != null) {\r\n                if (oldTone.isOnLastTick) {\r\n                    this.freeTone(oldTone);\r\n                } else {\r\n                    this.releaseTone(instrumentState, oldTone);\r\n                }\r\n                this.tempMatchedPitchTones[i] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private playTone(channelIndex: number, bufferIndex: number, runLength: number, tone: Tone): void {\r\n        const channelState: ChannelState = this.channels[channelIndex];\r\n        const instrumentState: InstrumentState = channelState.instruments[tone.instrumentIndex];\r\n\r\n        if (instrumentState.synthesizer != null) instrumentState.synthesizer!(this, bufferIndex, runLength, tone, instrumentState);\r\n        tone.envelopeComputer.clearEnvelopes();\r\n    }\r\n\r\n    // Computes mod note position at the start and end of the window and \"plays\" the mod tone, setting appropriate mod data.\r\n    private playModTone(song: Song, channelIndex: number, samplesPerTick: number, bufferIndex: number, roundedSamplesPerTick: number, tone: Tone, released: boolean, shouldFadeOutFast: boolean): void {\r\n        const channel: Channel = song.channels[channelIndex];\r\n        const instrument: Instrument = channel.instruments[tone.instrumentIndex];\r\n\r\n        if (tone.note != null) {\r\n            const ticksIntoBar: number = this.getTicksIntoBar();\r\n            const partTimeTickStart: number = (ticksIntoBar) / Config.ticksPerPart;\r\n            const partTimeTickEnd: number = (ticksIntoBar + 1) / Config.ticksPerPart;\r\n            const tickSampleCountdown: number = this.tickSampleCountdown;\r\n            const startRatio: number = 1.0 - (tickSampleCountdown) / samplesPerTick;\r\n            const endRatio: number = 1.0 - (tickSampleCountdown - roundedSamplesPerTick) / samplesPerTick;\r\n            const partTimeStart: number = partTimeTickStart + (partTimeTickEnd - partTimeTickStart) * startRatio;\r\n            const partTimeEnd: number = partTimeTickStart + (partTimeTickEnd - partTimeTickStart) * endRatio;\r\n            const tickTimeStart: number = Config.ticksPerPart * partTimeStart;\r\n            const tickTimeEnd: number = Config.ticksPerPart * partTimeEnd;\r\n            const endPinIndex: number = tone.note.getEndPinIndex(this.getCurrentPart());\r\n            const startPin: NotePin = tone.note.pins[endPinIndex - 1];\r\n            const endPin: NotePin = tone.note.pins[endPinIndex];\r\n            const startPinTick: number = (tone.note.start + startPin.time) * Config.ticksPerPart;\r\n            const endPinTick: number = (tone.note.start + endPin.time) * Config.ticksPerPart;\r\n            const ratioStart: number = (tickTimeStart - startPinTick) / (endPinTick - startPinTick);\r\n            const ratioEnd: number = (tickTimeEnd - startPinTick) / (endPinTick - startPinTick);\r\n            tone.expression = startPin.size + (endPin.size - startPin.size) * ratioStart;\r\n            tone.expressionDelta = (startPin.size + (endPin.size - startPin.size) * ratioEnd) - tone.expression;\r\n\r\n            Synth.modSynth(this, bufferIndex, roundedSamplesPerTick, tone, instrument);\r\n        }\r\n    }\r\n\r\n    private static computeChordExpression(chordSize: number): number {\r\n        return 1.0 / ((chordSize - 1) * 0.25 + 1.0);\r\n    }\r\n\r\n    private computeTone(song: Song, channelIndex: number, samplesPerTick: number, tone: Tone, released: boolean, shouldFadeOutFast: boolean): void {\r\n        \r\n        const roundedSamplesPerTick: number = Math.ceil(samplesPerTick);\r\n        const channel: Channel = song.channels[channelIndex];\r\n        const channelState: ChannelState = this.channels[channelIndex];\r\n        const instrument: Instrument = channel.instruments[tone.instrumentIndex];\r\n        const instrumentState: InstrumentState = channelState.instruments[tone.instrumentIndex];\r\n        instrumentState.awake = true;\r\n        instrumentState.tonesAddedInThisTick = true;\r\n        if (!instrumentState.computed) {\r\n            instrumentState.compute(this, instrument, samplesPerTick, roundedSamplesPerTick, tone, channelIndex, tone.instrumentIndex);\r\n        }\r\n        const transition: Transition = instrument.getTransition();\r\n        const chord: Chord = instrument.getChord();\r\n        const chordExpression: number = chord.singleTone ? 1.0 : Synth.computeChordExpression(tone.chordSize);\r\n        const isNoiseChannel: boolean = song.getChannelIsNoise(channelIndex);\r\n        const intervalScale: number = isNoiseChannel ? Config.noiseInterval : 1;\r\n        const secondsPerPart: number = Config.ticksPerPart * samplesPerTick / this.samplesPerSecond;\r\n        const sampleTime: number = 1.0 / this.samplesPerSecond;\r\n        const beatsPerPart: number = 1.0 / Config.partsPerBeat;\r\n        const ticksIntoBar: number = this.getTicksIntoBar();\r\n        const partTimeStart: number = (ticksIntoBar) / Config.ticksPerPart;\r\n        const partTimeEnd: number = (ticksIntoBar + 1.0) / Config.ticksPerPart;\r\n        const currentPart: number = this.getCurrentPart();\r\n\r\n        let specialIntervalMult: number = 1.0;\r\n        tone.specialIntervalExpressionMult = 1.0;\r\n\r\n\r\n\r\n        //if (synth.isModActive(ModSetting.mstPan, channelIndex, tone.instrumentIndex)) {\r\n        //    startPan = synth.getModValue(ModSetting.mstPan, false, channel, instrumentIdx, false);\r\n        //    endPan = synth.getModValue(ModSetting.mstPan, false, channel, instrumentIdx, true);\r\n        //}\r\n\r\n        let toneIsOnLastTick: boolean = shouldFadeOutFast;\r\n        let intervalStart: number = 0.0;\r\n        let intervalEnd: number = 0.0;\r\n        let fadeExpressionStart: number = 1.0;\r\n        let fadeExpressionEnd: number = 1.0;\r\n        let chordExpressionStart: number = chordExpression;\r\n        let chordExpressionEnd: number = chordExpression;\r\n\r\n        let expressionReferencePitch: number = 16; // A low \"E\" as a MIDI pitch.\r\n        let basePitch: number = Config.keys[song.key].basePitch;\r\n        let baseExpression: number = 1.0;\r\n        let pitchDamping: number = 48;\r\n        if (instrument.type == InstrumentType.spectrum) {\r\n            baseExpression = Config.spectrumBaseExpression;\r\n            if (isNoiseChannel) {\r\n                basePitch = Config.spectrumBasePitch;\r\n                baseExpression *= 2.0; // Note: spectrum is louder for drum channels than pitch channels!\r\n            }\r\n            expressionReferencePitch = Config.spectrumBasePitch;\r\n            pitchDamping = 28;\r\n        } else if (instrument.type == InstrumentType.drumset) {\r\n            basePitch = Config.spectrumBasePitch;\r\n            baseExpression = Config.drumsetBaseExpression;\r\n            expressionReferencePitch = basePitch;\r\n        } else if (instrument.type == InstrumentType.noise) {\r\n            basePitch = Config.chipNoises[instrument.chipNoise].basePitch;\r\n            baseExpression = Config.noiseBaseExpression;\r\n            expressionReferencePitch = basePitch;\r\n            pitchDamping = Config.chipNoises[instrument.chipNoise].isSoft ? 24.0 : 60.0;\r\n        } else if (instrument.type == InstrumentType.fm) {\r\n            baseExpression = Config.fmBaseExpression;\r\n        } else if (instrument.type == InstrumentType.chip || instrument.type == InstrumentType.customChipWave) {\r\n            baseExpression = Config.chipBaseExpression;\r\n        } else if (instrument.type == InstrumentType.harmonics) {\r\n            baseExpression = Config.harmonicsBaseExpression;\r\n        } else if (instrument.type == InstrumentType.pwm) {\r\n            baseExpression = Config.pwmBaseExpression;\r\n        } else if (instrument.type == InstrumentType.pickedString) {\r\n            baseExpression = Config.pickedStringBaseExpression;\r\n        } else if (instrument.type == InstrumentType.mod) {\r\n            baseExpression = 1.0;\r\n            expressionReferencePitch = 0;\r\n            pitchDamping = 1.0;\r\n            basePitch = 0;\r\n        } else {\r\n            throw new Error(\"Unknown instrument type in computeTone.\");\r\n        }\r\n\r\n        if ((tone.atNoteStart && !transition.isSeamless && !tone.forceContinueAtStart) || tone.freshlyAllocated) {\r\n            tone.reset();\r\n        }\r\n        tone.freshlyAllocated = false;\r\n\r\n        for (let i: number = 0; i < Config.maxPitchOrOperatorCount; i++) {\r\n            tone.phaseDeltas[i] = 0.0;\r\n            tone.phaseDeltaScales[i] = 0.0;\r\n            tone.operatorExpressions[i] = 0.0;\r\n            tone.operatorExpressionDeltas[i] = 0.0;\r\n        }\r\n        tone.expression = 0.0;\r\n        tone.expressionDelta = 0.0;\r\n        for (let i: number = 0; i < Config.operatorCount; i++) {\r\n            tone.operatorWaves[i] = Synth.getOperatorWave(instrument.operators[i].waveform, instrument.operators[i].pulseWidth);\r\n        }\r\n\r\n        if (released) {\r\n            const startTicksSinceReleased: number = tone.ticksSinceReleased;\r\n            const endTicksSinceReleased: number = tone.ticksSinceReleased + 1.0;\r\n            intervalStart = intervalEnd = tone.lastInterval;\r\n            const fadeOutTicks: number = Math.abs(instrument.getFadeOutTicks());\r\n            fadeExpressionStart = Synth.noteSizeToVolumeMult((1.0 - startTicksSinceReleased / fadeOutTicks) * Config.noteSizeMax);\r\n            fadeExpressionEnd = Synth.noteSizeToVolumeMult((1.0 - endTicksSinceReleased / fadeOutTicks) * Config.noteSizeMax);\r\n\r\n            if (shouldFadeOutFast) {\r\n                fadeExpressionEnd = 0.0;\r\n            }\r\n\r\n            if (tone.ticksSinceReleased + 1 >= fadeOutTicks) toneIsOnLastTick = true;\r\n        } else if (tone.note == null) {\r\n            fadeExpressionStart = fadeExpressionEnd = 1.0;\r\n            tone.lastInterval = 0;\r\n            tone.ticksSinceReleased = 0;\r\n            tone.liveInputSamplesHeld += roundedSamplesPerTick;\r\n        } else {\r\n            const note: Note = tone.note;\r\n            const nextNote: Note | null = tone.nextNote;\r\n\r\n            const noteStartPart: number = tone.noteStartPart;\r\n            const noteEndPart: number = tone.noteEndPart;\r\n\r\n\r\n            const endPinIndex: number = note.getEndPinIndex(currentPart);\r\n            const startPin: NotePin = note.pins[endPinIndex - 1];\r\n            const endPin: NotePin = note.pins[endPinIndex];\r\n            const noteStartTick: number = noteStartPart * Config.ticksPerPart;\r\n            const noteEndTick: number = noteEndPart * Config.ticksPerPart;\r\n            const pinStart: number = (note.start + startPin.time) * Config.ticksPerPart;\r\n            const pinEnd: number = (note.start + endPin.time) * Config.ticksPerPart;\r\n\r\n            tone.ticksSinceReleased = 0;\r\n\r\n            const tickTimeStart: number = currentPart * Config.ticksPerPart + this.tick;\r\n            const tickTimeEnd: number = tickTimeStart + 1.0;\r\n            const noteTicksPassedTickStart: number = tickTimeStart - noteStartTick;\r\n            const noteTicksPassedTickEnd: number = tickTimeEnd - noteStartTick;\r\n            const pinRatioStart: number = Math.min(1.0, (tickTimeStart - pinStart) / (pinEnd - pinStart));\r\n            const pinRatioEnd: number = Math.min(1.0, (tickTimeEnd - pinStart) / (pinEnd - pinStart));\r\n            fadeExpressionStart = 1.0;\r\n            fadeExpressionEnd = 1.0;\r\n            intervalStart = startPin.interval + (endPin.interval - startPin.interval) * pinRatioStart;\r\n            intervalEnd = startPin.interval + (endPin.interval - startPin.interval) * pinRatioEnd;\r\n            tone.lastInterval = intervalEnd;\r\n\r\n            if ((!transition.isSeamless && !tone.forceContinueAtEnd) || nextNote == null) {\r\n                const fadeOutTicks: number = -instrument.getFadeOutTicks();\r\n                if (fadeOutTicks > 0.0) {\r\n                    // If the tone should fade out before the end of the note, do so here.\r\n                    const noteLengthTicks: number = noteEndTick - noteStartTick;\r\n                    fadeExpressionStart *= Math.min(1.0, (noteLengthTicks - noteTicksPassedTickStart) / fadeOutTicks);\r\n                    fadeExpressionEnd *= Math.min(1.0, (noteLengthTicks - noteTicksPassedTickEnd) / fadeOutTicks);\r\n                    if (tickTimeEnd >= noteStartTick + noteLengthTicks) toneIsOnLastTick = true;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        tone.isOnLastTick = toneIsOnLastTick;\r\n\r\n        let tmpNoteFilter: FilterSettings = instrument.noteFilter;\r\n        let startPoint: FilterControlPoint;\r\n        let endPoint: FilterControlPoint;\r\n\r\n        if (instrument.noteFilterType) {\r\n            // Simple EQ filter (old style). For analysis, using random filters from normal style since they are N/A in this context.\r\n            const noteFilterSettingsStart: FilterSettings = instrument.noteFilter;\r\n            if (instrument.noteSubFilters[1] == null)\r\n                instrument.noteSubFilters[1] = new FilterSettings();\r\n            const noteFilterSettingsEnd: FilterSettings = instrument.noteSubFilters[1];\r\n\r\n            // Change location based on slider values\r\n            let startSimpleFreq: number = instrument.noteFilterSimpleCut;\r\n            let startSimpleGain: number = instrument.noteFilterSimplePeak;\r\n            let endSimpleFreq: number = instrument.noteFilterSimpleCut;\r\n            let endSimpleGain: number = instrument.noteFilterSimplePeak;\r\n            let filterChanges: boolean = false;\r\n\r\n            if (this.isModActive(Config.modulators.dictionary[\"note filt cut\"].index, channelIndex, tone.instrumentIndex)) {\r\n                startSimpleFreq = this.getModValue(Config.modulators.dictionary[\"note filt cut\"].index, channelIndex, tone.instrumentIndex, false);\r\n                endSimpleFreq = this.getModValue(Config.modulators.dictionary[\"note filt cut\"].index, channelIndex, tone.instrumentIndex, true);\r\n                filterChanges = true;\r\n            }\r\n            if (this.isModActive(Config.modulators.dictionary[\"note filt peak\"].index, channelIndex, tone.instrumentIndex)) {\r\n                startSimpleGain = this.getModValue(Config.modulators.dictionary[\"note filt peak\"].index, channelIndex, tone.instrumentIndex, false);\r\n                endSimpleGain = this.getModValue(Config.modulators.dictionary[\"note filt peak\"].index, channelIndex, tone.instrumentIndex, true);\r\n                filterChanges = true;\r\n            }\r\n\r\n            noteFilterSettingsStart.convertLegacySettingsForSynth(startSimpleFreq, startSimpleGain, !filterChanges);\r\n            noteFilterSettingsEnd.convertLegacySettingsForSynth(endSimpleFreq, endSimpleGain, !filterChanges);\r\n\r\n            startPoint = noteFilterSettingsStart.controlPoints[0];\r\n            endPoint = noteFilterSettingsEnd.controlPoints[0];\r\n\r\n            // Temporarily override so that envelope computer uses appropriate computed note filter\r\n            instrument.noteFilter = noteFilterSettingsStart;\r\n            instrument.tmpNoteFilterStart = noteFilterSettingsStart;\r\n        }\r\n\r\n        // Compute envelopes *after* resetting the tone, otherwise the envelope computer gets reset too!\r\n        const envelopeComputer: EnvelopeComputer = tone.envelopeComputer;\r\n        envelopeComputer.computeEnvelopes(instrument, currentPart, Config.ticksPerPart * partTimeStart, samplesPerTick / this.samplesPerSecond, tone);\r\n        const envelopeStarts: number[] = tone.envelopeComputer.envelopeStarts;\r\n        const envelopeEnds: number[] = tone.envelopeComputer.envelopeEnds;\r\n        instrument.noteFilter = tmpNoteFilter;\r\n\r\n        if (tone.note != null && transition.slides) {\r\n            // Slide interval and chordExpression at the start and/or end of the note if necessary.\r\n            const prevNote: Note | null = tone.prevNote;\r\n            const nextNote: Note | null = tone.nextNote;\r\n            if (prevNote != null) {\r\n                const intervalDiff: number = prevNote.pitches[tone.prevNotePitchIndex] + prevNote.pins[prevNote.pins.length - 1].interval - tone.pitches[0];\r\n                if (envelopeComputer.prevSlideStart) intervalStart += intervalDiff * envelopeComputer.prevSlideRatioStart;\r\n                if (envelopeComputer.prevSlideEnd) intervalEnd += intervalDiff * envelopeComputer.prevSlideRatioEnd;\r\n                if (!chord.singleTone) {\r\n                    const chordSizeDiff: number = prevNote.pitches.length - tone.chordSize;\r\n                    if (envelopeComputer.prevSlideStart) chordExpressionStart = Synth.computeChordExpression(tone.chordSize + chordSizeDiff * envelopeComputer.prevSlideRatioStart);\r\n                    if (envelopeComputer.prevSlideEnd) chordExpressionEnd = Synth.computeChordExpression(tone.chordSize + chordSizeDiff * envelopeComputer.prevSlideRatioEnd);\r\n                }\r\n            }\r\n            if (nextNote != null) {\r\n                const intervalDiff: number = nextNote.pitches[tone.nextNotePitchIndex] - (tone.pitches[0] + tone.note.pins[tone.note.pins.length - 1].interval);\r\n                if (envelopeComputer.nextSlideStart) intervalStart += intervalDiff * envelopeComputer.nextSlideRatioStart;\r\n                if (envelopeComputer.nextSlideEnd) intervalEnd += intervalDiff * envelopeComputer.nextSlideRatioEnd;\r\n                if (!chord.singleTone) {\r\n                    const chordSizeDiff: number = nextNote.pitches.length - tone.chordSize;\r\n                    if (envelopeComputer.nextSlideStart) chordExpressionStart = Synth.computeChordExpression(tone.chordSize + chordSizeDiff * envelopeComputer.nextSlideRatioStart);\r\n                    if (envelopeComputer.nextSlideEnd) chordExpressionEnd = Synth.computeChordExpression(tone.chordSize + chordSizeDiff * envelopeComputer.nextSlideRatioEnd);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (effectsIncludePitchShift(instrument.effects)) {\r\n            let pitchShift: number = Config.justIntonationSemitones[instrument.pitchShift] / intervalScale;\r\n            let pitchShiftScalarStart: number = 1.0;\r\n            let pitchShiftScalarEnd: number = 1.0;\r\n            if (this.isModActive(Config.modulators.dictionary[\"pitch shift\"].index, channelIndex, tone.instrumentIndex)) {\r\n                pitchShift = Config.justIntonationSemitones[Config.justIntonationSemitones.length - 1];\r\n                pitchShiftScalarStart = (this.getModValue(Config.modulators.dictionary[\"pitch shift\"].index, channelIndex, tone.instrumentIndex, false)) / (Config.pitchShiftCenter);\r\n                pitchShiftScalarEnd = (this.getModValue(Config.modulators.dictionary[\"pitch shift\"].index, channelIndex, tone.instrumentIndex, true)) / (Config.pitchShiftCenter);\r\n            }\r\n            const envelopeStart: number = envelopeStarts[EnvelopeComputeIndex.pitchShift];\r\n            const envelopeEnd: number = envelopeEnds[EnvelopeComputeIndex.pitchShift];\r\n            intervalStart += pitchShift * envelopeStart * pitchShiftScalarStart;\r\n            intervalEnd += pitchShift * envelopeEnd * pitchShiftScalarEnd;\r\n        }\r\n        if (effectsIncludeDetune(instrument.effects) || this.isModActive(Config.modulators.dictionary[\"song detune\"].index, channelIndex, tone.instrumentIndex)) {\r\n            const envelopeStart: number = envelopeStarts[EnvelopeComputeIndex.detune];\r\n            const envelopeEnd: number = envelopeEnds[EnvelopeComputeIndex.detune];\r\n            let modDetuneStart: number = instrument.detune;\r\n            let modDetuneEnd: number = instrument.detune;\r\n            if (this.isModActive(Config.modulators.dictionary[\"detune\"].index, channelIndex, tone.instrumentIndex)) {\r\n                modDetuneStart = this.getModValue(Config.modulators.dictionary[\"detune\"].index, channelIndex, tone.instrumentIndex, false) + Config.detuneCenter;\r\n                modDetuneEnd = this.getModValue(Config.modulators.dictionary[\"detune\"].index, channelIndex, tone.instrumentIndex, true) + Config.detuneCenter;\r\n            }\r\n            if (this.isModActive(Config.modulators.dictionary[\"song detune\"].index, channelIndex, tone.instrumentIndex)) {\r\n                modDetuneStart += 4 * this.getModValue(Config.modulators.dictionary[\"song detune\"].index, channelIndex, tone.instrumentIndex, false);\r\n                modDetuneEnd += 4 * this.getModValue(Config.modulators.dictionary[\"song detune\"].index, channelIndex, tone.instrumentIndex, true);\r\n            }\r\n            intervalStart += Synth.detuneToCents((modDetuneStart) * envelopeStart) * Config.pitchesPerOctave / (12.0 * 100.0);\r\n            intervalEnd += Synth.detuneToCents((modDetuneEnd) * envelopeEnd) * Config.pitchesPerOctave / (12.0 * 100.0);\r\n        }\r\n\r\n        if (effectsIncludeVibrato(instrument.effects)) {\r\n            let delayTicks: number;\r\n            let vibratoAmplitudeStart: number;\r\n            let vibratoAmplitudeEnd: number;\r\n            // Custom vibrato\r\n            if (instrument.vibrato == Config.vibratos.length) {\r\n                delayTicks = instrument.vibratoDelay * 2; // Delay was changed from parts to ticks in BB v9\r\n                // Special case: if vibrato delay is max, NEVER vibrato.\r\n                if (instrument.vibratoDelay == Config.modulators.dictionary[\"vibrato delay\"].maxRawVol)\r\n                    delayTicks = Number.POSITIVE_INFINITY;\r\n                vibratoAmplitudeStart = instrument.vibratoDepth;\r\n                vibratoAmplitudeEnd = vibratoAmplitudeStart;\r\n            } else {\r\n                delayTicks = Config.vibratos[instrument.vibrato].delayTicks;\r\n                vibratoAmplitudeStart = Config.vibratos[instrument.vibrato].amplitude;\r\n                vibratoAmplitudeEnd = vibratoAmplitudeStart;\r\n            }\r\n\r\n            if (this.isModActive(Config.modulators.dictionary[\"vibrato delay\"].index, channelIndex, tone.instrumentIndex)) {\r\n                delayTicks = this.getModValue(Config.modulators.dictionary[\"vibrato delay\"].index, channelIndex, tone.instrumentIndex, false) * 2; // Delay was changed from parts to ticks in BB v9\r\n                if (delayTicks == Config.modulators.dictionary[\"vibrato delay\"].maxRawVol * 2)\r\n                    delayTicks = Number.POSITIVE_INFINITY;\r\n\r\n            }\r\n\r\n            if (this.isModActive(Config.modulators.dictionary[\"vibrato depth\"].index, channelIndex, tone.instrumentIndex)) {\r\n                vibratoAmplitudeStart = this.getModValue(Config.modulators.dictionary[\"vibrato depth\"].index, channelIndex, tone.instrumentIndex, false) / 25;\r\n                vibratoAmplitudeEnd = this.getModValue(Config.modulators.dictionary[\"vibrato depth\"].index, channelIndex, tone.instrumentIndex, true) / 25;\r\n            }\r\n\r\n\r\n            // To maintain pitch continuity, (mostly for picked string which retriggers impulse\r\n            // otherwise) remember the vibrato at the end of this run and reuse it at the start\r\n            // of the next run if available.\r\n            let vibratoStart: number;\r\n            if (tone.prevVibrato != null) {\r\n                vibratoStart = tone.prevVibrato;\r\n            } else {\r\n                let lfoStart: number = Synth.getLFOAmplitude(instrument, secondsPerPart * instrument.LFOtime);\r\n                const vibratoDepthEnvelopeStart: number = envelopeStarts[EnvelopeComputeIndex.vibratoDepth];\r\n                vibratoStart = vibratoAmplitudeStart * lfoStart * vibratoDepthEnvelopeStart;\r\n                if (delayTicks > 0.0) {\r\n                    const ticksUntilVibratoStart: number = delayTicks - envelopeComputer.noteTicksStart;\r\n                    vibratoStart *= Math.max(0.0, Math.min(1.0, 1.0 - ticksUntilVibratoStart / 2.0));\r\n                }\r\n            }\r\n\r\n            let lfoEnd: number = Synth.getLFOAmplitude(instrument, secondsPerPart * instrument.nextLFOtime);\r\n            const vibratoDepthEnvelopeEnd: number = envelopeEnds[EnvelopeComputeIndex.vibratoDepth];\r\n            if (instrument.type != InstrumentType.mod) {\r\n                let vibratoEnd: number = vibratoAmplitudeEnd * lfoEnd * vibratoDepthEnvelopeEnd;\r\n                if (delayTicks > 0.0) {\r\n                    const ticksUntilVibratoEnd: number = delayTicks - envelopeComputer.noteTicksEnd;\r\n                    vibratoEnd *= Math.max(0.0, Math.min(1.0, 1.0 - ticksUntilVibratoEnd / 2.0));\r\n                }\r\n\r\n                tone.prevVibrato = vibratoEnd;\r\n\r\n                intervalStart += vibratoStart;\r\n                intervalEnd += vibratoEnd;\r\n            }\r\n        }\r\n\r\n        if ((!transition.isSeamless && !tone.forceContinueAtStart) || tone.prevNote == null) {\r\n            // Fade in the beginning of the note.\r\n            const fadeInSeconds: number = instrument.getFadeInSeconds();\r\n            if (fadeInSeconds > 0.0) {\r\n                fadeExpressionStart *= Math.min(1.0, envelopeComputer.noteSecondsStart / fadeInSeconds);\r\n                fadeExpressionEnd *= Math.min(1.0, envelopeComputer.noteSecondsEnd / fadeInSeconds);\r\n            }\r\n        }\r\n\r\n        if (instrument.type == InstrumentType.drumset && tone.drumsetPitch == null) {\r\n            // It's possible that the note will change while the user is editing it,\r\n            // but the tone's pitches don't get updated because the tone has already\r\n            // ended and is fading out. To avoid an array index out of bounds error, clamp the pitch.\r\n            tone.drumsetPitch = tone.pitches[0];\r\n            if (tone.note != null) tone.drumsetPitch += tone.note.pickMainInterval();\r\n            tone.drumsetPitch = Math.max(0, Math.min(Config.drumCount - 1, tone.drumsetPitch));\r\n        }\r\n\r\n        let noteFilterExpression: number = envelopeComputer.lowpassCutoffDecayVolumeCompensation;\r\n        if (!effectsIncludeNoteFilter(instrument.effects)) {\r\n            tone.noteFilterCount = 0;\r\n        } else {\r\n\r\n            const noteAllFreqsEnvelopeStart: number = envelopeStarts[EnvelopeComputeIndex.noteFilterAllFreqs];\r\n            const noteAllFreqsEnvelopeEnd: number = envelopeEnds[EnvelopeComputeIndex.noteFilterAllFreqs];\r\n\r\n            // Simple note filter\r\n            if (instrument.noteFilterType) {\r\n                const noteFreqEnvelopeStart: number = envelopeStarts[EnvelopeComputeIndex.noteFilterFreq0];\r\n                const noteFreqEnvelopeEnd: number = envelopeEnds[EnvelopeComputeIndex.noteFilterFreq0];\r\n                const notePeakEnvelopeStart: number = envelopeStarts[EnvelopeComputeIndex.noteFilterGain0];\r\n                const notePeakEnvelopeEnd: number = envelopeEnds[EnvelopeComputeIndex.noteFilterGain0];\r\n\r\n                startPoint!.toCoefficients(Synth.tempFilterStartCoefficients, this.samplesPerSecond, noteAllFreqsEnvelopeStart * noteFreqEnvelopeStart, notePeakEnvelopeStart);\r\n                endPoint!.toCoefficients(Synth.tempFilterEndCoefficients, this.samplesPerSecond, noteAllFreqsEnvelopeEnd * noteFreqEnvelopeEnd, notePeakEnvelopeEnd);\r\n\r\n                if (tone.noteFilters.length < 1) tone.noteFilters[0] = new DynamicBiquadFilter();\r\n                tone.noteFilters[0].loadCoefficientsWithGradient(Synth.tempFilterStartCoefficients, Synth.tempFilterEndCoefficients, 1.0 / roundedSamplesPerTick, startPoint!.type == FilterType.lowPass);\r\n                noteFilterExpression *= startPoint!.getVolumeCompensationMult();\r\n\r\n                tone.noteFilterCount = 1;\r\n            }\r\n            else {\r\n                const noteFilterSettings: FilterSettings = (instrument.tmpNoteFilterStart != null) ? instrument.tmpNoteFilterStart : instrument.noteFilter;\r\n\r\n                for (let i: number = 0; i < noteFilterSettings.controlPointCount; i++) {\r\n                    const noteFreqEnvelopeStart: number = envelopeStarts[EnvelopeComputeIndex.noteFilterFreq0 + i];\r\n                    const noteFreqEnvelopeEnd: number = envelopeEnds[EnvelopeComputeIndex.noteFilterFreq0 + i];\r\n                    const notePeakEnvelopeStart: number = envelopeStarts[EnvelopeComputeIndex.noteFilterGain0 + i];\r\n                    const notePeakEnvelopeEnd: number = envelopeEnds[EnvelopeComputeIndex.noteFilterGain0 + i];\r\n                    let startPoint: FilterControlPoint = noteFilterSettings.controlPoints[i];\r\n                    const endPoint: FilterControlPoint = (instrument.tmpNoteFilterEnd != null && instrument.tmpNoteFilterEnd.controlPoints[i] != null) ? instrument.tmpNoteFilterEnd.controlPoints[i] : noteFilterSettings.controlPoints[i];\r\n\r\n                    // If switching dot type, do it all at once and do not try to interpolate since no valid interpolation exists.\r\n                    if (startPoint.type != endPoint.type) {\r\n                        startPoint = endPoint;\r\n                    }\r\n\r\n                    startPoint.toCoefficients(Synth.tempFilterStartCoefficients, this.samplesPerSecond, noteAllFreqsEnvelopeStart * noteFreqEnvelopeStart, notePeakEnvelopeStart);\r\n                    endPoint.toCoefficients(Synth.tempFilterEndCoefficients, this.samplesPerSecond, noteAllFreqsEnvelopeEnd * noteFreqEnvelopeEnd, notePeakEnvelopeEnd);\r\n                    if (tone.noteFilters.length <= i) tone.noteFilters[i] = new DynamicBiquadFilter();\r\n                    tone.noteFilters[i].loadCoefficientsWithGradient(Synth.tempFilterStartCoefficients, Synth.tempFilterEndCoefficients, 1.0 / roundedSamplesPerTick, startPoint.type == FilterType.lowPass);\r\n                    noteFilterExpression *= startPoint.getVolumeCompensationMult();\r\n                }\r\n                tone.noteFilterCount = noteFilterSettings.controlPointCount;\r\n            }\r\n        }\r\n\r\n        if (instrument.type == InstrumentType.drumset) {\r\n            const drumsetFilterEnvelope: Envelope = instrument.getDrumsetEnvelope(tone.drumsetPitch!);\r\n            // If the drumset lowpass cutoff decays, compensate by increasing expression.\r\n            noteFilterExpression *= EnvelopeComputer.getLowpassCutoffDecayVolumeCompensation(drumsetFilterEnvelope)\r\n\r\n            // Drumset filters use the same envelope timing as the rest of the envelopes, but do not include support for slide transitions.\r\n            let drumsetFilterEnvelopeStart: number = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, envelopeComputer.noteSecondsStart, beatsPerPart * partTimeStart, envelopeComputer.noteSizeStart);\r\n            let drumsetFilterEnvelopeEnd: number = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, envelopeComputer.noteSecondsEnd, beatsPerPart * partTimeEnd, envelopeComputer.noteSizeEnd);\r\n\r\n            // Apply slide interpolation to drumset envelope.\r\n            if (envelopeComputer.prevSlideStart) {\r\n                const other: number = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, envelopeComputer.prevNoteSecondsStart, beatsPerPart * partTimeStart, envelopeComputer.prevNoteSize);\r\n                drumsetFilterEnvelopeStart += (other - drumsetFilterEnvelopeStart) * envelopeComputer.prevSlideRatioStart;\r\n            }\r\n            if (envelopeComputer.prevSlideEnd) {\r\n                const other: number = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, envelopeComputer.prevNoteSecondsEnd, beatsPerPart * partTimeEnd, envelopeComputer.prevNoteSize);\r\n                drumsetFilterEnvelopeEnd += (other - drumsetFilterEnvelopeEnd) * envelopeComputer.prevSlideRatioEnd;\r\n            }\r\n            if (envelopeComputer.nextSlideStart) {\r\n                const other: number = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, 0.0, beatsPerPart * partTimeStart, envelopeComputer.nextNoteSize);\r\n                drumsetFilterEnvelopeStart += (other - drumsetFilterEnvelopeStart) * envelopeComputer.nextSlideRatioStart;\r\n            }\r\n            if (envelopeComputer.nextSlideEnd) {\r\n                const other: number = EnvelopeComputer.computeEnvelope(drumsetFilterEnvelope, 0.0, beatsPerPart * partTimeEnd, envelopeComputer.nextNoteSize);\r\n                drumsetFilterEnvelopeEnd += (other - drumsetFilterEnvelopeEnd) * envelopeComputer.nextSlideRatioEnd;\r\n            }\r\n\r\n            const point: FilterControlPoint = this.tempDrumSetControlPoint;\r\n            point.type = FilterType.lowPass;\r\n            point.gain = FilterControlPoint.getRoundedSettingValueFromLinearGain(0.5);\r\n            point.freq = FilterControlPoint.getRoundedSettingValueFromHz(8000.0);\r\n            // Drumset envelopes are warped to better imitate the legacy simplified 2nd order lowpass at ~48000Hz that I used to use.\r\n            point.toCoefficients(Synth.tempFilterStartCoefficients, this.samplesPerSecond, drumsetFilterEnvelopeStart * (1.0 + drumsetFilterEnvelopeStart), 1.0);\r\n            point.toCoefficients(Synth.tempFilterEndCoefficients, this.samplesPerSecond, drumsetFilterEnvelopeEnd * (1.0 + drumsetFilterEnvelopeEnd), 1.0);\r\n            if (tone.noteFilters.length == tone.noteFilterCount) tone.noteFilters[tone.noteFilterCount] = new DynamicBiquadFilter();\r\n            tone.noteFilters[tone.noteFilterCount].loadCoefficientsWithGradient(Synth.tempFilterStartCoefficients, Synth.tempFilterEndCoefficients, 1.0 / roundedSamplesPerTick, true);\r\n            tone.noteFilterCount++;\r\n        }\r\n\r\n        noteFilterExpression = Math.min(3.0, noteFilterExpression);\r\n\r\n        if (instrument.type == InstrumentType.fm) {\r\n            // phase modulation!\r\n\r\n            let sineExpressionBoost: number = 1.0;\r\n            let totalCarrierExpression: number = 0.0;\r\n\r\n            let arpeggioInterval: number = 0;\r\n            const arpeggiates: boolean = chord.arpeggiates;\r\n            if (tone.pitchCount > 1 && arpeggiates) {\r\n                const arpeggio: number = Math.floor(instrument.arpTime / Config.ticksPerArpeggio);\r\n                arpeggioInterval = tone.pitches[getArpeggioPitchIndex(tone.pitchCount, instrument.fastTwoNoteArp, arpeggio)] - tone.pitches[0];\r\n            }\r\n\r\n            const carrierCount: number = Config.algorithms[instrument.algorithm].carrierCount;\r\n            for (let i: number = 0; i < Config.operatorCount; i++) {\r\n\r\n                const associatedCarrierIndex: number = Config.algorithms[instrument.algorithm].associatedCarrier[i] - 1;\r\n                const pitch: number = tone.pitches[arpeggiates ? 0 : ((i < tone.pitchCount) ? i : ((associatedCarrierIndex < tone.pitchCount) ? associatedCarrierIndex : 0))];\r\n                const freqMult = Config.operatorFrequencies[instrument.operators[i].frequency].mult;\r\n                const interval = Config.operatorCarrierInterval[associatedCarrierIndex] + arpeggioInterval;\r\n                const pitchStart: number = basePitch + (pitch + intervalStart) * intervalScale + interval;\r\n                const pitchEnd: number = basePitch + (pitch + intervalEnd) * intervalScale + interval;\r\n                const baseFreqStart: number = Instrument.frequencyFromPitch(pitchStart);\r\n                const baseFreqEnd: number = Instrument.frequencyFromPitch(pitchEnd);\r\n                const hzOffset: number = Config.operatorFrequencies[instrument.operators[i].frequency].hzOffset;\r\n                const targetFreqStart: number = freqMult * baseFreqStart + hzOffset;\r\n                const targetFreqEnd: number = freqMult * baseFreqEnd + hzOffset;\r\n\r\n                const freqEnvelopeStart: number = envelopeStarts[EnvelopeComputeIndex.operatorFrequency0 + i];\r\n                const freqEnvelopeEnd: number = envelopeEnds[EnvelopeComputeIndex.operatorFrequency0 + i];\r\n                let freqStart: number;\r\n                let freqEnd: number;\r\n                if (freqEnvelopeStart != 1.0 || freqEnvelopeEnd != 1.0) {\r\n                    freqStart = Math.pow(2.0, Math.log2(targetFreqStart / baseFreqStart) * freqEnvelopeStart) * baseFreqStart;\r\n                    freqEnd = Math.pow(2.0, Math.log2(targetFreqEnd / baseFreqEnd) * freqEnvelopeEnd) * baseFreqEnd;\r\n                } else {\r\n                    freqStart = targetFreqStart;\r\n                    freqEnd = targetFreqEnd;\r\n                }\r\n                tone.phaseDeltas[i] = freqStart * sampleTime;\r\n                tone.phaseDeltaScales[i] = Math.pow(freqEnd / freqStart, 1.0 / roundedSamplesPerTick);\r\n\r\n                let amplitudeStart: number = instrument.operators[i].amplitude;\r\n                let amplitudeEnd: number = instrument.operators[i].amplitude;\r\n                if (this.isModActive(Config.modulators.dictionary[\"fm slider 1\"].index + i, channelIndex, tone.instrumentIndex)) {\r\n                    amplitudeStart *= this.getModValue(Config.modulators.dictionary[\"fm slider 1\"].index + i, channelIndex, tone.instrumentIndex, false) / 15.0;\r\n                    amplitudeEnd *= this.getModValue(Config.modulators.dictionary[\"fm slider 1\"].index + i, channelIndex, tone.instrumentIndex, true) / 15.0;\r\n                }\r\n\r\n                const amplitudeCurveStart: number = Synth.operatorAmplitudeCurve(amplitudeStart);\r\n                const amplitudeCurveEnd: number = Synth.operatorAmplitudeCurve(amplitudeEnd);\r\n                const amplitudeMultStart: number = amplitudeCurveStart * Config.operatorFrequencies[instrument.operators[i].frequency].amplitudeSign;\r\n                const amplitudeMultEnd: number = amplitudeCurveEnd * Config.operatorFrequencies[instrument.operators[i].frequency].amplitudeSign;\r\n\r\n                let expressionStart: number = amplitudeMultStart;\r\n                let expressionEnd: number = amplitudeMultEnd;\r\n\r\n\r\n                if (i < carrierCount) {\r\n                    // carrier\r\n                    let pitchExpressionStart: number;\r\n                    if (tone.prevPitchExpressions[i] != null) {\r\n                        pitchExpressionStart = tone.prevPitchExpressions[i]!;\r\n                    } else {\r\n                        pitchExpressionStart = Math.pow(2.0, -(pitchStart - expressionReferencePitch) / pitchDamping);\r\n                    }\r\n                    const pitchExpressionEnd: number = Math.pow(2.0, -(pitchEnd - expressionReferencePitch) / pitchDamping);\r\n                    tone.prevPitchExpressions[i] = pitchExpressionEnd;\r\n                    expressionStart *= pitchExpressionStart;\r\n                    expressionEnd *= pitchExpressionEnd;\r\n\r\n                    totalCarrierExpression += amplitudeCurveEnd;\r\n                } else {\r\n                    // modulator\r\n                    expressionStart *= Config.sineWaveLength * 1.5;\r\n                    expressionEnd *= Config.sineWaveLength * 1.5;\r\n\r\n                    sineExpressionBoost *= 1.0 - Math.min(1.0, instrument.operators[i].amplitude / 15);\r\n                }\r\n\r\n                expressionStart *= envelopeStarts[EnvelopeComputeIndex.operatorAmplitude0 + i];\r\n                expressionEnd *= envelopeEnds[EnvelopeComputeIndex.operatorAmplitude0 + i];\r\n\r\n                // Check for mod-related volume delta\r\n                // @jummbus - This amplification is also applied to modulator FM operators which distorts the sound.\r\n                // The fix is to apply this only to carriers, but as this is a legacy bug and it can cause some interesting sounds, it's left in.\r\n                // You can use the mix volume modulator instead to avoid this effect.\r\n\r\n                if (this.isModActive(Config.modulators.dictionary[\"note volume\"].index, channelIndex, tone.instrumentIndex)) {\r\n                    // Linear falloff below 0, normal volume formula above 0. Seems to work best for scaling since the normal volume mult formula has a big gap from -25 to -24.\r\n                    const startVal: number = this.getModValue(Config.modulators.dictionary[\"note volume\"].index, channelIndex, tone.instrumentIndex, false);\r\n                    const endVal: number = this.getModValue(Config.modulators.dictionary[\"note volume\"].index, channelIndex, tone.instrumentIndex, true);\r\n                    expressionStart *= ((startVal <= 0) ? ((startVal + Config.volumeRange / 2) / (Config.volumeRange / 2)) : Synth.instrumentVolumeToVolumeMult(startVal));\r\n                    expressionEnd *= ((endVal <= 0) ? ((endVal + Config.volumeRange / 2) / (Config.volumeRange / 2)) : Synth.instrumentVolumeToVolumeMult(endVal));\r\n                }\r\n\r\n                tone.operatorExpressions[i] = expressionStart;\r\n                tone.operatorExpressionDeltas[i] = (expressionEnd - expressionStart) / roundedSamplesPerTick;\r\n\r\n            }\r\n\r\n            sineExpressionBoost *= (Math.pow(2.0, (2.0 - 1.4 * instrument.feedbackAmplitude / 15.0)) - 1.0) / 3.0;\r\n            sineExpressionBoost *= 1.0 - Math.min(1.0, Math.max(0.0, totalCarrierExpression - 1) / 2.0);\r\n            sineExpressionBoost = 1.0 + sineExpressionBoost * 3.0;\r\n            const expressionStart: number = baseExpression * sineExpressionBoost * noteFilterExpression * fadeExpressionStart * chordExpressionStart * envelopeStarts[EnvelopeComputeIndex.noteVolume];\r\n            const expressionEnd: number = baseExpression * sineExpressionBoost * noteFilterExpression * fadeExpressionEnd * chordExpressionEnd * envelopeEnds[EnvelopeComputeIndex.noteVolume];\r\n            tone.expression = expressionStart;\r\n            tone.expressionDelta = (expressionEnd - expressionStart) / roundedSamplesPerTick;\r\n\r\n\r\n            let useFeedbackAmplitudeStart: number = instrument.feedbackAmplitude;\r\n            let useFeedbackAmplitudeEnd: number = instrument.feedbackAmplitude;\r\n            if (this.isModActive(Config.modulators.dictionary[\"fm feedback\"].index, channelIndex, tone.instrumentIndex)) {\r\n                useFeedbackAmplitudeStart *= this.getModValue(Config.modulators.dictionary[\"fm feedback\"].index, channelIndex, tone.instrumentIndex, false) / 15.0;\r\n                useFeedbackAmplitudeEnd *= this.getModValue(Config.modulators.dictionary[\"fm feedback\"].index, channelIndex, tone.instrumentIndex, true) / 15.0;\r\n            }\r\n\r\n            let feedbackAmplitudeStart: number = Config.sineWaveLength * 0.3 * useFeedbackAmplitudeStart / 15.0;\r\n            const feedbackAmplitudeEnd: number = Config.sineWaveLength * 0.3 * useFeedbackAmplitudeEnd / 15.0;\r\n\r\n            let feedbackStart: number = feedbackAmplitudeStart * envelopeStarts[EnvelopeComputeIndex.feedbackAmplitude];\r\n            let feedbackEnd: number = feedbackAmplitudeEnd * envelopeEnds[EnvelopeComputeIndex.feedbackAmplitude];\r\n            tone.feedbackMult = feedbackStart;\r\n            tone.feedbackDelta = (feedbackEnd - feedbackStart) / roundedSamplesPerTick;\r\n\r\n\r\n        } else {\r\n            const basePhaseDeltaScale: number = Math.pow(2.0, ((intervalEnd - intervalStart) * intervalScale / 12.0) / roundedSamplesPerTick);\r\n\r\n            let pitch: number = tone.pitches[0];\r\n            if (tone.pitchCount > 1 && (chord.arpeggiates || chord.customInterval)) {\r\n                const arpeggio: number = Math.floor(instrument.arpTime / Config.ticksPerArpeggio);\r\n                if (chord.customInterval) {\r\n                    const intervalOffset: number = tone.pitches[1 + getArpeggioPitchIndex(tone.pitchCount - 1, instrument.fastTwoNoteArp, arpeggio)] - tone.pitches[0];\r\n                    specialIntervalMult = Math.pow(2.0, intervalOffset / 12.0);\r\n                    tone.specialIntervalExpressionMult = Math.pow(2.0, -intervalOffset / pitchDamping);\r\n                } else {\r\n                    pitch = tone.pitches[getArpeggioPitchIndex(tone.pitchCount, instrument.fastTwoNoteArp, arpeggio)];\r\n                }\r\n            }\r\n\r\n            const startPitch: number = basePitch + (pitch + intervalStart) * intervalScale;\r\n            const endPitch: number = basePitch + (pitch + intervalEnd) * intervalScale;\r\n            let pitchExpressionStart: number;\r\n            // TODO: use the second element of prevPitchExpressions for the unison voice, compute a separate expression delta for it.\r\n            if (tone.prevPitchExpressions[0] != null) {\r\n                pitchExpressionStart = tone.prevPitchExpressions[0]!;\r\n            } else {\r\n                pitchExpressionStart = Math.pow(2.0, -(startPitch - expressionReferencePitch) / pitchDamping);\r\n            }\r\n            const pitchExpressionEnd: number = Math.pow(2.0, -(endPitch - expressionReferencePitch) / pitchDamping);\r\n            tone.prevPitchExpressions[0] = pitchExpressionEnd;\r\n            let settingsExpressionMult: number = baseExpression * noteFilterExpression;\r\n\r\n            if (instrument.type == InstrumentType.noise) {\r\n                settingsExpressionMult *= Config.chipNoises[instrument.chipNoise].expression;\r\n            }\r\n            if (instrument.type == InstrumentType.chip) {\r\n                settingsExpressionMult *= Config.chipWaves[instrument.chipWave].expression;\r\n            }\r\n            if (instrument.type == InstrumentType.pwm) {\r\n                const basePulseWidth: number = getPulseWidthRatio(instrument.pulseWidth);\r\n\r\n                // Check for PWM mods to this instrument\r\n                let pulseWidthModStart: number = basePulseWidth;\r\n                let pulseWidthModEnd: number = basePulseWidth;\r\n                if (this.isModActive(Config.modulators.dictionary[\"pulse width\"].index, channelIndex, tone.instrumentIndex)) {\r\n                    pulseWidthModStart = (this.getModValue(Config.modulators.dictionary[\"pulse width\"].index, channelIndex, tone.instrumentIndex, false)) / (Config.pulseWidthRange * 2);\r\n                    pulseWidthModEnd = (this.getModValue(Config.modulators.dictionary[\"pulse width\"].index, channelIndex, tone.instrumentIndex, true)) / (Config.pulseWidthRange * 2);\r\n                }\r\n\r\n                const pulseWidthStart: number = pulseWidthModStart * envelopeStarts[EnvelopeComputeIndex.pulseWidth];\r\n                const pulseWidthEnd: number = pulseWidthModEnd * envelopeEnds[EnvelopeComputeIndex.pulseWidth];\r\n                tone.pulseWidth = pulseWidthStart;\r\n                tone.pulseWidthDelta = (pulseWidthEnd - pulseWidthStart) / roundedSamplesPerTick;\r\n            }\r\n            if (instrument.type == InstrumentType.pickedString) {\r\n                // Check for sustain mods\r\n                let useSustainStart: number = instrument.stringSustain;\r\n                let useSustainEnd: number = instrument.stringSustain;\r\n                if (this.isModActive(Config.modulators.dictionary[\"sustain\"].index, channelIndex, tone.instrumentIndex)) {\r\n                    useSustainStart = this.getModValue(Config.modulators.dictionary[\"sustain\"].index, channelIndex, tone.instrumentIndex, false);\r\n                    useSustainEnd = this.getModValue(Config.modulators.dictionary[\"sustain\"].index, channelIndex, tone.instrumentIndex, true);\r\n                }\r\n\r\n                tone.stringSustainStart = useSustainStart;\r\n                tone.stringSustainEnd = useSustainEnd;\r\n\r\n                // Increase expression to compensate for string decay.\r\n                settingsExpressionMult *= Math.pow(2.0, 0.7 * (1.0 - useSustainStart / (Config.stringSustainRange - 1)));\r\n\r\n            }\r\n\r\n            const startFreq: number = Instrument.frequencyFromPitch(startPitch);\r\n            if (instrument.type == InstrumentType.chip || instrument.type == InstrumentType.customChipWave || instrument.type == InstrumentType.harmonics || instrument.type == InstrumentType.pickedString) {\r\n                // These instruments have two waves at different frequencies for the unison feature.\r\n                const unison: Unison = Config.unisons[instrument.unison];\r\n                const voiceCountExpression: number = (instrument.type == InstrumentType.pickedString) ? 1 : unison.voices / 2.0;\r\n                settingsExpressionMult *= unison.expression * voiceCountExpression;\r\n                const unisonEnvelopeStart = envelopeStarts[EnvelopeComputeIndex.unison];\r\n                const unisonEnvelopeEnd = envelopeEnds[EnvelopeComputeIndex.unison];\r\n                const unisonAStart: number = Math.pow(2.0, (unison.offset + unison.spread) * unisonEnvelopeStart / 12.0);\r\n                const unisonAEnd: number = Math.pow(2.0, (unison.offset + unison.spread) * unisonEnvelopeEnd / 12.0);\r\n                const unisonBStart: number = Math.pow(2.0, (unison.offset - unison.spread) * unisonEnvelopeStart / 12.0) * specialIntervalMult;\r\n                const unisonBEnd: number = Math.pow(2.0, (unison.offset - unison.spread) * unisonEnvelopeEnd / 12.0) * specialIntervalMult;\r\n                tone.phaseDeltas[0] = startFreq * sampleTime * unisonAStart;\r\n                tone.phaseDeltas[1] = startFreq * sampleTime * unisonBStart;\r\n                tone.phaseDeltaScales[0] = basePhaseDeltaScale * Math.pow(unisonAEnd / unisonAStart, 1.0 / roundedSamplesPerTick);\r\n                tone.phaseDeltaScales[1] = basePhaseDeltaScale * Math.pow(unisonBEnd / unisonBStart, 1.0 / roundedSamplesPerTick);\r\n            } else {\r\n                tone.phaseDeltas[0] = startFreq * sampleTime;\r\n                tone.phaseDeltaScales[0] = basePhaseDeltaScale;\r\n            }\r\n\r\n            let expressionStart: number = settingsExpressionMult * fadeExpressionStart * chordExpressionStart * pitchExpressionStart * envelopeStarts[EnvelopeComputeIndex.noteVolume];\r\n            let expressionEnd: number = settingsExpressionMult * fadeExpressionEnd * chordExpressionEnd * pitchExpressionEnd * envelopeEnds[EnvelopeComputeIndex.noteVolume];\r\n\r\n            // Check for mod-related volume delta\r\n            if (this.isModActive(Config.modulators.dictionary[\"note volume\"].index, channelIndex, tone.instrumentIndex)) {\r\n                // Linear falloff below 0, normal volume formula above 0. Seems to work best for scaling since the normal volume mult formula has a big gap from -25 to -24.\r\n                const startVal: number = this.getModValue(Config.modulators.dictionary[\"note volume\"].index, channelIndex, tone.instrumentIndex, false);\r\n                const endVal: number = this.getModValue(Config.modulators.dictionary[\"note volume\"].index, channelIndex, tone.instrumentIndex, true)\r\n                expressionStart *= ((startVal <= 0) ? ((startVal + Config.volumeRange / 2) / (Config.volumeRange / 2)) : Synth.instrumentVolumeToVolumeMult(startVal));\r\n                expressionEnd *= ((endVal <= 0) ? ((endVal + Config.volumeRange / 2) / (Config.volumeRange / 2)) : Synth.instrumentVolumeToVolumeMult(endVal));\r\n            }\r\n\r\n            tone.expression = expressionStart;\r\n            tone.expressionDelta = (expressionEnd - expressionStart) / roundedSamplesPerTick;\r\n\r\n\r\n            if (instrument.type == InstrumentType.pickedString) {\r\n                let stringDecayStart: number;\r\n                if (tone.prevStringDecay != null) {\r\n                    stringDecayStart = tone.prevStringDecay;\r\n                } else {\r\n                    const sustainEnvelopeStart: number = tone.envelopeComputer.envelopeStarts[EnvelopeComputeIndex.stringSustain];\r\n                    stringDecayStart = 1.0 - Math.min(1.0, sustainEnvelopeStart * tone.stringSustainStart / (Config.stringSustainRange - 1));\r\n                }\r\n                const sustainEnvelopeEnd: number = tone.envelopeComputer.envelopeEnds[EnvelopeComputeIndex.stringSustain];\r\n                let stringDecayEnd: number = 1.0 - Math.min(1.0, sustainEnvelopeEnd * tone.stringSustainEnd / (Config.stringSustainRange - 1));\r\n                tone.prevStringDecay = stringDecayEnd;\r\n\r\n                const unison: Unison = Config.unisons[instrument.unison];\r\n                for (let i: number = tone.pickedStrings.length; i < unison.voices; i++) {\r\n                    tone.pickedStrings[i] = new PickedString();\r\n                }\r\n\r\n                if (tone.atNoteStart && !transition.continues && !tone.forceContinueAtStart) {\r\n                    for (const pickedString of tone.pickedStrings) {\r\n                        // Force the picked string to retrigger the attack impulse at the start of the note.\r\n                        pickedString.delayIndex = -1;\r\n                    }\r\n                }\r\n\r\n                for (let i: number = 0; i < unison.voices; i++) {\r\n                    tone.pickedStrings[i].update(this, instrumentState, tone, i, roundedSamplesPerTick, stringDecayStart, stringDecayEnd);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static getLFOAmplitude(instrument: Instrument, secondsIntoBar: number): number {\r\n        let effect: number = 0.0;\r\n        for (const vibratoPeriodSeconds of Config.vibratoTypes[instrument.vibratoType].periodsSeconds) {\r\n            effect += Math.sin(Math.PI * 2.0 * secondsIntoBar / vibratoPeriodSeconds);\r\n        }\r\n        return effect;\r\n    }\r\n\r\n\r\n    public static getInstrumentSynthFunction(instrument: Instrument): Function {\r\n        if (instrument.type == InstrumentType.fm) {\r\n            const fingerprint: string = instrument.algorithm + \"_\" + instrument.feedbackType;\r\n            if (Synth.fmSynthFunctionCache[fingerprint] == undefined) {\r\n                const synthSource: string[] = [];\r\n\r\n                for (const line of Synth.fmSourceTemplate) {\r\n                    if (line.indexOf(\"// CARRIER OUTPUTS\") != -1) {\r\n                        const outputs: string[] = [];\r\n                        for (let j: number = 0; j < Config.algorithms[instrument.algorithm].carrierCount; j++) {\r\n                            outputs.push(\"operator\" + j + \"Scaled\");\r\n                        }\r\n                        synthSource.push(line.replace(\"/*operator#Scaled*/\", outputs.join(\" + \")));\r\n                    } else if (line.indexOf(\"// INSERT OPERATOR COMPUTATION HERE\") != -1) {\r\n                        for (let j: number = Config.operatorCount - 1; j >= 0; j--) {\r\n                            for (const operatorLine of Synth.operatorSourceTemplate) {\r\n                                if (operatorLine.indexOf(\"/* + operator@Scaled*/\") != -1) {\r\n                                    let modulators = \"\";\r\n                                    for (const modulatorNumber of Config.algorithms[instrument.algorithm].modulatedBy[j]) {\r\n                                        modulators += \" + operator\" + (modulatorNumber - 1) + \"Scaled\";\r\n                                    }\r\n\r\n                                    const feedbackIndices: ReadonlyArray<number> = Config.feedbacks[instrument.feedbackType].indices[j];\r\n                                    if (feedbackIndices.length > 0) {\r\n                                        modulators += \" + feedbackMult * (\";\r\n                                        const feedbacks: string[] = [];\r\n                                        for (const modulatorNumber of feedbackIndices) {\r\n                                            feedbacks.push(\"operator\" + (modulatorNumber - 1) + \"Output\");\r\n                                        }\r\n                                        modulators += feedbacks.join(\" + \") + \")\";\r\n                                    }\r\n                                    synthSource.push(operatorLine.replace(/\\#/g, j + \"\").replace(\"/* + operator@Scaled*/\", modulators));\r\n                                } else {\r\n                                    synthSource.push(operatorLine.replace(/\\#/g, j + \"\"));\r\n                                }\r\n                            }\r\n                        }\r\n                    } else if (line.indexOf(\"#\") != -1) {\r\n                        for (let j: number = 0; j < Config.operatorCount; j++) {\r\n                            synthSource.push(line.replace(/\\#/g, j + \"\"));\r\n                        }\r\n                    } else {\r\n                        synthSource.push(line);\r\n                    }\r\n                }\r\n\r\n                //console.log(synthSource.join(\"\\n\"));\r\n\r\n                Synth.fmSynthFunctionCache[fingerprint] = new Function(\"synth\", \"bufferIndex\", \"roundedSamplesPerTick\", \"tone\", \"instrumentState\", synthSource.join(\"\\n\"));\r\n            }\r\n            return Synth.fmSynthFunctionCache[fingerprint];\r\n        } else if (instrument.type == InstrumentType.chip) {\r\n            return Synth.chipSynth;\r\n        } else if (instrument.type == InstrumentType.customChipWave) {\r\n            return Synth.chipSynth;\r\n        } else if (instrument.type == InstrumentType.harmonics) {\r\n            return Synth.harmonicsSynth;\r\n        } else if (instrument.type == InstrumentType.pwm) {\r\n            return Synth.pulseWidthSynth;\r\n        } else if (instrument.type == InstrumentType.pickedString) {\r\n            return Synth.pickedStringSynth;\r\n        } else if (instrument.type == InstrumentType.noise) {\r\n            return Synth.noiseSynth;\r\n        } else if (instrument.type == InstrumentType.spectrum) {\r\n            return Synth.spectrumSynth;\r\n        } else if (instrument.type == InstrumentType.drumset) {\r\n            return Synth.drumsetSynth;\r\n        } else if (instrument.type == InstrumentType.mod) {\r\n            return Synth.modSynth;\r\n        } else {\r\n            throw new Error(\"Unrecognized instrument type: \" + instrument.type);\r\n        }\r\n    }\r\n\r\n    private static chipSynth(synth: Synth, bufferIndex: number, roundedSamplesPerTick: number, tone: Tone, instrumentState: InstrumentState): void {\r\n        const sign: number = instrumentState.invertWave ? -1 : 1;\r\n        const aliases: boolean = (effectsIncludeDistortion(instrumentState.effects) && instrumentState.aliases);\r\n        const data: Float32Array = synth.tempMonoInstrumentSampleBuffer!;\r\n        const wave: Float32Array = instrumentState.wave!;\r\n        const volumeScale = instrumentState.volumeScale;\r\n\r\n        // For all but aliasing custom chip, the first sample is duplicated at the end, so don't double-count it.\r\n        const waveLength: number = (aliases && instrumentState.type == InstrumentType.customChipWave) ? wave.length : wave.length - 1;\r\n\r\n        const unisonSign: number = tone.specialIntervalExpressionMult * instrumentState.unison!.sign;\r\n        if (instrumentState.unison!.voices == 1 && !instrumentState.chord!.customInterval) tone.phases[1] = tone.phases[0];\r\n        let phaseDeltaA: number = tone.phaseDeltas[0] * waveLength;\r\n        let phaseDeltaB: number = tone.phaseDeltas[1] * waveLength;\r\n        const phaseDeltaScaleA: number = +tone.phaseDeltaScales[0];\r\n        const phaseDeltaScaleB: number = +tone.phaseDeltaScales[1];\r\n        let expression: number = +tone.expression;\r\n        const expressionDelta: number = +tone.expressionDelta;\r\n        let phaseA: number = (tone.phases[0] % 1) * waveLength;\r\n        let phaseB: number = (tone.phases[1] % 1) * waveLength;\r\n\r\n        const filters: DynamicBiquadFilter[] = tone.noteFilters;\r\n        const filterCount: number = tone.noteFilterCount | 0;\r\n        let initialFilterInput1: number = +tone.initialNoteFilterInput1;\r\n        let initialFilterInput2: number = +tone.initialNoteFilterInput2;\r\n        const applyFilters: Function = Synth.applyFilters;\r\n        let prevWaveIntegralA: number = 0;\r\n        let prevWaveIntegralB: number = 0;\r\n\r\n        if (!aliases) {\r\n            const phaseAInt: number = phaseA | 0;\r\n            const phaseBInt: number = phaseB | 0;\r\n            const indexA: number = phaseAInt % waveLength;\r\n            const indexB: number = phaseBInt % waveLength;\r\n            const phaseRatioA: number = phaseA - phaseAInt;\r\n            const phaseRatioB: number = phaseB - phaseBInt;\r\n            prevWaveIntegralA = +wave[indexA];\r\n            prevWaveIntegralB = +wave[indexB];\r\n            prevWaveIntegralA += (wave[indexA + 1] - prevWaveIntegralA) * phaseRatioA;\r\n            prevWaveIntegralB += (wave[indexB + 1] - prevWaveIntegralB) * phaseRatioB;\r\n        }\r\n\r\n        const stopIndex: number = bufferIndex + roundedSamplesPerTick;\r\n        for (let sampleIndex: number = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n\r\n            phaseA += phaseDeltaA;\r\n            phaseB += phaseDeltaB;\r\n\r\n            let waveA: number;\r\n            let waveB: number;\r\n            let inputSample: number;\r\n\r\n            if (aliases) {\r\n                waveA = wave[(0 | phaseA) % waveLength];\r\n                waveB = wave[(0 | phaseB) % waveLength];\r\n                inputSample = waveA + waveB;\r\n            } else {\r\n                const phaseAInt: number = phaseA | 0;\r\n                const phaseBInt: number = phaseB | 0;\r\n                const indexA: number = phaseAInt % waveLength;\r\n                const indexB: number = phaseBInt % waveLength;\r\n                let nextWaveIntegralA: number = wave[indexA];\r\n                let nextWaveIntegralB: number = wave[indexB];\r\n                const phaseRatioA: number = phaseA - phaseAInt;\r\n                const phaseRatioB: number = phaseB - phaseBInt;\r\n                nextWaveIntegralA += (wave[indexA + 1] - nextWaveIntegralA) * phaseRatioA;\r\n                nextWaveIntegralB += (wave[indexB + 1] - nextWaveIntegralB) * phaseRatioB;\r\n                waveA = (nextWaveIntegralA - prevWaveIntegralA) / phaseDeltaA;\r\n                waveB = (nextWaveIntegralB - prevWaveIntegralB) / phaseDeltaB;\r\n                prevWaveIntegralA = nextWaveIntegralA;\r\n                prevWaveIntegralB = nextWaveIntegralB;\r\n                inputSample = waveA + waveB * unisonSign;\r\n            }\r\n\r\n            inputSample *= sign;\r\n\r\n            const sample: number = applyFilters(inputSample * volumeScale, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n            initialFilterInput2 = initialFilterInput1;\r\n            initialFilterInput1 = inputSample * volumeScale;\r\n\r\n            phaseDeltaA *= phaseDeltaScaleA;\r\n            phaseDeltaB *= phaseDeltaScaleB;\r\n\r\n            const output: number = sample * expression;\r\n            expression += expressionDelta;\r\n\r\n            data[sampleIndex] += output;\r\n        }\r\n\r\n        tone.phases[0] = phaseA / waveLength;\r\n        tone.phases[1] = phaseB / waveLength;\r\n        tone.phaseDeltas[0] = phaseDeltaA / waveLength;\r\n        tone.phaseDeltas[1] = phaseDeltaB / waveLength;\r\n        tone.expression = expression;\r\n\r\n\r\n        synth.sanitizeFilters(filters);\r\n        tone.initialNoteFilterInput1 = initialFilterInput1;\r\n        tone.initialNoteFilterInput2 = initialFilterInput2;\r\n    }\r\n\r\n    private static harmonicsSynth(synth: Synth, bufferIndex: number, roundedSamplesPerTick: number, tone: Tone, instrumentState: InstrumentState): void {\r\n        const sign: number = instrumentState.invertWave ? -1 : 1;\r\n        const data: Float32Array = synth.tempMonoInstrumentSampleBuffer!;\r\n        const wave: Float32Array = instrumentState.wave!;\r\n        const waveLength: number = wave.length - 1; // The first sample is duplicated at the end, don't double-count it.\r\n\r\n        const unisonSign: number = tone.specialIntervalExpressionMult * instrumentState.unison!.sign;\r\n        if (instrumentState.unison!.voices == 1 && !instrumentState.chord!.customInterval) tone.phases[1] = tone.phases[0];\r\n        let phaseDeltaA: number = tone.phaseDeltas[0] * waveLength;\r\n        let phaseDeltaB: number = tone.phaseDeltas[1] * waveLength;\r\n        const phaseDeltaScaleA: number = +tone.phaseDeltaScales[0];\r\n        const phaseDeltaScaleB: number = +tone.phaseDeltaScales[1];\r\n        let expression: number = +tone.expression;\r\n        const expressionDelta: number = +tone.expressionDelta;\r\n        let phaseA: number = (tone.phases[0] % 1) * waveLength;\r\n        let phaseB: number = (tone.phases[1] % 1) * waveLength;\r\n\r\n        const filters: DynamicBiquadFilter[] = tone.noteFilters;\r\n        const filterCount: number = tone.noteFilterCount | 0;\r\n        let initialFilterInput1: number = +tone.initialNoteFilterInput1;\r\n        let initialFilterInput2: number = +tone.initialNoteFilterInput2;\r\n        const applyFilters: Function = Synth.applyFilters;\r\n\r\n        const phaseAInt: number = phaseA | 0;\r\n        const phaseBInt: number = phaseB | 0;\r\n        const indexA: number = phaseAInt % waveLength;\r\n        const indexB: number = phaseBInt % waveLength;\r\n        const phaseRatioA: number = phaseA - phaseAInt;\r\n        const phaseRatioB: number = phaseB - phaseBInt;\r\n        let prevWaveIntegralA: number = +wave[indexA];\r\n        let prevWaveIntegralB: number = +wave[indexB];\r\n        prevWaveIntegralA += (wave[indexA + 1] - prevWaveIntegralA) * phaseRatioA;\r\n        prevWaveIntegralB += (wave[indexB + 1] - prevWaveIntegralB) * phaseRatioB;\r\n\r\n        const stopIndex: number = bufferIndex + roundedSamplesPerTick;\r\n        for (let sampleIndex: number = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n\r\n            phaseA += phaseDeltaA;\r\n            phaseB += phaseDeltaB;\r\n\r\n            const phaseAInt: number = phaseA | 0;\r\n            const phaseBInt: number = phaseB | 0;\r\n            const indexA: number = phaseAInt % waveLength;\r\n            const indexB: number = phaseBInt % waveLength;\r\n            let nextWaveIntegralA: number = wave[indexA];\r\n            let nextWaveIntegralB: number = wave[indexB];\r\n            const phaseRatioA: number = phaseA - phaseAInt;\r\n            const phaseRatioB: number = phaseB - phaseBInt;\r\n            nextWaveIntegralA += (wave[indexA + 1] - nextWaveIntegralA) * phaseRatioA;\r\n            nextWaveIntegralB += (wave[indexB + 1] - nextWaveIntegralB) * phaseRatioB;\r\n            const waveA: number = (nextWaveIntegralA - prevWaveIntegralA) / phaseDeltaA;\r\n            const waveB: number = (nextWaveIntegralB - prevWaveIntegralB) / phaseDeltaB;\r\n            prevWaveIntegralA = nextWaveIntegralA;\r\n            prevWaveIntegralB = nextWaveIntegralB;\r\n\r\n            const inputSample: number = (waveA + waveB * unisonSign) * sign;\r\n            const sample: number = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n            initialFilterInput2 = initialFilterInput1;\r\n            initialFilterInput1 = inputSample;\r\n\r\n            phaseDeltaA *= phaseDeltaScaleA;\r\n            phaseDeltaB *= phaseDeltaScaleB;\r\n\r\n            const output: number = sample * expression;\r\n            expression += expressionDelta;\r\n\r\n            data[sampleIndex] += output;\r\n        }\r\n\r\n        tone.phases[0] = phaseA / waveLength;\r\n        tone.phases[1] = phaseB / waveLength;\r\n        tone.phaseDeltas[0] = phaseDeltaA / waveLength;\r\n        tone.phaseDeltas[1] = phaseDeltaB / waveLength;\r\n        tone.expression = expression;\r\n\r\n        synth.sanitizeFilters(filters);\r\n        tone.initialNoteFilterInput1 = initialFilterInput1;\r\n        tone.initialNoteFilterInput2 = initialFilterInput2;\r\n    }\r\n\r\n    private static pickedStringSynth(synth: Synth, bufferIndex: number, roundedSamplesPerTick: number, tone: Tone, instrumentState: InstrumentState): void {\r\n        // This algorithm is similar to the Karpluss-Strong algorithm in principle, but with an\r\n        // all-pass filter for dispersion and with more control over the impulse harmonics.\r\n        // The source code is processed as a string before being compiled, in order to\r\n        // handle the unison feature. If unison is disabled or set to none, then only one\r\n        // string voice is required, otherwise two string voices are required. We only want\r\n        // to compute the minimum possible number of string voices, so omit the code for\r\n        // processing extra ones if possible. Any line containing a \"#\" is duplicated for\r\n        // each required voice, replacing the \"#\" with the voice index.\r\n\r\n        const voiceCount: number = instrumentState.unison!.voices;\r\n        let pickedStringFunction: Function = Synth.pickedStringFunctionCache[voiceCount];\r\n        if (pickedStringFunction == undefined) {\r\n            let pickedStringSource: string = \"\";\r\n\r\n            pickedStringSource += `\r\n                const sign = instrumentState.invertWave ? -1 : 1;\r\n\t\t\t\tconst Config = beepbox.Config;\r\n\t\t\t\tconst Synth = beepbox.Synth;\r\n\t\t\t\tconst data = synth.tempMonoInstrumentSampleBuffer;\r\n\r\n\t\t\t\tlet pickedString# = tone.pickedStrings[#];\r\n\t\t\t\tlet allPassSample# = +pickedString#.allPassSample;\r\n\t\t\t\tlet allPassPrevInput# = +pickedString#.allPassPrevInput;\r\n\t\t\t\tlet shelfSample# = +pickedString#.shelfSample;\r\n\t\t\t\tlet shelfPrevInput# = +pickedString#.shelfPrevInput;\r\n\t\t\t\tlet fractionalDelaySample# = +pickedString#.fractionalDelaySample;\r\n\t\t\t\tconst delayLine# = pickedString#.delayLine;\r\n\t\t\t\tconst delayBufferMask# = (delayLine#.length - 1) >> 0;\r\n\t\t\t\tlet delayIndex# = pickedString#.delayIndex|0;\r\n\t\t\t\tdelayIndex# = (delayIndex# & delayBufferMask#) + delayLine#.length;\r\n\t\t\t\tlet delayLength# = +pickedString#.prevDelayLength;\r\n\t\t\t\tconst delayLengthDelta# = +pickedString#.delayLengthDelta;\r\n\t\t\t\tlet allPassG# = +pickedString#.allPassG;\r\n\t\t\t\tlet shelfA1# = +pickedString#.shelfA1;\r\n\t\t\t\tlet shelfB0# = +pickedString#.shelfB0;\r\n\t\t\t\tlet shelfB1# = +pickedString#.shelfB1;\r\n\t\t\t\tconst allPassGDelta# = +pickedString#.allPassGDelta;\r\n\t\t\t\tconst shelfA1Delta# = +pickedString#.shelfA1Delta;\r\n\t\t\t\tconst shelfB0Delta# = +pickedString#.shelfB0Delta;\r\n\t\t\t\tconst shelfB1Delta# = +pickedString#.shelfB1Delta;\r\n\r\n\t\t\t\tlet expression = +tone.expression;\r\n\t\t\t\tconst expressionDelta = +tone.expressionDelta;\r\n\r\n\t\t\t\tconst unisonSign = tone.specialIntervalExpressionMult * instrumentState.unison.sign;\r\n\t\t\t\tconst delayResetOffset# = pickedString#.delayResetOffset|0;\r\n\r\n\t\t\t\tconst filters = tone.noteFilters;\r\n\t\t\t\tconst filterCount = tone.noteFilterCount|0;\r\n\t\t\t\tlet initialFilterInput1 = +tone.initialNoteFilterInput1;\r\n\t\t\t\tlet initialFilterInput2 = +tone.initialNoteFilterInput2;\r\n\t\t\t\tconst applyFilters = Synth.applyFilters;\r\n\r\n\t\t\t\tconst stopIndex = bufferIndex + runLength;\r\n\t\t\t\tfor (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n\t\t\t\t\tconst targetSampleTime# = delayIndex# - delayLength#;\r\n\t\t\t\t\tconst lowerIndex# = (targetSampleTime# + 0.125) | 0; // Offset to improve stability of all-pass filter.\r\n\t\t\t\t\tconst upperIndex# = lowerIndex# + 1;\r\n\t\t\t\t\tconst fractionalDelay# = upperIndex# - targetSampleTime#;\r\n\t\t\t\t\tconst fractionalDelayG# = (1.0 - fractionalDelay#) / (1.0 + fractionalDelay#); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\r\n\t\t\t\t\tconst prevInput# = delayLine#[lowerIndex# & delayBufferMask#];\r\n\t\t\t\t\tconst input# = delayLine#[upperIndex# & delayBufferMask#];\r\n\t\t\t\t\tfractionalDelaySample# = fractionalDelayG# * input# + prevInput# - fractionalDelayG# * fractionalDelaySample#;\r\n\r\n\t\t\t\t\tallPassSample# = fractionalDelaySample# * allPassG# + allPassPrevInput# - allPassG# * allPassSample#;\r\n\t\t\t\t\tallPassPrevInput# = fractionalDelaySample#;\r\n\r\n\t\t\t\t\tshelfSample# = shelfB0# * allPassSample# + shelfB1# * shelfPrevInput# - shelfA1# * shelfSample#;\r\n\t\t\t\t\tshelfPrevInput# = allPassSample#;\r\n\r\n\t\t\t\t\tdelayLine#[delayIndex# & delayBufferMask#] += shelfSample#;\r\n\t\t\t\t\tdelayLine#[(delayIndex# + delayResetOffset#) & delayBufferMask#] = 0.0;\r\n\t\t\t\t\tdelayIndex#++;\r\n\r\n\t\t\t\t\tconst inputSample = (`\r\n\r\n            const sampleList: string[] = [];\r\n            for (let voice: number = 0; voice < voiceCount; voice++) {\r\n                sampleList.push(\"fractionalDelaySample\" + voice + (voice == 1 ? \" * unisonSign\" : \"\"));\r\n            }\r\n\r\n            pickedStringSource += sampleList.join(\" + \");\r\n\r\n            pickedStringSource += `) * expression * sign;\r\n\t\t\t\t\tconst sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n\t\t\t\t\tinitialFilterInput2 = initialFilterInput1;\r\n\t\t\t\t\tinitialFilterInput1 = inputSample;\r\n\t\t\t\t\tdata[sampleIndex] += sample;\r\n\r\n\t\t\t\t\texpression += expressionDelta;\r\n\t\t\t\t\tdelayLength# += delayLengthDelta#;\r\n\t\t\t\t\tallPassG# += allPassGDelta#;\r\n\t\t\t\t\tshelfA1# += shelfA1Delta#;\r\n\t\t\t\t\tshelfB0# += shelfB0Delta#;\r\n\t\t\t\t\tshelfB1# += shelfB1Delta#;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Avoid persistent denormal or NaN values in the delay buffers and filter history.\r\n\t\t\t\tconst epsilon = (1.0e-24);\r\n\t\t\t\tif (!Number.isFinite(allPassSample#) || Math.abs(allPassSample#) < epsilon) allPassSample# = 0.0;\r\n\t\t\t\tif (!Number.isFinite(allPassPrevInput#) || Math.abs(allPassPrevInput#) < epsilon) allPassPrevInput# = 0.0;\r\n\t\t\t\tif (!Number.isFinite(shelfSample#) || Math.abs(shelfSample#) < epsilon) shelfSample# = 0.0;\r\n\t\t\t\tif (!Number.isFinite(shelfPrevInput#) || Math.abs(shelfPrevInput#) < epsilon) shelfPrevInput# = 0.0;\r\n\t\t\t\tif (!Number.isFinite(fractionalDelaySample#) || Math.abs(fractionalDelaySample#) < epsilon) fractionalDelaySample# = 0.0;\r\n\t\t\t\tpickedString#.allPassSample = allPassSample#;\r\n\t\t\t\tpickedString#.allPassPrevInput = allPassPrevInput#;\r\n\t\t\t\tpickedString#.shelfSample = shelfSample#;\r\n\t\t\t\tpickedString#.shelfPrevInput = shelfPrevInput#;\r\n\t\t\t\tpickedString#.fractionalDelaySample = fractionalDelaySample#;\r\n\t\t\t\tpickedString#.delayIndex = delayIndex#;\r\n\t\t\t\tpickedString#.prevDelayLength = delayLength#;\r\n\t\t\t\tpickedString#.allPassG = allPassG#;\r\n\t\t\t\tpickedString#.shelfA1 = shelfA1#;\r\n\t\t\t\tpickedString#.shelfB0 = shelfB0#;\r\n\t\t\t\tpickedString#.shelfB1 = shelfB1#;\r\n\r\n\t\t\t\ttone.expression = expression;\r\n\r\n\t\t\t\tsynth.sanitizeFilters(filters);\r\n\t\t\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\r\n\t\t\t\ttone.initialNoteFilterInput2 = initialFilterInput2;`\r\n\r\n            // Duplicate lines containing \"#\" for each voice and replace the \"#\" with the voice index.\r\n            pickedStringSource = pickedStringSource.replace(/^.*\\#.*$/mg, line => {\r\n                const lines = [];\r\n                for (let voice: number = 0; voice < voiceCount; voice++) {\r\n                    lines.push(line.replace(/\\#/g, String(voice)));\r\n                }\r\n                return lines.join(\"\\n\");\r\n            });\r\n\r\n            //console.log(pickedStringSource);\r\n            pickedStringFunction = new Function(\"synth\", \"bufferIndex\", \"runLength\", \"tone\", \"instrumentState\", pickedStringSource);\r\n            Synth.pickedStringFunctionCache[voiceCount] = pickedStringFunction;\r\n        }\r\n\r\n        pickedStringFunction(synth, bufferIndex, roundedSamplesPerTick, tone, instrumentState);\r\n    }\r\n\r\n    private static effectsSynth(synth: Synth, outputDataL: Float32Array, outputDataR: Float32Array, bufferIndex: number, runLength: number, instrumentState: InstrumentState): void {\r\n\r\n\r\n\r\n        // TODO: If automation is involved, don't assume sliders will stay at zero.\r\n        // @jummbus - ^ Correct, removed the non-zero checks as modulation can change them.\r\n\r\n        const usesDistortion: boolean = effectsIncludeDistortion(instrumentState.effects);\r\n        const usesBitcrusher: boolean = effectsIncludeBitcrusher(instrumentState.effects);\r\n        const usesEqFilter: boolean = instrumentState.eqFilterCount > 0;\r\n        const usesPanning: boolean = effectsIncludePanning(instrumentState.effects);\r\n        const usesChorus: boolean = effectsIncludeChorus(instrumentState.effects);\r\n        const usesEcho: boolean = effectsIncludeEcho(instrumentState.effects);\r\n        const usesReverb: boolean = effectsIncludeReverb(instrumentState.effects);\r\n        let signature: number = 0; if (usesDistortion) signature = signature | 1;\r\n        signature = signature << 1; if (usesBitcrusher) signature = signature | 1;\r\n        signature = signature << 1; if (usesEqFilter) signature = signature | 1;\r\n        signature = signature << 1; if (usesPanning) signature = signature | 1;\r\n        signature = signature << 1; if (usesChorus) signature = signature | 1;\r\n        signature = signature << 1; if (usesEcho) signature = signature | 1;\r\n        signature = signature << 1; if (usesReverb) signature = signature | 1;\r\n\r\n        let effectsFunction: Function = Synth.effectsFunctionCache[signature];\r\n        if (effectsFunction == undefined) {\r\n            let effectsSource: string = \"\";\r\n\r\n            const usesDelays: boolean = usesChorus || usesReverb || usesEcho;\r\n\r\n            effectsSource += `\r\n\t\t\t\tconst Config = beepbox.Config;\r\n\t\t\t\tconst tempMonoInstrumentSampleBuffer = synth.tempMonoInstrumentSampleBuffer;\r\n\r\n\t\t\t\tlet mixVolume = +instrumentState.mixVolume;\r\n\t\t\t\tconst mixVolumeDelta = +instrumentState.mixVolumeDelta;`\r\n\r\n            if (usesDelays) {\r\n                effectsSource += `\r\n\r\n\t\t\t\tlet delayInputMult = +instrumentState.delayInputMult;\r\n\t\t\t\tconst delayInputMultDelta = +instrumentState.delayInputMultDelta;`\r\n            }\r\n\r\n            if (usesDistortion) {\r\n                // Distortion can sometimes create noticeable aliasing.\r\n                // It seems the established industry best practice for distortion antialiasing\r\n                // is to upsample the inputs (\"zero stuffing\" followed by a brick wall lowpass\r\n                // at the original nyquist frequency), perform the distortion, then downsample\r\n                // (the lowpass again followed by dropping in-between samples). This is\r\n                // \"mathematically correct\" in that it preserves only the intended frequencies,\r\n                // but it has several unfortunate tradeoffs depending on the choice of filter,\r\n                // introducing latency and/or time smearing, since no true brick wall filter\r\n                // exists. For the time being, I've opted to instead generate in-between input\r\n                // samples using fractional delay all-pass filters, and after distorting them,\r\n                // I \"downsample\" these with a simple weighted sum.\r\n\r\n                effectsSource += `\r\n\r\n\t\t\t\tconst distortionBaseVolume = +Config.distortionBaseVolume;\r\n\t\t\t\tlet distortion = instrumentState.distortion;\r\n\t\t\t\tconst distortionDelta = instrumentState.distortionDelta;\r\n\t\t\t\tlet distortionDrive = instrumentState.distortionDrive;\r\n\t\t\t\tconst distortionDriveDelta = instrumentState.distortionDriveDelta;\r\n\t\t\t\tconst distortionFractionalResolution = 4.0;\r\n\t\t\t\tconst distortionOversampleCompensation = distortionBaseVolume / distortionFractionalResolution;\r\n\t\t\t\tconst distortionFractionalDelay1 = 1.0 / distortionFractionalResolution;\r\n\t\t\t\tconst distortionFractionalDelay2 = 2.0 / distortionFractionalResolution;\r\n\t\t\t\tconst distortionFractionalDelay3 = 3.0 / distortionFractionalResolution;\r\n\t\t\t\tconst distortionFractionalDelayG1 = (1.0 - distortionFractionalDelay1) / (1.0 + distortionFractionalDelay1); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\r\n\t\t\t\tconst distortionFractionalDelayG2 = (1.0 - distortionFractionalDelay2) / (1.0 + distortionFractionalDelay2); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\r\n\t\t\t\tconst distortionFractionalDelayG3 = (1.0 - distortionFractionalDelay3) / (1.0 + distortionFractionalDelay3); // Inlined version of FilterCoefficients.prototype.allPass1stOrderFractionalDelay\r\n\t\t\t\tconst distortionNextOutputWeight1 = Math.cos(Math.PI * distortionFractionalDelay1) * 0.5 + 0.5;\r\n\t\t\t\tconst distortionNextOutputWeight2 = Math.cos(Math.PI * distortionFractionalDelay2) * 0.5 + 0.5;\r\n\t\t\t\tconst distortionNextOutputWeight3 = Math.cos(Math.PI * distortionFractionalDelay3) * 0.5 + 0.5;\r\n\t\t\t\tconst distortionPrevOutputWeight1 = 1.0 - distortionNextOutputWeight1;\r\n\t\t\t\tconst distortionPrevOutputWeight2 = 1.0 - distortionNextOutputWeight2;\r\n\t\t\t\tconst distortionPrevOutputWeight3 = 1.0 - distortionNextOutputWeight3;\r\n\r\n\t\t\t\tlet distortionFractionalInput1 = +instrumentState.distortionFractionalInput1;\r\n\t\t\t\tlet distortionFractionalInput2 = +instrumentState.distortionFractionalInput2;\r\n\t\t\t\tlet distortionFractionalInput3 = +instrumentState.distortionFractionalInput3;\r\n\t\t\t\tlet distortionPrevInput = +instrumentState.distortionPrevInput;\r\n\t\t\t\tlet distortionNextOutput = +instrumentState.distortionNextOutput;`\r\n            }\r\n\r\n            if (usesBitcrusher) {\r\n                effectsSource += `\r\n\r\n\t\t\t\tlet bitcrusherPrevInput = +instrumentState.bitcrusherPrevInput;\r\n\t\t\t\tlet bitcrusherCurrentOutput = +instrumentState.bitcrusherCurrentOutput;\r\n\t\t\t\tlet bitcrusherPhase = +instrumentState.bitcrusherPhase;\r\n\t\t\t\tlet bitcrusherPhaseDelta = +instrumentState.bitcrusherPhaseDelta;\r\n\t\t\t\tconst bitcrusherPhaseDeltaScale = +instrumentState.bitcrusherPhaseDeltaScale;\r\n\t\t\t\tlet bitcrusherScale = +instrumentState.bitcrusherScale;\r\n\t\t\t\tconst bitcrusherScaleScale = +instrumentState.bitcrusherScaleScale;\r\n\t\t\t\tlet bitcrusherFoldLevel = +instrumentState.bitcrusherFoldLevel;\r\n\t\t\t\tconst bitcrusherFoldLevelScale = +instrumentState.bitcrusherFoldLevelScale;`\r\n            }\r\n\r\n            if (usesEqFilter) {\r\n                effectsSource += `\r\n\r\n\t\t\t\tlet filters = instrumentState.eqFilters;\r\n\t\t\t\tconst filterCount = instrumentState.eqFilterCount|0;\r\n\t\t\t\tlet initialFilterInput1 = +instrumentState.initialEqFilterInput1;\r\n\t\t\t\tlet initialFilterInput2 = +instrumentState.initialEqFilterInput2;\r\n\t\t\t\tconst applyFilters = beepbox.Synth.applyFilters;`\r\n            }\r\n\r\n            // The eq filter volume is also used to fade out the instrument state, so always include it.\r\n            effectsSource += `\r\n\r\n\t\t\t\tlet eqFilterVolume = +instrumentState.eqFilterVolume;\r\n\t\t\t\tconst eqFilterVolumeDelta = +instrumentState.eqFilterVolumeDelta;`\r\n\r\n            if (usesPanning) {\r\n                effectsSource += `\r\n\r\n\t\t\t\tconst panningMask = synth.panningDelayBufferMask >>> 0;\r\n\t\t\t\tconst panningDelayLine = instrumentState.panningDelayLine;\r\n\t\t\t\tlet panningDelayPos = instrumentState.panningDelayPos & panningMask;\r\n\t\t\t\tlet   panningVolumeL      = +instrumentState.panningVolumeL;\r\n\t\t\t\tlet   panningVolumeR      = +instrumentState.panningVolumeR;\r\n\t\t\t\tconst panningVolumeDeltaL = +instrumentState.panningVolumeDeltaL;\r\n\t\t\t\tconst panningVolumeDeltaR = +instrumentState.panningVolumeDeltaR;\r\n\t\t\t\tlet   panningOffsetL      = +instrumentState.panningOffsetL;\r\n\t\t\t\tlet   panningOffsetR      = +instrumentState.panningOffsetR;\r\n\t\t\t\tconst panningOffsetDeltaL = 1.0 - instrumentState.panningOffsetDeltaL;\r\n\t\t\t\tconst panningOffsetDeltaR = 1.0 - instrumentState.panningOffsetDeltaR;`\r\n            }\r\n\r\n            if (usesChorus) {\r\n                effectsSource += `\r\n\r\n\t\t\t\tconst chorusMask = synth.chorusDelayBufferMask >>> 0;\r\n\t\t\t\tconst chorusDelayLineL = instrumentState.chorusDelayLineL;\r\n\t\t\t\tconst chorusDelayLineR = instrumentState.chorusDelayLineR;\r\n\t\t\t\tinstrumentState.chorusDelayLineDirty = true;\r\n\t\t\t\tlet chorusDelayPos = instrumentState.chorusDelayPos & chorusMask;\r\n\r\n\t\t\t\tlet chorusVoiceMult = +instrumentState.chorusVoiceMult;\r\n\t\t\t\tconst chorusVoiceMultDelta = +instrumentState.chorusVoiceMultDelta;\r\n\t\t\t\tlet chorusCombinedMult = +instrumentState.chorusCombinedMult;\r\n\t\t\t\tconst chorusCombinedMultDelta = +instrumentState.chorusCombinedMultDelta;\r\n\r\n\t\t\t\tconst chorusDuration = +beepbox.Config.chorusPeriodSeconds;\r\n\t\t\t\tconst chorusAngle = Math.PI * 2.0 / (chorusDuration * synth.samplesPerSecond);\r\n\t\t\t\tconst chorusRange = synth.samplesPerSecond * beepbox.Config.chorusDelayRange;\r\n\t\t\t\tconst chorusOffset0 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[0][0] * chorusRange;\r\n\t\t\t\tconst chorusOffset1 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[0][1] * chorusRange;\r\n\t\t\t\tconst chorusOffset2 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[0][2] * chorusRange;\r\n\t\t\t\tconst chorusOffset3 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[1][0] * chorusRange;\r\n\t\t\t\tconst chorusOffset4 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[1][1] * chorusRange;\r\n\t\t\t\tconst chorusOffset5 = synth.chorusDelayBufferSize - beepbox.Config.chorusDelayOffsets[1][2] * chorusRange;\r\n\t\t\t\tlet chorusPhase = instrumentState.chorusPhase % (Math.PI * 2.0);\r\n\t\t\t\tlet chorusTap0Index = chorusDelayPos + chorusOffset0 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][0]);\r\n\t\t\t\tlet chorusTap1Index = chorusDelayPos + chorusOffset1 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][1]);\r\n\t\t\t\tlet chorusTap2Index = chorusDelayPos + chorusOffset2 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][2]);\r\n\t\t\t\tlet chorusTap3Index = chorusDelayPos + chorusOffset3 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][0]);\r\n\t\t\t\tlet chorusTap4Index = chorusDelayPos + chorusOffset4 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][1]);\r\n\t\t\t\tlet chorusTap5Index = chorusDelayPos + chorusOffset5 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][2]);\r\n\t\t\t\tchorusPhase += chorusAngle * runLength;\r\n\t\t\t\tconst chorusTap0End = chorusDelayPos + chorusOffset0 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][0]) + runLength;\r\n\t\t\t\tconst chorusTap1End = chorusDelayPos + chorusOffset1 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][1]) + runLength;\r\n\t\t\t\tconst chorusTap2End = chorusDelayPos + chorusOffset2 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[0][2]) + runLength;\r\n\t\t\t\tconst chorusTap3End = chorusDelayPos + chorusOffset3 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][0]) + runLength;\r\n\t\t\t\tconst chorusTap4End = chorusDelayPos + chorusOffset4 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][1]) + runLength;\r\n\t\t\t\tconst chorusTap5End = chorusDelayPos + chorusOffset5 - chorusRange * Math.sin(chorusPhase + beepbox.Config.chorusPhaseOffsets[1][2]) + runLength;\r\n\t\t\t\tconst chorusTap0Delta = (chorusTap0End - chorusTap0Index) / runLength;\r\n\t\t\t\tconst chorusTap1Delta = (chorusTap1End - chorusTap1Index) / runLength;\r\n\t\t\t\tconst chorusTap2Delta = (chorusTap2End - chorusTap2Index) / runLength;\r\n\t\t\t\tconst chorusTap3Delta = (chorusTap3End - chorusTap3Index) / runLength;\r\n\t\t\t\tconst chorusTap4Delta = (chorusTap4End - chorusTap4Index) / runLength;\r\n\t\t\t\tconst chorusTap5Delta = (chorusTap5End - chorusTap5Index) / runLength;`\r\n            }\r\n\r\n            if (usesEcho) {\r\n                effectsSource += `\r\n\r\n\t\t\t\tlet echoMult = +instrumentState.echoMult;\r\n\t\t\t\tconst echoMultDelta = +instrumentState.echoMultDelta;\r\n\r\n\t\t\t\tconst echoDelayLineL = instrumentState.echoDelayLineL;\r\n\t\t\t\tconst echoDelayLineR = instrumentState.echoDelayLineR;\r\n\t\t\t\tconst echoMask = (echoDelayLineL.length - 1) >>> 0;\r\n\t\t\t\tinstrumentState.echoDelayLineDirty = true;\r\n\r\n\t\t\t\tlet echoDelayPos = instrumentState.echoDelayPos & echoMask;\r\n\t\t\t\tconst echoDelayOffsetStart = (echoDelayLineL.length - instrumentState.echoDelayOffsetStart) & echoMask;\r\n\t\t\t\tconst echoDelayOffsetEnd   = (echoDelayLineL.length - instrumentState.echoDelayOffsetEnd) & echoMask;\r\n\t\t\t\tlet echoDelayOffsetRatio = +instrumentState.echoDelayOffsetRatio;\r\n\t\t\t\tconst echoDelayOffsetRatioDelta = +instrumentState.echoDelayOffsetRatioDelta;\r\n\r\n\t\t\t\tconst echoShelfA1 = +instrumentState.echoShelfA1;\r\n\t\t\t\tconst echoShelfB0 = +instrumentState.echoShelfB0;\r\n\t\t\t\tconst echoShelfB1 = +instrumentState.echoShelfB1;\r\n\t\t\t\tlet echoShelfSampleL = +instrumentState.echoShelfSampleL;\r\n\t\t\t\tlet echoShelfSampleR = +instrumentState.echoShelfSampleR;\r\n\t\t\t\tlet echoShelfPrevInputL = +instrumentState.echoShelfPrevInputL;\r\n\t\t\t\tlet echoShelfPrevInputR = +instrumentState.echoShelfPrevInputR;`\r\n            }\r\n\r\n            if (usesReverb) {\r\n                effectsSource += `\r\n\r\n\t\t\t\tconst reverbMask = Config.reverbDelayBufferMask >>> 0; //TODO: Dynamic reverb buffer size.\r\n\t\t\t\tconst reverbDelayLine = instrumentState.reverbDelayLine;\r\n\t\t\t\tinstrumentState.reverbDelayLineDirty = true;\r\n\t\t\t\tlet reverbDelayPos = instrumentState.reverbDelayPos & reverbMask;\r\n\r\n\t\t\t\tlet reverb = +instrumentState.reverbMult;\r\n\t\t\t\tconst reverbDelta = +instrumentState.reverbMultDelta;\r\n\r\n\t\t\t\tconst reverbShelfA1 = +instrumentState.reverbShelfA1;\r\n\t\t\t\tconst reverbShelfB0 = +instrumentState.reverbShelfB0;\r\n\t\t\t\tconst reverbShelfB1 = +instrumentState.reverbShelfB1;\r\n\t\t\t\tlet reverbShelfSample0 = +instrumentState.reverbShelfSample0;\r\n\t\t\t\tlet reverbShelfSample1 = +instrumentState.reverbShelfSample1;\r\n\t\t\t\tlet reverbShelfSample2 = +instrumentState.reverbShelfSample2;\r\n\t\t\t\tlet reverbShelfSample3 = +instrumentState.reverbShelfSample3;\r\n\t\t\t\tlet reverbShelfPrevInput0 = +instrumentState.reverbShelfPrevInput0;\r\n\t\t\t\tlet reverbShelfPrevInput1 = +instrumentState.reverbShelfPrevInput1;\r\n\t\t\t\tlet reverbShelfPrevInput2 = +instrumentState.reverbShelfPrevInput2;\r\n\t\t\t\tlet reverbShelfPrevInput3 = +instrumentState.reverbShelfPrevInput3;`\r\n            }\r\n\r\n            effectsSource += `\r\n\r\n\t\t\t\tconst stopIndex = bufferIndex + runLength;\r\n\t\t\t\tfor (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n\t\t\t\t\tlet sample = tempMonoInstrumentSampleBuffer[sampleIndex];\r\n\t\t\t\t\ttempMonoInstrumentSampleBuffer[sampleIndex] = 0.0;`\r\n\r\n            if (usesDistortion) {\r\n                effectsSource += `\r\n\r\n\t\t\t\t\tconst distortionReverse = 1.0 - distortion;\r\n\t\t\t\t\tconst distortionNextInput = sample * distortionDrive;\r\n\t\t\t\t\tsample = distortionNextOutput;\r\n\t\t\t\t\tdistortionNextOutput = distortionNextInput / (distortionReverse * Math.abs(distortionNextInput) + distortion);\r\n\t\t\t\t\tdistortionFractionalInput1 = distortionFractionalDelayG1 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG1 * distortionFractionalInput1;\r\n\t\t\t\t\tdistortionFractionalInput2 = distortionFractionalDelayG2 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG2 * distortionFractionalInput2;\r\n\t\t\t\t\tdistortionFractionalInput3 = distortionFractionalDelayG3 * distortionNextInput + distortionPrevInput - distortionFractionalDelayG3 * distortionFractionalInput3;\r\n\t\t\t\t\tconst distortionOutput1 = distortionFractionalInput1 / (distortionReverse * Math.abs(distortionFractionalInput1) + distortion);\r\n\t\t\t\t\tconst distortionOutput2 = distortionFractionalInput2 / (distortionReverse * Math.abs(distortionFractionalInput2) + distortion);\r\n\t\t\t\t\tconst distortionOutput3 = distortionFractionalInput3 / (distortionReverse * Math.abs(distortionFractionalInput3) + distortion);\r\n\t\t\t\t\tdistortionNextOutput += distortionOutput1 * distortionNextOutputWeight1 + distortionOutput2 * distortionNextOutputWeight2 + distortionOutput3 * distortionNextOutputWeight3;\r\n\t\t\t\t\tsample += distortionOutput1 * distortionPrevOutputWeight1 + distortionOutput2 * distortionPrevOutputWeight2 + distortionOutput3 * distortionPrevOutputWeight3;\r\n\t\t\t\t\tsample *= distortionOversampleCompensation;\r\n\t\t\t\t\tdistortionPrevInput = distortionNextInput;\r\n\t\t\t\t\tdistortion += distortionDelta;\r\n\t\t\t\t\tdistortionDrive += distortionDriveDelta;`\r\n            }\r\n\r\n            if (usesBitcrusher) {\r\n                effectsSource += `\r\n\r\n\t\t\t\t\tbitcrusherPhase += bitcrusherPhaseDelta;\r\n\t\t\t\t\tif (bitcrusherPhase < 1.0) {\r\n\t\t\t\t\t\tbitcrusherPrevInput = sample;\r\n\t\t\t\t\t\tsample = bitcrusherCurrentOutput;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tbitcrusherPhase = bitcrusherPhase % 1.0;\r\n\t\t\t\t\t\tconst ratio = bitcrusherPhase / bitcrusherPhaseDelta;\r\n\r\n\t\t\t\t\t\tconst lerpedInput = sample + (bitcrusherPrevInput - sample) * ratio;\r\n\t\t\t\t\t\tbitcrusherPrevInput = sample;\r\n\r\n\t\t\t\t\t\tconst bitcrusherWrapLevel = bitcrusherFoldLevel * 4.0;\r\n\t\t\t\t\t\tconst wrappedSample = (((lerpedInput + bitcrusherFoldLevel) % bitcrusherWrapLevel) + bitcrusherWrapLevel) % bitcrusherWrapLevel;\r\n\t\t\t\t\t\tconst foldedSample = bitcrusherFoldLevel - Math.abs(bitcrusherFoldLevel * 2.0 - wrappedSample);\r\n\t\t\t\t\t\tconst scaledSample = foldedSample / bitcrusherScale;\r\n\t\t\t\t\t\tconst oldValue = bitcrusherCurrentOutput;\r\n\t\t\t\t\t\tconst newValue = (((scaledSample > 0 ? scaledSample + 1 : scaledSample)|0)-.5) * bitcrusherScale;\r\n\r\n\t\t\t\t\t\tsample = oldValue + (newValue - oldValue) * ratio;\r\n\t\t\t\t\t\tbitcrusherCurrentOutput = newValue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbitcrusherPhaseDelta *= bitcrusherPhaseDeltaScale;\r\n\t\t\t\t\tbitcrusherScale *= bitcrusherScaleScale;\r\n\t\t\t\t\tbitcrusherFoldLevel *= bitcrusherFoldLevelScale;`\r\n            }\r\n\r\n            if (usesEqFilter) {\r\n                effectsSource += `\r\n\r\n\t\t\t\t\tconst inputSample = sample;\r\n\t\t\t\t\tsample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n\t\t\t\t\tinitialFilterInput2 = initialFilterInput1;\r\n\t\t\t\t\tinitialFilterInput1 = inputSample;`\r\n            }\r\n\r\n            // The eq filter volume is also used to fade out the instrument state, so always include it.\r\n            effectsSource += `\r\n\r\n\t\t\t\t\tsample *= eqFilterVolume;\r\n\t\t\t\t\teqFilterVolume += eqFilterVolumeDelta;`\r\n\r\n            if (usesPanning) {\r\n                effectsSource += `\r\n\r\n\t\t\t\t\tpanningDelayLine[panningDelayPos] = sample;\r\n\t\t\t\t\tconst panningRatioL  = panningOffsetL % 1;\r\n\t\t\t\t\tconst panningRatioR  = panningOffsetR % 1;\r\n\t\t\t\t\tconst panningTapLA   = panningDelayLine[(panningOffsetL) & panningMask];\r\n\t\t\t\t\tconst panningTapLB   = panningDelayLine[(panningOffsetL + 1) & panningMask];\r\n\t\t\t\t\tconst panningTapRA   = panningDelayLine[(panningOffsetR) & panningMask];\r\n\t\t\t\t\tconst panningTapRB   = panningDelayLine[(panningOffsetR + 1) & panningMask];\r\n\t\t\t\t\tconst panningTapL    = panningTapLA + (panningTapLB - panningTapLA) * panningRatioL;\r\n\t\t\t\t\tconst panningTapR    = panningTapRA + (panningTapRB - panningTapRA) * panningRatioR;\r\n\t\t\t\t\tlet sampleL = panningTapL * panningVolumeL;\r\n\t\t\t\t\tlet sampleR = panningTapR * panningVolumeR;\r\n\t\t\t\t\tpanningDelayPos = (panningDelayPos + 1) & panningMask;\r\n\t\t\t\t\tpanningVolumeL += panningVolumeDeltaL;\r\n\t\t\t\t\tpanningVolumeR += panningVolumeDeltaR;\r\n\t\t\t\t\tpanningOffsetL += panningOffsetDeltaL;\r\n\t\t\t\t\tpanningOffsetR += panningOffsetDeltaR;`\r\n            } else {\r\n                effectsSource += `\r\n\r\n\t\t\t\t\tlet sampleL = sample;\r\n\t\t\t\t\tlet sampleR = sample;`\r\n            }\r\n\r\n            if (usesChorus) {\r\n                effectsSource += `\r\n\r\n\t\t\t\t\tconst chorusTap0Ratio = chorusTap0Index % 1;\r\n\t\t\t\t\tconst chorusTap1Ratio = chorusTap1Index % 1;\r\n\t\t\t\t\tconst chorusTap2Ratio = chorusTap2Index % 1;\r\n\t\t\t\t\tconst chorusTap3Ratio = chorusTap3Index % 1;\r\n\t\t\t\t\tconst chorusTap4Ratio = chorusTap4Index % 1;\r\n\t\t\t\t\tconst chorusTap5Ratio = chorusTap5Index % 1;\r\n\t\t\t\t\tconst chorusTap0A = chorusDelayLineL[(chorusTap0Index) & chorusMask];\r\n\t\t\t\t\tconst chorusTap0B = chorusDelayLineL[(chorusTap0Index + 1) & chorusMask];\r\n\t\t\t\t\tconst chorusTap1A = chorusDelayLineL[(chorusTap1Index) & chorusMask];\r\n\t\t\t\t\tconst chorusTap1B = chorusDelayLineL[(chorusTap1Index + 1) & chorusMask];\r\n\t\t\t\t\tconst chorusTap2A = chorusDelayLineL[(chorusTap2Index) & chorusMask];\r\n\t\t\t\t\tconst chorusTap2B = chorusDelayLineL[(chorusTap2Index + 1) & chorusMask];\r\n\t\t\t\t\tconst chorusTap3A = chorusDelayLineR[(chorusTap3Index) & chorusMask];\r\n\t\t\t\t\tconst chorusTap3B = chorusDelayLineR[(chorusTap3Index + 1) & chorusMask];\r\n\t\t\t\t\tconst chorusTap4A = chorusDelayLineR[(chorusTap4Index) & chorusMask];\r\n\t\t\t\t\tconst chorusTap4B = chorusDelayLineR[(chorusTap4Index + 1) & chorusMask];\r\n\t\t\t\t\tconst chorusTap5A = chorusDelayLineR[(chorusTap5Index) & chorusMask];\r\n\t\t\t\t\tconst chorusTap5B = chorusDelayLineR[(chorusTap5Index + 1) & chorusMask];\r\n\t\t\t\t\tconst chorusTap0 = chorusTap0A + (chorusTap0B - chorusTap0A) * chorusTap0Ratio;\r\n\t\t\t\t\tconst chorusTap1 = chorusTap1A + (chorusTap1B - chorusTap1A) * chorusTap1Ratio;\r\n\t\t\t\t\tconst chorusTap2 = chorusTap2A + (chorusTap2B - chorusTap2A) * chorusTap2Ratio;\r\n\t\t\t\t\tconst chorusTap3 = chorusTap3A + (chorusTap3B - chorusTap3A) * chorusTap3Ratio;\r\n\t\t\t\t\tconst chorusTap4 = chorusTap4A + (chorusTap4B - chorusTap4A) * chorusTap4Ratio;\r\n\t\t\t\t\tconst chorusTap5 = chorusTap5A + (chorusTap5B - chorusTap5A) * chorusTap5Ratio;\r\n\t\t\t\t\tchorusDelayLineL[chorusDelayPos] = sampleL * delayInputMult;\r\n\t\t\t\t\tchorusDelayLineR[chorusDelayPos] = sampleR * delayInputMult;\r\n\t\t\t\t\tsampleL = chorusCombinedMult * (sampleL + chorusVoiceMult * (chorusTap1 - chorusTap0 - chorusTap2));\r\n\t\t\t\t\tsampleR = chorusCombinedMult * (sampleR + chorusVoiceMult * (chorusTap4 - chorusTap3 - chorusTap5));\r\n\t\t\t\t\tchorusDelayPos = (chorusDelayPos + 1) & chorusMask;\r\n\t\t\t\t\tchorusTap0Index += chorusTap0Delta;\r\n\t\t\t\t\tchorusTap1Index += chorusTap1Delta;\r\n\t\t\t\t\tchorusTap2Index += chorusTap2Delta;\r\n\t\t\t\t\tchorusTap3Index += chorusTap3Delta;\r\n\t\t\t\t\tchorusTap4Index += chorusTap4Delta;\r\n\t\t\t\t\tchorusTap5Index += chorusTap5Delta;\r\n\t\t\t\t\tchorusVoiceMult += chorusVoiceMultDelta;\r\n\t\t\t\t\tchorusCombinedMult += chorusCombinedMultDelta;`\r\n            }\r\n\r\n            if (usesEcho) {\r\n                effectsSource += `\r\n\r\n\t\t\t\t\tconst echoTapStartIndex = (echoDelayPos + echoDelayOffsetStart) & echoMask;\r\n\t\t\t\t\tconst echoTapEndIndex   = (echoDelayPos + echoDelayOffsetEnd  ) & echoMask;\r\n\t\t\t\t\tconst echoTapStartL = echoDelayLineL[echoTapStartIndex];\r\n\t\t\t\t\tconst echoTapEndL   = echoDelayLineL[echoTapEndIndex];\r\n\t\t\t\t\tconst echoTapStartR = echoDelayLineR[echoTapStartIndex];\r\n\t\t\t\t\tconst echoTapEndR   = echoDelayLineR[echoTapEndIndex];\r\n\t\t\t\t\tconst echoTapL = (echoTapStartL + (echoTapEndL - echoTapStartL) * echoDelayOffsetRatio) * echoMult;\r\n\t\t\t\t\tconst echoTapR = (echoTapStartR + (echoTapEndR - echoTapStartR) * echoDelayOffsetRatio) * echoMult;\r\n\r\n\t\t\t\t\techoShelfSampleL = echoShelfB0 * echoTapL + echoShelfB1 * echoShelfPrevInputL - echoShelfA1 * echoShelfSampleL;\r\n\t\t\t\t\techoShelfSampleR = echoShelfB0 * echoTapR + echoShelfB1 * echoShelfPrevInputR - echoShelfA1 * echoShelfSampleR;\r\n\t\t\t\t\techoShelfPrevInputL = echoTapL;\r\n\t\t\t\t\techoShelfPrevInputR = echoTapR;\r\n\t\t\t\t\tsampleL += echoShelfSampleL;\r\n\t\t\t\t\tsampleR += echoShelfSampleR;\r\n\r\n\t\t\t\t\techoDelayLineL[echoDelayPos] = sampleL * delayInputMult;\r\n\t\t\t\t\techoDelayLineR[echoDelayPos] = sampleR * delayInputMult;\r\n\t\t\t\t\techoDelayPos = (echoDelayPos + 1) & echoMask;\r\n\t\t\t\t\techoDelayOffsetRatio += echoDelayOffsetRatioDelta;\r\n\t\t\t\t\techoMult += echoMultDelta;\r\n                    `\r\n            }\r\n\r\n            if (usesReverb) {\r\n                effectsSource += `\r\n\r\n\t\t\t\t\t// Reverb, implemented using a feedback delay network with a Hadamard matrix and lowpass filters.\r\n\t\t\t\t\t// good ratios:    0.555235 + 0.618033 + 0.818 +   1.0 = 2.991268\r\n\t\t\t\t\t// Delay lengths:  3041     + 3385     + 4481  +  5477 = 16384 = 2^14\r\n\t\t\t\t\t// Buffer offsets: 3041    -> 6426   -> 10907 -> 16384\r\n\t\t\t\t\tconst reverbDelayPos1 = (reverbDelayPos +  3041) & reverbMask;\r\n\t\t\t\t\tconst reverbDelayPos2 = (reverbDelayPos +  6426) & reverbMask;\r\n\t\t\t\t\tconst reverbDelayPos3 = (reverbDelayPos + 10907) & reverbMask;\r\n\t\t\t\t\tconst reverbSample0 = (reverbDelayLine[reverbDelayPos]);\r\n\t\t\t\t\tconst reverbSample1 = reverbDelayLine[reverbDelayPos1];\r\n\t\t\t\t\tconst reverbSample2 = reverbDelayLine[reverbDelayPos2];\r\n\t\t\t\t\tconst reverbSample3 = reverbDelayLine[reverbDelayPos3];\r\n\t\t\t\t\tconst reverbTemp0 = -(reverbSample0 + sampleL) + reverbSample1;\r\n\t\t\t\t\tconst reverbTemp1 = -(reverbSample0 + sampleR) - reverbSample1;\r\n\t\t\t\t\tconst reverbTemp2 = -reverbSample2 + reverbSample3;\r\n\t\t\t\t\tconst reverbTemp3 = -reverbSample2 - reverbSample3;\r\n\t\t\t\t\tconst reverbShelfInput0 = (reverbTemp0 + reverbTemp2) * reverb;\r\n\t\t\t\t\tconst reverbShelfInput1 = (reverbTemp1 + reverbTemp3) * reverb;\r\n\t\t\t\t\tconst reverbShelfInput2 = (reverbTemp0 - reverbTemp2) * reverb;\r\n\t\t\t\t\tconst reverbShelfInput3 = (reverbTemp1 - reverbTemp3) * reverb;\r\n\t\t\t\t\treverbShelfSample0 = reverbShelfB0 * reverbShelfInput0 + reverbShelfB1 * reverbShelfPrevInput0 - reverbShelfA1 * reverbShelfSample0;\r\n\t\t\t\t\treverbShelfSample1 = reverbShelfB0 * reverbShelfInput1 + reverbShelfB1 * reverbShelfPrevInput1 - reverbShelfA1 * reverbShelfSample1;\r\n\t\t\t\t\treverbShelfSample2 = reverbShelfB0 * reverbShelfInput2 + reverbShelfB1 * reverbShelfPrevInput2 - reverbShelfA1 * reverbShelfSample2;\r\n\t\t\t\t\treverbShelfSample3 = reverbShelfB0 * reverbShelfInput3 + reverbShelfB1 * reverbShelfPrevInput3 - reverbShelfA1 * reverbShelfSample3;\r\n\t\t\t\t\treverbShelfPrevInput0 = reverbShelfInput0;\r\n\t\t\t\t\treverbShelfPrevInput1 = reverbShelfInput1;\r\n\t\t\t\t\treverbShelfPrevInput2 = reverbShelfInput2;\r\n\t\t\t\t\treverbShelfPrevInput3 = reverbShelfInput3;\r\n\t\t\t\t\treverbDelayLine[reverbDelayPos1] = reverbShelfSample0 * delayInputMult;\r\n\t\t\t\t\treverbDelayLine[reverbDelayPos2] = reverbShelfSample1 * delayInputMult;\r\n\t\t\t\t\treverbDelayLine[reverbDelayPos3] = reverbShelfSample2 * delayInputMult;\r\n\t\t\t\t\treverbDelayLine[reverbDelayPos ] = reverbShelfSample3 * delayInputMult;\r\n\t\t\t\t\treverbDelayPos = (reverbDelayPos + 1) & reverbMask;\r\n\t\t\t\t\tsampleL += reverbSample1 + reverbSample2 + reverbSample3;\r\n\t\t\t\t\tsampleR += reverbSample0 + reverbSample2 - reverbSample3;\r\n\t\t\t\t\treverb += reverbDelta;`\r\n            }\r\n\r\n            effectsSource += `\r\n\r\n\t\t\t\t\toutputDataL[sampleIndex] += sampleL * mixVolume;\r\n\t\t\t\t\toutputDataR[sampleIndex] += sampleR * mixVolume;\r\n\t\t\t\t\tmixVolume += mixVolumeDelta;`\r\n\r\n            if (usesDelays) {\r\n                effectsSource += `\r\n\r\n\t\t\t\t\tdelayInputMult += delayInputMultDelta;`\r\n            }\r\n\r\n            effectsSource += `\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinstrumentState.mixVolume = mixVolume;\r\n\t\t\t\tinstrumentState.eqFilterVolume = eqFilterVolume;\r\n\r\n\t\t\t\t// Avoid persistent denormal or NaN values in the delay buffers and filter history.\r\n\t\t\t\tconst epsilon = (1.0e-24);`\r\n\r\n            if (usesDelays) {\r\n                effectsSource += `\r\n\r\n\t\t\t\tinstrumentState.delayInputMult = delayInputMult;`\r\n            }\r\n\r\n            if (usesDistortion) {\r\n                effectsSource += `\r\n\r\n\t\t\t\tinstrumentState.distortion = distortion;\r\n\t\t\t\tinstrumentState.distortionDrive = distortionDrive;\r\n\r\n\t\t\t\tif (!Number.isFinite(distortionFractionalInput1) || Math.abs(distortionFractionalInput1) < epsilon) distortionFractionalInput1 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(distortionFractionalInput2) || Math.abs(distortionFractionalInput2) < epsilon) distortionFractionalInput2 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(distortionFractionalInput3) || Math.abs(distortionFractionalInput3) < epsilon) distortionFractionalInput3 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(distortionPrevInput) || Math.abs(distortionPrevInput) < epsilon) distortionPrevInput = 0.0;\r\n\t\t\t\tif (!Number.isFinite(distortionNextOutput) || Math.abs(distortionNextOutput) < epsilon) distortionNextOutput = 0.0;\r\n\r\n\t\t\t\tinstrumentState.distortionFractionalInput1 = distortionFractionalInput1;\r\n\t\t\t\tinstrumentState.distortionFractionalInput2 = distortionFractionalInput2;\r\n\t\t\t\tinstrumentState.distortionFractionalInput3 = distortionFractionalInput3;\r\n\t\t\t\tinstrumentState.distortionPrevInput = distortionPrevInput;\r\n\t\t\t\tinstrumentState.distortionNextOutput = distortionNextOutput;`\r\n            }\r\n\r\n            if (usesBitcrusher) {\r\n                effectsSource += `\r\n\r\n\t\t\t\tif (Math.abs(bitcrusherPrevInput) < epsilon) bitcrusherPrevInput = 0.0;\r\n\t\t\t\tif (Math.abs(bitcrusherCurrentOutput) < epsilon) bitcrusherCurrentOutput = 0.0;\r\n\t\t\t\tinstrumentState.bitcrusherPrevInput = bitcrusherPrevInput;\r\n\t\t\t\tinstrumentState.bitcrusherCurrentOutput = bitcrusherCurrentOutput;\r\n\t\t\t\tinstrumentState.bitcrusherPhase = bitcrusherPhase;\r\n\t\t\t\tinstrumentState.bitcrusherPhaseDelta = bitcrusherPhaseDelta;\r\n\t\t\t\tinstrumentState.bitcrusherScale = bitcrusherScale;\r\n\t\t\t\tinstrumentState.bitcrusherFoldLevel = bitcrusherFoldLevel;`\r\n\r\n            }\r\n\r\n            if (usesEqFilter) {\r\n                effectsSource += `\r\n\r\n\t\t\t\tsynth.sanitizeFilters(filters);\r\n\t\t\t\t// The filter input here is downstream from another filter so we\r\n\t\t\t\t// better make sure it's safe too.\r\n\t\t\t\tif (!(initialFilterInput1 < 100) || !(initialFilterInput2 < 100)) {\r\n\t\t\t\t\tinitialFilterInput1 = 0.0;\r\n\t\t\t\t\tinitialFilterInput2 = 0.0;\r\n\t\t\t\t}\r\n\t\t\t\tif (Math.abs(initialFilterInput1) < epsilon) initialFilterInput1 = 0.0;\r\n\t\t\t\tif (Math.abs(initialFilterInput2) < epsilon) initialFilterInput2 = 0.0;\r\n\t\t\t\tinstrumentState.initialEqFilterInput1 = initialFilterInput1;\r\n\t\t\t\tinstrumentState.initialEqFilterInput2 = initialFilterInput2;`\r\n            }\r\n\r\n            if (usesPanning) {\r\n                effectsSource += `\r\n\r\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(panningDelayLine, panningDelayPos, panningMask);\r\n\t\t\t\tinstrumentState.panningDelayPos = panningDelayPos;\r\n\t\t\t\tinstrumentState.panningVolumeL = panningVolumeL;\r\n\t\t\t\tinstrumentState.panningVolumeR = panningVolumeR;\r\n\t\t\t\tinstrumentState.panningOffsetL = panningOffsetL;\r\n\t\t\t\tinstrumentState.panningOffsetR = panningOffsetR;`\r\n            }\r\n\r\n            if (usesChorus) {\r\n                effectsSource += `\r\n\r\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(chorusDelayLineL, chorusDelayPos, chorusMask);\r\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(chorusDelayLineR, chorusDelayPos, chorusMask);\r\n\t\t\t\tinstrumentState.chorusPhase = chorusPhase;\r\n\t\t\t\tinstrumentState.chorusDelayPos = chorusDelayPos;\r\n\t\t\t\tinstrumentState.chorusVoiceMult = chorusVoiceMult;\r\n\t\t\t\tinstrumentState.chorusCombinedMult = chorusCombinedMult;`\r\n            }\r\n\r\n            if (usesEcho) {\r\n                effectsSource += `\r\n\r\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(echoDelayLineL, echoDelayPos, echoMask);\r\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(echoDelayLineR, echoDelayPos, echoMask);\r\n\t\t\t\tinstrumentState.echoDelayPos = echoDelayPos;\r\n\t\t\t\tinstrumentState.echoMult = echoMult;\r\n\t\t\t\tinstrumentState.echoDelayOffsetRatio = echoDelayOffsetRatio;\r\n\r\n\t\t\t\tif (!Number.isFinite(echoShelfSampleL) || Math.abs(echoShelfSampleL) < epsilon) echoShelfSampleL = 0.0;\r\n\t\t\t\tif (!Number.isFinite(echoShelfSampleR) || Math.abs(echoShelfSampleR) < epsilon) echoShelfSampleR = 0.0;\r\n\t\t\t\tif (!Number.isFinite(echoShelfPrevInputL) || Math.abs(echoShelfPrevInputL) < epsilon) echoShelfPrevInputL = 0.0;\r\n\t\t\t\tif (!Number.isFinite(echoShelfPrevInputR) || Math.abs(echoShelfPrevInputR) < epsilon) echoShelfPrevInputR = 0.0;\r\n\t\t\t\tinstrumentState.echoShelfSampleL = echoShelfSampleL;\r\n\t\t\t\tinstrumentState.echoShelfSampleR = echoShelfSampleR;\r\n\t\t\t\tinstrumentState.echoShelfPrevInputL = echoShelfPrevInputL;\r\n\t\t\t\tinstrumentState.echoShelfPrevInputR = echoShelfPrevInputR;`\r\n            }\r\n\r\n            if (usesReverb) {\r\n                effectsSource += `\r\n\r\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos        , reverbMask);\r\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos +  3041, reverbMask);\r\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos +  6426, reverbMask);\r\n\t\t\t\tbeepbox.Synth.sanitizeDelayLine(reverbDelayLine, reverbDelayPos + 10907, reverbMask);\r\n\t\t\t\tinstrumentState.reverbDelayPos = reverbDelayPos;\r\n\t\t\t\tinstrumentState.reverbMult = reverb;\r\n\r\n\t\t\t\tif (!Number.isFinite(reverbShelfSample0) || Math.abs(reverbShelfSample0) < epsilon) reverbShelfSample0 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(reverbShelfSample1) || Math.abs(reverbShelfSample1) < epsilon) reverbShelfSample1 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(reverbShelfSample2) || Math.abs(reverbShelfSample2) < epsilon) reverbShelfSample2 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(reverbShelfSample3) || Math.abs(reverbShelfSample3) < epsilon) reverbShelfSample3 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput0) || Math.abs(reverbShelfPrevInput0) < epsilon) reverbShelfPrevInput0 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput1) || Math.abs(reverbShelfPrevInput1) < epsilon) reverbShelfPrevInput1 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput2) || Math.abs(reverbShelfPrevInput2) < epsilon) reverbShelfPrevInput2 = 0.0;\r\n\t\t\t\tif (!Number.isFinite(reverbShelfPrevInput3) || Math.abs(reverbShelfPrevInput3) < epsilon) reverbShelfPrevInput3 = 0.0;\r\n\t\t\t\tinstrumentState.reverbShelfSample0 = reverbShelfSample0;\r\n\t\t\t\tinstrumentState.reverbShelfSample1 = reverbShelfSample1;\r\n\t\t\t\tinstrumentState.reverbShelfSample2 = reverbShelfSample2;\r\n\t\t\t\tinstrumentState.reverbShelfSample3 = reverbShelfSample3;\r\n\t\t\t\tinstrumentState.reverbShelfPrevInput0 = reverbShelfPrevInput0;\r\n\t\t\t\tinstrumentState.reverbShelfPrevInput1 = reverbShelfPrevInput1;\r\n\t\t\t\tinstrumentState.reverbShelfPrevInput2 = reverbShelfPrevInput2;\r\n\t\t\t\tinstrumentState.reverbShelfPrevInput3 = reverbShelfPrevInput3;`\r\n            }\r\n\r\n            //console.log(effectsSource);\r\n            effectsFunction = new Function(\"synth\", \"outputDataL\", \"outputDataR\", \"bufferIndex\", \"runLength\", \"instrumentState\", effectsSource);\r\n            Synth.effectsFunctionCache[signature] = effectsFunction;\r\n        }\r\n\r\n        effectsFunction(synth, outputDataL, outputDataR, bufferIndex, runLength, instrumentState);\r\n    }\r\n\r\n    private static pulseWidthSynth(synth: Synth, bufferIndex: number, roundedSamplesPerTick: number, tone: Tone, instrument: Instrument): void {\r\n        const sign: number = instrument.invertWave ? -1 : 1;\r\n        const data: Float32Array = synth.tempMonoInstrumentSampleBuffer!;\r\n\r\n        let phaseDelta: number = tone.phaseDeltas[0];\r\n        const phaseDeltaScale: number = +tone.phaseDeltaScales[0];\r\n        let expression: number = +tone.expression;\r\n        const expressionDelta: number = +tone.expressionDelta;\r\n        let phase: number = (tone.phases[0] % 1);\r\n\r\n        let pulseWidth: number = tone.pulseWidth;\r\n        const pulseWidthDelta: number = tone.pulseWidthDelta;\r\n\r\n        const filters: DynamicBiquadFilter[] = tone.noteFilters;\r\n        const filterCount: number = tone.noteFilterCount | 0;\r\n        let initialFilterInput1: number = +tone.initialNoteFilterInput1;\r\n        let initialFilterInput2: number = +tone.initialNoteFilterInput2;\r\n        const applyFilters: Function = Synth.applyFilters;\r\n\r\n        const stopIndex: number = bufferIndex + roundedSamplesPerTick;\r\n        for (let sampleIndex: number = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n\r\n            const sawPhaseA: number = phase % 1;\r\n            const sawPhaseB: number = (phase + pulseWidth) % 1;\r\n\r\n            let pulseWave: number = sawPhaseB - sawPhaseA;\r\n\r\n            // This is a PolyBLEP, which smooths out discontinuities at any frequency to reduce aliasing.\r\n            if (!instrument.aliases) {\r\n                if (sawPhaseA < phaseDelta) {\r\n                    var t = sawPhaseA / phaseDelta;\r\n                    pulseWave += (t + t - t * t - 1) * 0.5;\r\n                } else if (sawPhaseA > 1.0 - phaseDelta) {\r\n                    var t = (sawPhaseA - 1.0) / phaseDelta;\r\n                    pulseWave += (t + t + t * t + 1) * 0.5;\r\n                }\r\n                if (sawPhaseB < phaseDelta) {\r\n                    var t = sawPhaseB / phaseDelta;\r\n                    pulseWave -= (t + t - t * t - 1) * 0.5;\r\n                } else if (sawPhaseB > 1.0 - phaseDelta) {\r\n                    var t = (sawPhaseB - 1.0) / phaseDelta;\r\n                    pulseWave -= (t + t + t * t + 1) * 0.5;\r\n                }\r\n            }\r\n\r\n            const inputSample: number = pulseWave*sign;\r\n            const sample: number = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n            initialFilterInput2 = initialFilterInput1;\r\n            initialFilterInput1 = inputSample;\r\n\r\n            phase += phaseDelta;\r\n            phaseDelta *= phaseDeltaScale;\r\n            pulseWidth += pulseWidthDelta;\r\n\r\n            const output: number = sample * expression;\r\n            expression += expressionDelta;\r\n\r\n            data[sampleIndex] += output;\r\n        }\r\n\r\n        tone.phases[0] = phase;\r\n        tone.phaseDeltas[0] = phaseDelta;\r\n        tone.expression = expression;\r\n        tone.pulseWidth = pulseWidth;\r\n\r\n        synth.sanitizeFilters(filters);\r\n        tone.initialNoteFilterInput1 = initialFilterInput1;\r\n        tone.initialNoteFilterInput2 = initialFilterInput2;\r\n    }\r\n\r\n    private static fmSourceTemplate: string[] = (`\r\n        const sign = instrumentState.invertWave ? -1 : 1;\r\n\t\tconst data = synth.tempMonoInstrumentSampleBuffer;\r\n\t\tconst sineWave = beepbox.Config.sineWave;\r\n\r\n\t\t// I'm adding 1000 to the phase to ensure that it's never negative even when modulated by other waves because negative numbers don't work with the modulus operator very well.\r\n\t\tlet operator#Phase       = +((tone.phases[#] % 1) + 1000) * ` + Config.sineWaveLength + `;\r\n\t\tlet operator#PhaseDelta  = +tone.phaseDeltas[#] * ` + Config.sineWaveLength + `;\r\n\t\tlet operator#PhaseDeltaScale = +tone.phaseDeltaScales[#];\r\n\t\tlet operator#OutputMult  = +tone.operatorExpressions[#];\r\n\t\tconst operator#OutputDelta = +tone.operatorExpressionDeltas[#];\r\n\t\tlet operator#Output      = +tone.feedbackOutputs[#];\r\n        const operator#Wave      = tone.operatorWaves[#].samples;\r\n\t\tlet feedbackMult         = +tone.feedbackMult;\r\n\t\tconst feedbackDelta        = +tone.feedbackDelta;\r\n        let expression = +tone.expression;\r\n\t\tconst expressionDelta = +tone.expressionDelta;\r\n\r\n\t\tconst filters = tone.noteFilters;\r\n\t\tconst filterCount = tone.noteFilterCount|0;\r\n\t\tlet initialFilterInput1 = +tone.initialNoteFilterInput1;\r\n\t\tlet initialFilterInput2 = +tone.initialNoteFilterInput2;\r\n\t\tconst applyFilters = beepbox.Synth.applyFilters;\r\n\r\n\t\tconst stopIndex = bufferIndex + roundedSamplesPerTick;\r\n\t\tfor (let sampleIndex = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n\t\t\t\t// INSERT OPERATOR COMPUTATION HERE\r\n\t\t\t\tconst fmOutput = (/*operator#Scaled*/); // CARRIER OUTPUTS\r\n\r\n\t\t\tconst inputSample = fmOutput*sign;\r\n\t\t\tconst sample = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n\t\t\tinitialFilterInput2 = initialFilterInput1;\r\n\t\t\tinitialFilterInput1 = inputSample;\r\n\r\n\t\t\t\tfeedbackMult += feedbackDelta;\r\n\t\t\t\toperator#OutputMult += operator#OutputDelta;\r\n\t\t\t\toperator#Phase += operator#PhaseDelta;\r\n\t\t\toperator#PhaseDelta *= operator#PhaseDeltaScale;\r\n\r\n\t\t\tconst output = sample * expression;\r\n\t\t\texpression += expressionDelta;\r\n\r\n\t\t\tdata[sampleIndex] += output;\r\n\t\t\t}\r\n\r\n\t\t\ttone.phases[#] = operator#Phase / ` + Config.sineWaveLength + `;\r\n\t\t\ttone.phaseDeltas[#] = operator#PhaseDelta / ` + Config.sineWaveLength + `;\r\n\t\t\ttone.operatorExpressions[#] = operator#OutputMult;\r\n\t\t    tone.feedbackOutputs[#] = operator#Output;\r\n\t\t    tone.feedbackMult = feedbackMult;\r\n\t\t    tone.expression = expression;\r\n\r\n\t\tsynth.sanitizeFilters(filters);\r\n\t\ttone.initialNoteFilterInput1 = initialFilterInput1;\r\n\t\ttone.initialNoteFilterInput2 = initialFilterInput2;\r\n\t\t`).split(\"\\n\");\r\n\r\n    private static operatorSourceTemplate: string[] = (`\r\n\t\t\t\tconst operator#PhaseMix = operator#Phase/* + operator@Scaled*/;\r\n\t\t\t\tconst operator#PhaseInt = operator#PhaseMix|0;\r\n\t\t\t\tconst operator#Index    = operator#PhaseInt & ` + Config.sineWaveMask + `;\r\n                const operator#Sample   = operator#Wave[operator#Index];\r\n                operator#Output         = operator#Sample + (operator#Wave[operator#Index + 1] - operator#Sample) * (operator#PhaseMix - operator#PhaseInt);\r\n\t\t\t\tconst operator#Scaled   = operator#OutputMult * operator#Output;\r\n\t\t`).split(\"\\n\");\r\n\r\n    private static noiseSynth(synth: Synth, bufferIndex: number, runLength: number, tone: Tone, instrumentState: InstrumentState): void {\r\n        const randOff: number = Math.abs(Math.sin((tone.noteStartPart+tone.noteEndPart+tone.pitches[0]+synth.bar)*10000)) //Makes the random noise deterministric so that invert wave works properly\r\n        const sign: number = instrumentState.invertWave ? -1 : 1;\r\n        const data: Float32Array = synth.tempMonoInstrumentSampleBuffer!;\r\n        const wave: Float32Array = instrumentState.wave!;\r\n        let phaseDelta: number = +tone.phaseDeltas[0];\r\n        const phaseDeltaScale: number = +tone.phaseDeltaScales[0];\r\n        let expression: number = +tone.expression;\r\n        const expressionDelta: number = +tone.expressionDelta;\r\n        let phase: number = (tone.phases[0] % 1) * Config.chipNoiseLength;\r\n        if (tone.phases[0] == 0) {\r\n            // Zero phase means the tone was reset, just give noise a random start phase instead.\r\n            phase = randOff * Config.chipNoiseLength;\r\n        }\r\n        const phaseMask: number = Config.chipNoiseLength - 1;\r\n        let noiseSample: number = +tone.noiseSample;\r\n\r\n        const filters: DynamicBiquadFilter[] = tone.noteFilters;\r\n        const filterCount: number = tone.noteFilterCount | 0;\r\n        let initialFilterInput1: number = +tone.initialNoteFilterInput1;\r\n        let initialFilterInput2: number = +tone.initialNoteFilterInput2;\r\n        const applyFilters: Function = Synth.applyFilters;\r\n\r\n        // This is for a \"legacy\" style simplified 1st order lowpass filter with\r\n        // a cutoff frequency that is relative to the tone's fundamental frequency.\r\n        const pitchRelativefilter: number = Math.min(1.0, phaseDelta * instrumentState.noisePitchFilterMult);\r\n\r\n        const stopIndex: number = bufferIndex + runLength;\r\n        for (let sampleIndex: number = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n            const waveSample: number = wave[phase & phaseMask];\r\n\r\n            noiseSample += (waveSample - noiseSample) * pitchRelativefilter;\r\n\r\n            const inputSample: number = noiseSample*sign;\r\n            const sample: number = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n            initialFilterInput2 = initialFilterInput1;\r\n            initialFilterInput1 = inputSample;\r\n\r\n            phase += phaseDelta;\r\n            phaseDelta *= phaseDeltaScale;\r\n\r\n            const output: number = sample * expression;\r\n            expression += expressionDelta;\r\n\r\n            data[sampleIndex] += output;\r\n        }\r\n\r\n        tone.phases[0] = phase / Config.chipNoiseLength;\r\n        tone.phaseDeltas[0] = phaseDelta;\r\n        tone.expression = expression;\r\n        tone.noiseSample = noiseSample;\r\n\r\n        synth.sanitizeFilters(filters);\r\n        tone.initialNoteFilterInput1 = initialFilterInput1;\r\n        tone.initialNoteFilterInput2 = initialFilterInput2;\r\n    }\r\n\r\n    private static spectrumSynth(synth: Synth, bufferIndex: number, runLength: number, tone: Tone, instrumentState: InstrumentState): void {\r\n        const sign: number = instrumentState.invertWave ? -1 : 1;\r\n        const data: Float32Array = synth.tempMonoInstrumentSampleBuffer!;\r\n        const wave: Float32Array = instrumentState.wave!;\r\n        const samplesInPeriod: number = (1 << 7);\r\n        let phaseDelta: number = tone.phaseDeltas[0] * samplesInPeriod;\r\n        const phaseDeltaScale: number = +tone.phaseDeltaScales[0];\r\n        let expression: number = +tone.expression;\r\n        const expressionDelta: number = +tone.expressionDelta;\r\n        let noiseSample: number = +tone.noiseSample;\r\n\r\n        const filters: DynamicBiquadFilter[] = tone.noteFilters;\r\n        const filterCount: number = tone.noteFilterCount | 0;\r\n        let initialFilterInput1: number = +tone.initialNoteFilterInput1;\r\n        let initialFilterInput2: number = +tone.initialNoteFilterInput2;\r\n        const applyFilters: Function = Synth.applyFilters;\r\n\r\n        let phase: number = (tone.phases[0] % 1) * Config.spectrumNoiseLength;\r\n        // Zero phase means the tone was reset, just give noise a random start phase instead.\r\n        if (tone.phases[0] == 0) phase = Synth.findRandomZeroCrossing(wave, Config.spectrumNoiseLength, synth, tone) + phaseDelta;\r\n        const phaseMask: number = Config.spectrumNoiseLength - 1;\r\n\r\n        // This is for a \"legacy\" style simplified 1st order lowpass filter with\r\n        // a cutoff frequency that is relative to the tone's fundamental frequency.\r\n        const pitchRelativefilter: number = Math.min(1.0, phaseDelta);\r\n\r\n        const stopIndex: number = bufferIndex + runLength;\r\n        for (let sampleIndex: number = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n            const phaseInt: number = phase | 0;\r\n            const index: number = phaseInt & phaseMask;\r\n            let waveSample: number = wave[index];\r\n            const phaseRatio: number = phase - phaseInt;\r\n            waveSample += (wave[index + 1] - waveSample) * phaseRatio;\r\n\r\n            noiseSample += (waveSample - noiseSample) * pitchRelativefilter;\r\n\r\n\r\n            const inputSample: number = noiseSample*sign;\r\n            const sample: number = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n            initialFilterInput2 = initialFilterInput1;\r\n            initialFilterInput1 = inputSample;\r\n\r\n            phase += phaseDelta;\r\n            phaseDelta *= phaseDeltaScale;\r\n\r\n            const output: number = sample * expression;\r\n            expression += expressionDelta;\r\n\r\n            data[sampleIndex] += output;\r\n        }\r\n\r\n        tone.phases[0] = phase / Config.spectrumNoiseLength;\r\n        tone.phaseDeltas[0] = phaseDelta / samplesInPeriod;\r\n        tone.expression = expression;\r\n        tone.noiseSample = noiseSample;\r\n\r\n        synth.sanitizeFilters(filters);\r\n        tone.initialNoteFilterInput1 = initialFilterInput1;\r\n        tone.initialNoteFilterInput2 = initialFilterInput2;\r\n    }\r\n\r\n    private static drumsetSynth(synth: Synth, bufferIndex: number, runLength: number, tone: Tone, instrumentState: InstrumentState): void {\r\n        const sign: number = instrumentState.invertWave ? -1 : 1;\r\n        const data: Float32Array = synth.tempMonoInstrumentSampleBuffer!;\r\n        let wave: Float32Array = instrumentState.getDrumsetWave(tone.drumsetPitch!);\r\n        const referenceDelta: number = InstrumentState.drumsetIndexReferenceDelta(tone.drumsetPitch!);\r\n        let phaseDelta: number = tone.phaseDeltas[0] / referenceDelta;\r\n        const phaseDeltaScale: number = +tone.phaseDeltaScales[0];\r\n        let expression: number = +tone.expression;\r\n        const expressionDelta: number = +tone.expressionDelta;\r\n\r\n        const filters: DynamicBiquadFilter[] = tone.noteFilters;\r\n        const filterCount: number = tone.noteFilterCount | 0;\r\n        let initialFilterInput1: number = +tone.initialNoteFilterInput1;\r\n        let initialFilterInput2: number = +tone.initialNoteFilterInput2;\r\n        const applyFilters: Function = Synth.applyFilters;\r\n\r\n        let phase: number = (tone.phases[0] % 1) * Config.spectrumNoiseLength;\r\n        // Zero phase means the tone was reset, just give noise a random start phase instead.\r\n        if (tone.phases[0] == 0) phase = Synth.findRandomZeroCrossing(wave, Config.spectrumNoiseLength, synth, tone) + phaseDelta;\r\n        const phaseMask: number = Config.spectrumNoiseLength - 1;\r\n\r\n        const stopIndex: number = bufferIndex + runLength;\r\n        for (let sampleIndex: number = bufferIndex; sampleIndex < stopIndex; sampleIndex++) {\r\n            const phaseInt: number = phase | 0;\r\n            const index: number = phaseInt & phaseMask;\r\n            let noiseSample: number = wave[index];\r\n            const phaseRatio: number = phase - phaseInt;\r\n            noiseSample += (wave[index + 1] - noiseSample) * phaseRatio;\r\n\r\n            const inputSample: number = noiseSample*sign;\r\n            const sample: number = applyFilters(inputSample, initialFilterInput1, initialFilterInput2, filterCount, filters);\r\n            initialFilterInput2 = initialFilterInput1;\r\n            initialFilterInput1 = inputSample;\r\n\r\n            phase += phaseDelta;\r\n            phaseDelta *= phaseDeltaScale;\r\n\r\n            const output: number = sample * expression;\r\n            expression += expressionDelta;\r\n\r\n            data[sampleIndex] += output;\r\n        }\r\n\r\n        tone.phases[0] = phase / Config.spectrumNoiseLength;\r\n        tone.phaseDeltas[0] = phaseDelta * referenceDelta;\r\n        tone.expression = expression;\r\n\r\n        synth.sanitizeFilters(filters);\r\n        tone.initialNoteFilterInput1 = initialFilterInput1;\r\n        tone.initialNoteFilterInput2 = initialFilterInput2;\r\n    }\r\n\r\n    private static modSynth(synth: Synth, stereoBufferIndex: number, roundedSamplesPerTick: number, tone: Tone, instrument: Instrument): void {\r\n        // Note: present modulator value is tone.expressionStarts[0].\r\n\r\n        if (!synth.song) return;\r\n\r\n        let mod: number = Config.modCount - 1 - tone.pitches[0];\r\n\r\n        // Flagged as invalid because unused by current settings, skip\r\n        if (instrument.invalidModulators[mod]) return;\r\n\r\n        let setting: number = instrument.modulators[mod];\r\n\r\n        // Generate list of used instruments\r\n        let usedInstruments: number[] = [];\r\n        if (Config.modulators[instrument.modulators[mod]].forSong) {\r\n            // Instrument doesn't matter for song, just push a random index to run the modsynth once\r\n            usedInstruments.push(0);\r\n        } else {\r\n            // All\r\n            if (instrument.modInstruments[mod] == synth.song.channels[instrument.modChannels[mod]].instruments.length) {\r\n                for (let i: number = 0; i < synth.song.channels[instrument.modChannels[mod]].instruments.length; i++) {\r\n                    usedInstruments.push(i);\r\n                }\r\n            }\r\n            // Active\r\n            else if (instrument.modInstruments[mod] > synth.song.channels[instrument.modChannels[mod]].instruments.length) {\r\n                if (synth.song.getPattern(instrument.modChannels[mod], synth.bar) != null)\r\n                    usedInstruments = synth.song.getPattern(instrument.modChannels[mod], synth.bar)!.instruments;\r\n            } else {\r\n                usedInstruments.push(instrument.modInstruments[mod]);\r\n            }\r\n        }\r\n\r\n        for (let instrumentIndex: number = 0; instrumentIndex < usedInstruments.length; instrumentIndex++) {\r\n\r\n            synth.setModValue(tone.expression, tone.expression + tone.expressionDelta, mod, instrument.modChannels[mod], usedInstruments[instrumentIndex], setting);\r\n\r\n            // Reset arps, but only at the start of the note\r\n            if (setting == Config.modulators.dictionary[\"reset arp\"].index && synth.tick == 0 && tone.noteStartPart == synth.beat * Config.partsPerBeat + synth.part) {\r\n                synth.song.channels[instrument.modChannels[mod]].instruments[usedInstruments[instrumentIndex]].arpTime = 0;\r\n            }\r\n            // Denote next bar skip\r\n            else if (setting == Config.modulators.dictionary[\"next bar\"].index) {\r\n                synth.wantToSkip = true;\r\n            }\r\n            // Extra info for eq filter target needs to be set as well\r\n            else if (setting == Config.modulators.dictionary[\"eq filter\"].index) {\r\n                const tgtInstrument = synth.song.channels[instrument.modChannels[mod]].instruments[usedInstruments[instrumentIndex]];\r\n\r\n                if (!tgtInstrument.eqFilterType) {\r\n\r\n                    let dotTarget = instrument.modFilterTypes[mod] | 0;\r\n\r\n                    if (dotTarget == 0) { // Morph. Figure out the target filter's X/Y coords for this point. If no point exists with this index, or point types don't match, do lerp-out for this point and lerp-in of a new point\r\n\r\n                        let pinIdx: number = 0;\r\n                        const currentPart: number = synth.getTicksIntoBar() / Config.ticksPerPart;\r\n                        while (tone.note!.start + tone.note!.pins[pinIdx].time <= currentPart) pinIdx++;\r\n                        // 0 to 1 based on distance to next morph\r\n                        //let lerpStartRatio: number = (currentPart - tone.note!.pins[pinIdx - 1].time) / (tone.note!.pins[pinIdx].time - tone.note!.pins[pinIdx - 1].time);\r\n                        let lerpEndRatio: number = ((currentPart - tone.note!.start + (roundedSamplesPerTick / (synth.getSamplesPerTick() * Config.ticksPerPart)) * Config.ticksPerPart) - tone.note!.pins[pinIdx - 1].time) / (tone.note!.pins[pinIdx].time - tone.note!.pins[pinIdx - 1].time);\r\n\r\n                        // Compute the new settings to go to.\r\n                        if (tgtInstrument.eqSubFilters[tone.note!.pins[pinIdx - 1].size] != null || tgtInstrument.eqSubFilters[tone.note!.pins[pinIdx].size] != null) {\r\n                            tgtInstrument.tmpEqFilterEnd = FilterSettings.lerpFilters(tgtInstrument.eqSubFilters[tone.note!.pins[pinIdx - 1].size]!, tgtInstrument.eqSubFilters[tone.note!.pins[pinIdx].size]!, lerpEndRatio);\r\n                        } else {\r\n                            // No mutation will occur to the filter object so we can safely return it without copying\r\n                            tgtInstrument.tmpEqFilterEnd = tgtInstrument.eqFilter;\r\n                        }\r\n\r\n                    } // Target (1 is dot 1 X, 2 is dot 1 Y, etc.)\r\n                    else {\r\n                        // Since we are directly manipulating the filter, make sure it is a new one and not an actual one of the instrument's filters\r\n                        for (let i: number = 0; i < Config.filterMorphCount; i++) {\r\n                            if (tgtInstrument.tmpEqFilterEnd == tgtInstrument.eqSubFilters[i] && tgtInstrument.tmpEqFilterEnd != null) {\r\n                                tgtInstrument.tmpEqFilterEnd = new FilterSettings();\r\n                                tgtInstrument.tmpEqFilterEnd.fromJsonObject(tgtInstrument.eqSubFilters[i]!.toJsonObject());\r\n                            }\r\n                        }\r\n                        if (tgtInstrument.tmpEqFilterEnd == null) {\r\n                            tgtInstrument.tmpEqFilterEnd = new FilterSettings();\r\n                            tgtInstrument.tmpEqFilterEnd.fromJsonObject(tgtInstrument.eqFilter.toJsonObject());\r\n                        }\r\n\r\n                        if (tgtInstrument.tmpEqFilterEnd.controlPointCount > Math.floor((dotTarget - 1) / 2)) {\r\n                            if (dotTarget % 2) { // X\r\n                                tgtInstrument.tmpEqFilterEnd.controlPoints[Math.floor((dotTarget - 1) / 2)].freq = tone.expression + tone.expressionDelta;\r\n                            } else { // Y\r\n                                tgtInstrument.tmpEqFilterEnd.controlPoints[Math.floor((dotTarget - 1) / 2)].gain = tone.expression + tone.expressionDelta;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Extra info for note filter target needs to be set as well\r\n            else if (setting == Config.modulators.dictionary[\"note filter\"].index) {\r\n                const tgtInstrument = synth.song.channels[instrument.modChannels[mod]].instruments[usedInstruments[instrumentIndex]];\r\n\r\n                if (!tgtInstrument.noteFilterType) {\r\n                    let dotTarget = instrument.modFilterTypes[mod] | 0;\r\n\r\n                    if (dotTarget == 0) { // Morph. Figure out the target filter's X/Y coords for this point. If no point exists with this index, or point types don't match, do lerp-out for this point and lerp-in of a new point\r\n\r\n                        let pinIdx: number = 0;\r\n                        const currentPart: number = synth.getTicksIntoBar() / Config.ticksPerPart;\r\n                        while (tone.note!.start + tone.note!.pins[pinIdx].time <= currentPart) pinIdx++;\r\n                        // 0 to 1 based on distance to next morph\r\n                        //let lerpStartRatio: number = (currentPart - tone.note!.pins[pinIdx - 1].time) / (tone.note!.pins[pinIdx].time - tone.note!.pins[pinIdx - 1].time);\r\n                        let lerpEndRatio: number = ((currentPart - tone.note!.start + (roundedSamplesPerTick / (synth.getSamplesPerTick() * Config.ticksPerPart)) * Config.ticksPerPart) - tone.note!.pins[pinIdx - 1].time) / (tone.note!.pins[pinIdx].time - tone.note!.pins[pinIdx - 1].time);\r\n\r\n                        // Compute the new settings to go to.\r\n                        if (tgtInstrument.noteSubFilters[tone.note!.pins[pinIdx - 1].size] != null || tgtInstrument.noteSubFilters[tone.note!.pins[pinIdx].size] != null) {\r\n                            tgtInstrument.tmpNoteFilterEnd = FilterSettings.lerpFilters(tgtInstrument.noteSubFilters[tone.note!.pins[pinIdx - 1].size]!, tgtInstrument.noteSubFilters[tone.note!.pins[pinIdx].size]!, lerpEndRatio);\r\n                        } else {\r\n                            // No mutation will occur to the filter object so we can safely return it without copying\r\n                            tgtInstrument.tmpNoteFilterEnd = tgtInstrument.noteFilter;\r\n                        }\r\n\r\n                    } // Target (1 is dot 1 X, 2 is dot 1 Y, etc.)\r\n                    else {\r\n                        // Since we are directly manipulating the filter, make sure it is a new one and not an actual one of the instrument's filters\r\n\r\n                        for (let i: number = 0; i < Config.filterMorphCount; i++) {\r\n                            if (tgtInstrument.tmpNoteFilterEnd == tgtInstrument.noteSubFilters[i] && tgtInstrument.tmpNoteFilterEnd != null) {\r\n                                tgtInstrument.tmpNoteFilterEnd = new FilterSettings();\r\n                                tgtInstrument.tmpNoteFilterEnd.fromJsonObject(tgtInstrument.noteSubFilters[i]!.toJsonObject());\r\n                            }\r\n                        }\r\n                        if (tgtInstrument.tmpNoteFilterEnd == null) {\r\n                            tgtInstrument.tmpNoteFilterEnd = new FilterSettings();\r\n                            tgtInstrument.tmpNoteFilterEnd.fromJsonObject(tgtInstrument.noteFilter.toJsonObject());\r\n                        }\r\n\r\n                        if (tgtInstrument.tmpNoteFilterEnd.controlPointCount > Math.floor((dotTarget - 1) / 2)) {\r\n                            if (dotTarget % 2) { // X\r\n                                tgtInstrument.tmpNoteFilterEnd.controlPoints[Math.floor((dotTarget - 1) / 2)].freq = tone.expression + tone.expressionDelta;\r\n                            } else { // Y\r\n                                tgtInstrument.tmpNoteFilterEnd.controlPoints[Math.floor((dotTarget - 1) / 2)].gain = tone.expression + tone.expressionDelta;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static findRandomZeroCrossing(wave: Float32Array, waveLength: number, synth: Synth, tone: Tone): number {\r\n        const randOff: number = Math.abs(Math.sin((tone.noteStartPart+tone.noteEndPart+tone.pitches[0]+synth.bar)*10000)) //Makes the random noise deterministric so that invert wave works properly\r\n        let phase: number = randOff * waveLength;\r\n        const phaseMask: number = waveLength - 1;\r\n\r\n        // Spectrum and drumset waves sounds best when they start at a zero crossing,\r\n        // otherwise they pop. Try to find a zero crossing.\r\n        let indexPrev: number = phase & phaseMask;\r\n        let wavePrev: number = wave[indexPrev];\r\n        const stride: number = 16;\r\n        for (let attemptsRemaining: number = 128; attemptsRemaining > 0; attemptsRemaining--) {\r\n            const indexNext: number = (indexPrev + stride) & phaseMask;\r\n            const waveNext: number = wave[indexNext];\r\n            if (wavePrev * waveNext <= 0.0) {\r\n                // Found a zero crossing! Now let's narrow it down to two adjacent sample indices.\r\n                for (let i: number = 0; i < stride; i++) {\r\n                    const innerIndexNext: number = (indexPrev + 1) & phaseMask;\r\n                    const innerWaveNext: number = wave[innerIndexNext];\r\n                    if (wavePrev * innerWaveNext <= 0.0) {\r\n                        // Found the zero crossing again! Now let's find the exact intersection.\r\n                        const slope: number = innerWaveNext - wavePrev;\r\n                        phase = indexPrev;\r\n                        if (Math.abs(slope) > 0.00000001) {\r\n                            phase += -wavePrev / slope;\r\n                        }\r\n                        phase = Math.max(0, phase) % waveLength;\r\n                        break;\r\n                    } else {\r\n                        indexPrev = innerIndexNext;\r\n                        wavePrev = innerWaveNext;\r\n                    }\r\n                }\r\n                break;\r\n            } else {\r\n                indexPrev = indexNext;\r\n                wavePrev = waveNext;\r\n            }\r\n        }\r\n\r\n        return phase;\r\n    }\r\n\r\n    public static instrumentVolumeToVolumeMult(instrumentVolume: number): number {\r\n        return (instrumentVolume == -Config.volumeRange / 2.0) ? 0.0 : Math.pow(2, Config.volumeLogScale * instrumentVolume);\r\n    }\r\n    public static volumeMultToInstrumentVolume(volumeMult: number): number {\r\n        return (volumeMult <= 0.0) ? -Config.volumeRange / 2 : Math.min(Config.volumeRange, (Math.log(volumeMult) / Math.LN2) / Config.volumeLogScale);\r\n    }\r\n    public static noteSizeToVolumeMult(size: number): number {\r\n        return Math.pow(Math.max(0.0, size) / Config.noteSizeMax, 1.5);\r\n    }\r\n    public static volumeMultToNoteSize(volumeMult: number): number {\r\n        return Math.pow(Math.max(0.0, volumeMult), 1 / 1.5) * Config.noteSizeMax;\r\n    }\r\n\r\n    public static fadeInSettingToSeconds(setting: number): number {\r\n        return 0.0125 * (0.95 * setting + 0.05 * setting * setting);\r\n    }\r\n    public static secondsToFadeInSetting(seconds: number): number {\r\n        return clamp(0, Config.fadeInRange, Math.round((-0.95 + Math.sqrt(0.9025 + 0.2 * seconds / 0.0125)) / 0.1));\r\n    }\r\n    public static fadeOutSettingToTicks(setting: number): number {\r\n        return Config.fadeOutTicks[setting];\r\n    }\r\n    public static ticksToFadeOutSetting(ticks: number): number {\r\n        let lower: number = Config.fadeOutTicks[0];\r\n        if (ticks <= lower) return 0;\r\n        for (let i: number = 1; i < Config.fadeOutTicks.length; i++) {\r\n            let upper: number = Config.fadeOutTicks[i];\r\n            if (ticks <= upper) return (ticks < (lower + upper) / 2) ? i - 1 : i;\r\n            lower = upper;\r\n        }\r\n        return Config.fadeOutTicks.length - 1;\r\n    }\r\n\r\n    public static detuneToCents(detune: number): number {\r\n        // BeepBox formula, for reference:\r\n        // return detune * (Math.abs(detune) + 1) / 2;\r\n        return detune - Config.detuneCenter;\r\n    }\r\n    public static centsToDetune(cents: number): number {\r\n        // BeepBox formula, for reference:\r\n        // return Math.sign(cents) * (Math.sqrt(1 + 8 * Math.abs(cents)) - 1) / 2.0;\r\n        return cents + Config.detuneCenter;\r\n    }\r\n\r\n    public static getOperatorWave(waveform: number, pulseWidth: number) {\r\n        if (waveform != 3) {\r\n            return Config.operatorWaves[waveform];\r\n        }\r\n        else {\r\n            return Config.pwmOperatorWaves[pulseWidth];\r\n        }\r\n    }\r\n\r\n    private getSamplesPerTick(): number {\r\n        if (this.song == null) return 0;\r\n        let beatsPerMinute: number = this.song.getBeatsPerMinute();\r\n        if (this.isModActive(Config.modulators.dictionary[\"tempo\"].index)) {\r\n            beatsPerMinute = this.getModValue(Config.modulators.dictionary[\"tempo\"].index);\r\n        }\r\n        return this.getSamplesPerTickSpecificBPM(beatsPerMinute);\r\n    }\r\n\r\n    private getSamplesPerTickSpecificBPM(beatsPerMinute: number): number {\r\n        const beatsPerSecond: number = beatsPerMinute / 60.0;\r\n        const partsPerSecond: number = Config.partsPerBeat * beatsPerSecond;\r\n        const tickPerSecond: number = Config.ticksPerPart * partsPerSecond;\r\n        return this.samplesPerSecond / tickPerSecond;\r\n    }\r\n\r\n    public static fittingPowerOfTwo(x: number): number {\r\n        return 1 << (32 - Math.clz32(Math.ceil(x) - 1));\r\n    }\r\n\r\n    private sanitizeFilters(filters: DynamicBiquadFilter[]): void {\r\n        let reset: boolean = false;\r\n        for (const filter of filters) {\r\n            const output1: number = Math.abs(filter.output1);\r\n            const output2: number = Math.abs(filter.output2);\r\n            // If either is a large value, Infinity, or NaN, then just reset all filter history.\r\n            if (!(output1 < 100) || !(output2 < 100)) {\r\n                reset = true;\r\n                break;\r\n            }\r\n            if (output1 < epsilon) filter.output1 = 0.0;\r\n            if (output2 < epsilon) filter.output2 = 0.0;\r\n        }\r\n        if (reset) {\r\n            for (const filter of filters) {\r\n                filter.output1 = 0.0;\r\n                filter.output2 = 0.0;\r\n            }\r\n        }\r\n    }\r\n\r\n    public static sanitizeDelayLine(delayLine: Float32Array, lastIndex: number, mask: number): void {\r\n        while (true) {\r\n            lastIndex--;\r\n            const index: number = lastIndex & mask;\r\n            const sample: number = Math.abs(delayLine[index]);\r\n            if (Number.isFinite(sample) && (sample == 0.0 || sample >= epsilon)) break;\r\n            delayLine[index] = 0.0;\r\n        }\r\n    }\r\n\r\n    public static applyFilters(sample: number, input1: number, input2: number, filterCount: number, filters: DynamicBiquadFilter[]): number {\r\n        for (let i: number = 0; i < filterCount; i++) {\r\n            const filter: DynamicBiquadFilter = filters[i];\r\n            const output1: number = filter.output1;\r\n            const output2: number = filter.output2;\r\n            const a1: number = filter.a1;\r\n            const a2: number = filter.a2;\r\n            const b0: number = filter.b0;\r\n            const b1: number = filter.b1;\r\n            const b2: number = filter.b2;\r\n            sample = b0 * sample + b1 * input1 + b2 * input2 - a1 * output1 - a2 * output2;\r\n            filter.a1 = a1 + filter.a1Delta;\r\n            filter.a2 = a2 + filter.a2Delta;\r\n            if (filter.useMultiplicativeInputCoefficients) {\r\n                filter.b0 = b0 * filter.b0Delta;\r\n                filter.b1 = b1 * filter.b1Delta;\r\n                filter.b2 = b2 * filter.b2Delta;\r\n            } else {\r\n                filter.b0 = b0 + filter.b0Delta;\r\n                filter.b1 = b1 + filter.b1Delta;\r\n                filter.b2 = b2 + filter.b2Delta;\r\n            }\r\n            filter.output2 = output1;\r\n            filter.output1 = sample;\r\n            // Updating the input values is waste if the next filter doesn't exist...\r\n            input2 = output2;\r\n            input1 = output1;\r\n        }\r\n        return sample;\r\n    }\r\n}\r\n\r\n// When compiling synth.ts as a standalone module named \"beepbox\", expose these classes as members to JavaScript:\r\nexport { Dictionary, DictionaryArray, FilterType, EnvelopeType, InstrumentType, Transition, Chord, Envelope, Config };\r\n"],"mappings":"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I,GAAI,KAAO,CAAErB,eAAkB,UAAWqB,SAAY,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAO,CAAErB,eAAkB,UAAWqB,SAAY,CAAC,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAO,CAAErB,eAAkB,UAAWqB,SAAY,CAAC,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAO,CAAErB,eAAkB,UAAWqB,SAAY,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAO,CAAErB,eAAkB,UAAWqB,SAAY,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAO,CAAErB,eAAkB,UAAWqB,SAAY,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,KAAO,CAAErB,eAAkB,UAAWqB,SAAY,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAA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"}